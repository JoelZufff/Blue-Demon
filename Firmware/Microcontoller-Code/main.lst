CCS PCH C Compiler, Version 5.112, 29001               28-abr.-24 23:23

               Filename:   C:\Users\diego\Desktop\Mordu\Firmware\Microcontoller-Code\main.lst

               ROM used:   4460 bytes (7%)
                           Largest free fragment is 61072
               RAM used:   62 (2%) at main() level
                           139 (4%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   1052
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   0376
00060:  BTFSS  F9D.5
00062:  GOTO   006C
00066:  BTFSC  F9E.5
00068:  GOTO   02DE
0006C:  MOVFF  0E,00
00070:  MOVFF  0F,01
00074:  MOVFF  10,02
00078:  MOVFF  11,03
0007C:  MOVFF  0C,FE9
00080:  MOVFF  07,FEA
00084:  BSF    07.7
00086:  MOVFF  08,FE1
0008A:  MOVFF  09,FE2
0008E:  MOVFF  0A,FD9
00092:  MOVFF  0B,FDA
00096:  MOVFF  12,FF3
0009A:  MOVFF  13,FF4
0009E:  MOVFF  14,FFA
000A2:  MOVFF  15,FF5
000A6:  MOVFF  16,FF6
000AA:  MOVFF  17,FF7
000AE:  MOVF   04,W
000B0:  MOVFF  06,FE0
000B4:  MOVFF  05,FD8
000B8:  RETFIE 0
.................... // --------------- Preprocesadores de microcontrolador -------------- //
.................... #include    <18F26K22.h>                                                // Libreria del Microcontrolador
.................... //////////// Standard Header file for the PIC18F26K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F26K22
000BA:  MOVF   x86,W
000BC:  XORWF  x88,W
000BE:  ANDLW  80
000C0:  MOVWF  x8A
000C2:  BTFSS  x86.7
000C4:  BRA    00D0
000C6:  COMF   x85,F
000C8:  COMF   x86,F
000CA:  INCF   x85,F
000CC:  BTFSC  FD8.2
000CE:  INCF   x86,F
000D0:  BTFSS  x88.7
000D2:  BRA    00DE
000D4:  COMF   x87,F
000D6:  COMF   x88,F
000D8:  INCF   x87,F
000DA:  BTFSC  FD8.2
000DC:  INCF   x88,F
000DE:  MOVF   x85,W
000E0:  MULWF  x87
000E2:  MOVFF  FF3,01
000E6:  MOVFF  FF4,00
000EA:  MULWF  x88
000EC:  MOVF   FF3,W
000EE:  ADDWF  00,F
000F0:  MOVF   x86,W
000F2:  MULWF  x87
000F4:  MOVF   FF3,W
000F6:  ADDWFC 00,W
000F8:  MOVWF  02
000FA:  BTFSS  x8A.7
000FC:  BRA    0108
000FE:  COMF   01,F
00100:  COMF   02,F
00102:  INCF   01,F
00104:  BTFSC  FD8.2
00106:  INCF   02,F
00108:  GOTO   01E2 (RETURN)
*
003B6:  MOVF   43,W
003B8:  MULWF  45
003BA:  MOVFF  FF3,01
003BE:  MOVFF  FF4,00
003C2:  MULWF  46
003C4:  MOVF   FF3,W
003C6:  ADDWF  00,F
003C8:  MOVF   44,W
003CA:  MULWF  45
003CC:  MOVF   FF3,W
003CE:  ADDWFC 00,W
003D0:  MOVWF  02
003D2:  RETURN 0
*
0047E:  MOVF   58,W
00480:  ANDLW  07
00482:  MOVWF  00
00484:  RRCF   58,W
00486:  MOVWF  01
00488:  RRCF   01,F
0048A:  RRCF   01,F
0048C:  MOVLW  1F
0048E:  ANDWF  01,F
00490:  MOVF   01,W
00492:  ADDWF  5A,W
00494:  MOVWF  FE9
00496:  MOVLW  00
00498:  ADDWFC 5B,W
0049A:  MOVWF  FEA
0049C:  CLRF   01
0049E:  INCF   01,F
004A0:  INCF   00,F
004A2:  BRA    04A6
004A4:  RLCF   01,F
004A6:  DECFSZ 00,F
004A8:  BRA    04A4
004AA:  MOVF   59,F
004AC:  BZ    04B4
004AE:  MOVF   01,W
004B0:  IORWF  FEF,F
004B2:  BRA    04BA
004B4:  COMF   01,F
004B6:  MOVF   01,W
004B8:  ANDWF  FEF,F
004BA:  RETURN 0
*
0052E:  MOVLW  8E
00530:  MOVWF  00
00532:  MOVFF  50,01
00536:  MOVFF  4F,02
0053A:  CLRF   03
0053C:  BTFSS  50.7
0053E:  BRA    054A
00540:  COMF   01,F
00542:  COMF   02,F
00544:  INCF   02,F
00546:  BNZ   054A
00548:  INCF   01,F
0054A:  MOVF   01,F
0054C:  BNZ   0560
0054E:  MOVFF  02,01
00552:  CLRF   02
00554:  MOVLW  08
00556:  SUBWF  00,F
00558:  MOVF   01,F
0055A:  BNZ   0560
0055C:  CLRF   00
0055E:  BRA    0574
00560:  BCF    FD8.0
00562:  BTFSC  01.7
00564:  BRA    056E
00566:  RLCF   02,F
00568:  RLCF   01,F
0056A:  DECF   00,F
0056C:  BRA    0560
0056E:  BTFSC  50.7
00570:  BRA    0574
00572:  BCF    01.7
00574:  RETURN 0
00576:  MOVF   56,W
00578:  BTFSC  FD8.2
0057A:  BRA    065E
0057C:  MOVWF  00
0057E:  MOVF   5A,W
00580:  BTFSC  FD8.2
00582:  BRA    065E
00584:  ADDWF  00,F
00586:  BNC   0590
00588:  MOVLW  81
0058A:  ADDWF  00,F
0058C:  BC    065E
0058E:  BRA    0598
00590:  MOVLW  7F
00592:  SUBWF  00,F
00594:  BNC   065E
00596:  BZ    065E
00598:  MOVFF  57,5E
0059C:  MOVF   5B,W
0059E:  XORWF  5E,F
005A0:  BSF    57.7
005A2:  BSF    5B.7
005A4:  MOVF   59,W
005A6:  MULWF  5D
005A8:  MOVFF  FF4,60
005AC:  MOVF   58,W
005AE:  MULWF  5C
005B0:  MOVFF  FF4,03
005B4:  MOVFF  FF3,5F
005B8:  MULWF  5D
005BA:  MOVF   FF3,W
005BC:  ADDWF  x60,F
005BE:  MOVF   FF4,W
005C0:  ADDWFC 5F,F
005C2:  MOVLW  00
005C4:  ADDWFC 03,F
005C6:  MOVF   59,W
005C8:  MULWF  5C
005CA:  MOVF   FF3,W
005CC:  ADDWF  x60,F
005CE:  MOVF   FF4,W
005D0:  ADDWFC 5F,F
005D2:  MOVLW  00
005D4:  CLRF   02
005D6:  ADDWFC 03,F
005D8:  ADDWFC 02,F
005DA:  MOVF   57,W
005DC:  MULWF  5D
005DE:  MOVF   FF3,W
005E0:  ADDWF  5F,F
005E2:  MOVF   FF4,W
005E4:  ADDWFC 03,F
005E6:  MOVLW  00
005E8:  ADDWFC 02,F
005EA:  MOVF   57,W
005EC:  MULWF  5C
005EE:  MOVF   FF3,W
005F0:  ADDWF  03,F
005F2:  MOVF   FF4,W
005F4:  ADDWFC 02,F
005F6:  MOVLW  00
005F8:  CLRF   01
005FA:  ADDWFC 01,F
005FC:  MOVF   59,W
005FE:  MULWF  5B
00600:  MOVF   FF3,W
00602:  ADDWF  5F,F
00604:  MOVF   FF4,W
00606:  ADDWFC 03,F
00608:  MOVLW  00
0060A:  ADDWFC 02,F
0060C:  ADDWFC 01,F
0060E:  MOVF   58,W
00610:  MULWF  5B
00612:  MOVF   FF3,W
00614:  ADDWF  03,F
00616:  MOVF   FF4,W
00618:  ADDWFC 02,F
0061A:  MOVLW  00
0061C:  ADDWFC 01,F
0061E:  MOVF   57,W
00620:  MULWF  5B
00622:  MOVF   FF3,W
00624:  ADDWF  02,F
00626:  MOVF   FF4,W
00628:  ADDWFC 01,F
0062A:  INCF   00,F
0062C:  BTFSC  01.7
0062E:  BRA    063A
00630:  RLCF   5F,F
00632:  RLCF   03,F
00634:  RLCF   02,F
00636:  RLCF   01,F
00638:  DECF   00,F
0063A:  MOVLW  00
0063C:  BTFSS  5F.7
0063E:  BRA    0654
00640:  INCF   03,F
00642:  ADDWFC 02,F
00644:  ADDWFC 01,F
00646:  MOVF   01,W
00648:  BNZ   0654
0064A:  MOVF   02,W
0064C:  BNZ   0654
0064E:  MOVF   03,W
00650:  BNZ   0654
00652:  INCF   00,F
00654:  BTFSC  5E.7
00656:  BSF    01.7
00658:  BTFSS  5E.7
0065A:  BCF    01.7
0065C:  BRA    0666
0065E:  CLRF   00
00660:  CLRF   01
00662:  CLRF   02
00664:  CLRF   03
00666:  RETURN 0
00668:  MOVF   5A,W
0066A:  BTFSC  FD8.2
0066C:  BRA    07B8
0066E:  MOVWF  x66
00670:  MOVF   5E,W
00672:  BTFSC  FD8.2
00674:  BRA    07B8
00676:  SUBWF  x66,F
00678:  BNC   0684
0067A:  MOVLW  7F
0067C:  ADDWF  x66,F
0067E:  BTFSC  FD8.0
00680:  BRA    07B8
00682:  BRA    0690
00684:  MOVLW  81
00686:  SUBWF  x66,F
00688:  BTFSS  FD8.0
0068A:  BRA    07B8
0068C:  BTFSC  FD8.2
0068E:  BRA    07B8
00690:  MOVFF  66,00
00694:  CLRF   01
00696:  CLRF   02
00698:  CLRF   03
0069A:  CLRF   x65
0069C:  MOVFF  5B,64
006A0:  BSF    x64.7
006A2:  MOVFF  5C,63
006A6:  MOVFF  5D,62
006AA:  MOVLW  19
006AC:  MOVWF  x66
006AE:  MOVF   x61,W
006B0:  SUBWF  x62,F
006B2:  BC    06CE
006B4:  MOVLW  01
006B6:  SUBWF  x63,F
006B8:  BC    06CE
006BA:  SUBWF  x64,F
006BC:  BC    06CE
006BE:  SUBWF  x65,F
006C0:  BC    06CE
006C2:  INCF   x65,F
006C4:  INCF   x64,F
006C6:  INCF   x63,F
006C8:  MOVF   x61,W
006CA:  ADDWF  x62,F
006CC:  BRA    071E
006CE:  MOVF   x60,W
006D0:  SUBWF  x63,F
006D2:  BC    06F8
006D4:  MOVLW  01
006D6:  SUBWF  x64,F
006D8:  BC    06F8
006DA:  SUBWF  x65,F
006DC:  BC    06F8
006DE:  INCF   x65,F
006E0:  INCF   x64,F
006E2:  MOVF   x60,W
006E4:  ADDWF  x63,F
006E6:  MOVF   x61,W
006E8:  ADDWF  x62,F
006EA:  BNC   071E
006EC:  INCF   x63,F
006EE:  BNZ   071E
006F0:  INCF   x64,F
006F2:  BNZ   071E
006F4:  INCF   x65,F
006F6:  BRA    071E
006F8:  MOVF   5F,W
006FA:  IORLW  80
006FC:  SUBWF  x64,F
006FE:  BC    071C
00700:  MOVLW  01
00702:  SUBWF  x65,F
00704:  BC    071C
00706:  INCF   x65,F
00708:  MOVF   5F,W
0070A:  IORLW  80
0070C:  ADDWF  x64,F
0070E:  MOVF   x60,W
00710:  ADDWF  x63,F
00712:  BNC   06E6
00714:  INCF   x64,F
00716:  BNZ   06E6
00718:  INCF   x65,F
0071A:  BRA    06E6
0071C:  BSF    03.0
0071E:  DECFSZ x66,F
00720:  BRA    0724
00722:  BRA    073A
00724:  BCF    FD8.0
00726:  RLCF   x62,F
00728:  RLCF   x63,F
0072A:  RLCF   x64,F
0072C:  RLCF   x65,F
0072E:  BCF    FD8.0
00730:  RLCF   03,F
00732:  RLCF   02,F
00734:  RLCF   01,F
00736:  RLCF   x67,F
00738:  BRA    06AE
0073A:  BTFSS  x67.0
0073C:  BRA    074A
0073E:  BCF    FD8.0
00740:  RRCF   01,F
00742:  RRCF   02,F
00744:  RRCF   03,F
00746:  RRCF   x67,F
00748:  BRA    074E
0074A:  DECF   00,F
0074C:  BZ    07B8
0074E:  BTFSC  x67.7
00750:  BRA    078E
00752:  BCF    FD8.0
00754:  RLCF   x62,F
00756:  RLCF   x63,F
00758:  RLCF   x64,F
0075A:  RLCF   x65,F
0075C:  MOVF   x61,W
0075E:  SUBWF  x62,F
00760:  BC    0770
00762:  MOVLW  01
00764:  SUBWF  x63,F
00766:  BC    0770
00768:  SUBWF  x64,F
0076A:  BC    0770
0076C:  SUBWF  x65,F
0076E:  BNC   07A4
00770:  MOVF   x60,W
00772:  SUBWF  x63,F
00774:  BC    0780
00776:  MOVLW  01
00778:  SUBWF  x64,F
0077A:  BC    0780
0077C:  SUBWF  x65,F
0077E:  BNC   07A4
00780:  MOVF   5F,W
00782:  IORLW  80
00784:  SUBWF  x64,F
00786:  BC    078E
00788:  MOVLW  01
0078A:  SUBWF  x65,F
0078C:  BNC   07A4
0078E:  INCF   03,F
00790:  BNZ   07A4
00792:  INCF   02,F
00794:  BNZ   07A4
00796:  INCF   01,F
00798:  BNZ   07A4
0079A:  INCF   00,F
0079C:  BZ    07B8
0079E:  RRCF   01,F
007A0:  RRCF   02,F
007A2:  RRCF   03,F
007A4:  MOVFF  5B,66
007A8:  MOVF   5F,W
007AA:  XORWF  x66,F
007AC:  BTFSS  x66.7
007AE:  BRA    07B4
007B0:  BSF    01.7
007B2:  BRA    07C0
007B4:  BCF    01.7
007B6:  BRA    07C0
007B8:  CLRF   00
007BA:  CLRF   01
007BC:  CLRF   02
007BE:  CLRF   03
007C0:  RETURN 0
007C2:  MOVLW  80
007C4:  BTFSC  FD8.1
007C6:  XORWF  5F,F
007C8:  CLRF   x64
007CA:  CLRF   x65
007CC:  MOVFF  5B,63
007D0:  MOVF   5F,W
007D2:  XORWF  x63,F
007D4:  MOVF   5A,W
007D6:  BTFSC  FD8.2
007D8:  BRA    0992
007DA:  MOVWF  x62
007DC:  MOVWF  00
007DE:  MOVF   5E,W
007E0:  BTFSC  FD8.2
007E2:  BRA    09A4
007E4:  SUBWF  x62,F
007E6:  BTFSC  FD8.2
007E8:  BRA    08EC
007EA:  BNC   0866
007EC:  MOVFF  5F,68
007F0:  BSF    x68.7
007F2:  MOVFF  60,67
007F6:  MOVFF  61,66
007FA:  CLRF   x65
007FC:  BCF    FD8.0
007FE:  RRCF   x68,F
00800:  RRCF   x67,F
00802:  RRCF   x66,F
00804:  RRCF   x65,F
00806:  DECFSZ x62,F
00808:  BRA    07FA
0080A:  BTFSS  x63.7
0080C:  BRA    0814
0080E:  BSF    x64.0
00810:  BRA    09CC
00812:  BCF    x64.0
00814:  BCF    x62.0
00816:  BSF    x64.4
00818:  CLRF   FEA
0081A:  MOVLW  5D
0081C:  MOVWF  FE9
0081E:  BRA    09F2
00820:  BCF    x64.4
00822:  BTFSC  x63.7
00824:  BRA    083A
00826:  BTFSS  x62.0
00828:  BRA    0850
0082A:  RRCF   x68,F
0082C:  RRCF   x67,F
0082E:  RRCF   x66,F
00830:  RRCF   x65,F
00832:  INCF   00,F
00834:  BTFSC  FD8.2
00836:  BRA    09C2
00838:  BRA    0850
0083A:  BTFSC  x68.7
0083C:  BRA    0856
0083E:  BCF    FD8.0
00840:  RLCF   x65,F
00842:  RLCF   x66,F
00844:  RLCF   x67,F
00846:  RLCF   x68,F
00848:  DECF   00,F
0084A:  BTFSC  FD8.2
0084C:  BRA    09C2
0084E:  BRA    083A
00850:  BSF    x64.6
00852:  BRA    092A
00854:  BCF    x64.6
00856:  MOVFF  5B,63
0085A:  BTFSS  5B.7
0085C:  BRA    0862
0085E:  BSF    x68.7
00860:  BRA    09B4
00862:  BCF    x68.7
00864:  BRA    09B4
00866:  MOVFF  5E,62
0086A:  MOVFF  5E,00
0086E:  MOVF   5A,W
00870:  SUBWF  x62,F
00872:  MOVFF  5B,68
00876:  BSF    x68.7
00878:  MOVFF  5C,67
0087C:  MOVFF  5D,66
00880:  CLRF   x65
00882:  BCF    FD8.0
00884:  RRCF   x68,F
00886:  RRCF   x67,F
00888:  RRCF   x66,F
0088A:  RRCF   x65,F
0088C:  DECFSZ x62,F
0088E:  BRA    0880
00890:  BTFSS  x63.7
00892:  BRA    089A
00894:  BSF    x64.1
00896:  BRA    09CC
00898:  BCF    x64.1
0089A:  BCF    x62.0
0089C:  BSF    x64.5
0089E:  CLRF   FEA
008A0:  MOVLW  61
008A2:  MOVWF  FE9
008A4:  BRA    09F2
008A6:  BCF    x64.5
008A8:  BTFSC  x63.7
008AA:  BRA    08C0
008AC:  BTFSS  x62.0
008AE:  BRA    08D6
008B0:  RRCF   x68,F
008B2:  RRCF   x67,F
008B4:  RRCF   x66,F
008B6:  RRCF   x65,F
008B8:  INCF   00,F
008BA:  BTFSC  FD8.2
008BC:  BRA    09C2
008BE:  BRA    08D6
008C0:  BTFSC  x68.7
008C2:  BRA    08DC
008C4:  BCF    FD8.0
008C6:  RLCF   x65,F
008C8:  RLCF   x66,F
008CA:  RLCF   x67,F
008CC:  RLCF   x68,F
008CE:  DECF   00,F
008D0:  BTFSC  FD8.2
008D2:  BRA    09C2
008D4:  BRA    08C0
008D6:  BSF    x64.7
008D8:  BRA    092A
008DA:  BCF    x64.7
008DC:  MOVFF  5F,63
008E0:  BTFSS  5F.7
008E2:  BRA    08E8
008E4:  BSF    x68.7
008E6:  BRA    09B4
008E8:  BCF    x68.7
008EA:  BRA    09B4
008EC:  MOVFF  5F,68
008F0:  BSF    x68.7
008F2:  MOVFF  60,67
008F6:  MOVFF  61,66
008FA:  BTFSS  x63.7
008FC:  BRA    0906
008FE:  BCF    x68.7
00900:  BSF    x64.2
00902:  BRA    09CC
00904:  BCF    x64.2
00906:  CLRF   x65
00908:  BCF    x62.0
0090A:  CLRF   FEA
0090C:  MOVLW  5D
0090E:  MOVWF  FE9
00910:  BRA    09F2
00912:  BTFSC  x63.7
00914:  BRA    094E
00916:  MOVFF  5B,63
0091A:  BTFSS  x62.0
0091C:  BRA    092A
0091E:  RRCF   x68,F
00920:  RRCF   x67,F
00922:  RRCF   x66,F
00924:  RRCF   x65,F
00926:  INCF   00,F
00928:  BZ    09C2
0092A:  BTFSS  x65.7
0092C:  BRA    0944
0092E:  INCF   x66,F
00930:  BNZ   0944
00932:  INCF   x67,F
00934:  BNZ   0944
00936:  INCF   x68,F
00938:  BNZ   0944
0093A:  RRCF   x68,F
0093C:  RRCF   x67,F
0093E:  RRCF   x66,F
00940:  INCF   00,F
00942:  BZ    09C2
00944:  BTFSC  x64.6
00946:  BRA    0854
00948:  BTFSC  x64.7
0094A:  BRA    08DA
0094C:  BRA    0986
0094E:  MOVLW  80
00950:  XORWF  x68,F
00952:  BTFSS  x68.7
00954:  BRA    095E
00956:  BRA    09CC
00958:  MOVFF  5F,63
0095C:  BRA    0972
0095E:  MOVFF  5B,63
00962:  MOVF   x68,F
00964:  BNZ   0972
00966:  MOVF   x67,F
00968:  BNZ   0972
0096A:  MOVF   x66,F
0096C:  BNZ   0972
0096E:  CLRF   00
00970:  BRA    09B4
00972:  BTFSC  x68.7
00974:  BRA    0986
00976:  BCF    FD8.0
00978:  RLCF   x65,F
0097A:  RLCF   x66,F
0097C:  RLCF   x67,F
0097E:  RLCF   x68,F
00980:  DECFSZ 00,F
00982:  BRA    0972
00984:  BRA    09C2
00986:  BTFSS  x63.7
00988:  BRA    098E
0098A:  BSF    x68.7
0098C:  BRA    09B4
0098E:  BCF    x68.7
00990:  BRA    09B4
00992:  MOVFF  5E,00
00996:  MOVFF  5F,68
0099A:  MOVFF  60,67
0099E:  MOVFF  61,66
009A2:  BRA    09B4
009A4:  MOVFF  5A,00
009A8:  MOVFF  5B,68
009AC:  MOVFF  5C,67
009B0:  MOVFF  5D,66
009B4:  MOVFF  68,01
009B8:  MOVFF  67,02
009BC:  MOVFF  66,03
009C0:  BRA    0A2A
009C2:  CLRF   00
009C4:  CLRF   01
009C6:  CLRF   02
009C8:  CLRF   03
009CA:  BRA    0A2A
009CC:  CLRF   x65
009CE:  COMF   x66,F
009D0:  COMF   x67,F
009D2:  COMF   x68,F
009D4:  COMF   x65,F
009D6:  INCF   x65,F
009D8:  BNZ   09E4
009DA:  INCF   x66,F
009DC:  BNZ   09E4
009DE:  INCF   x67,F
009E0:  BNZ   09E4
009E2:  INCF   x68,F
009E4:  BTFSC  x64.0
009E6:  BRA    0812
009E8:  BTFSC  x64.1
009EA:  BRA    0898
009EC:  BTFSC  x64.2
009EE:  BRA    0904
009F0:  BRA    0958
009F2:  MOVF   FEF,W
009F4:  ADDWF  x66,F
009F6:  BNC   0A02
009F8:  INCF   x67,F
009FA:  BNZ   0A02
009FC:  INCF   x68,F
009FE:  BTFSC  FD8.2
00A00:  BSF    x62.0
00A02:  MOVF   FED,F
00A04:  MOVF   FEF,W
00A06:  ADDWF  x67,F
00A08:  BNC   0A10
00A0A:  INCF   x68,F
00A0C:  BTFSC  FD8.2
00A0E:  BSF    x62.0
00A10:  MOVF   FED,F
00A12:  MOVF   FEF,W
00A14:  BTFSC  FEF.7
00A16:  BRA    0A1A
00A18:  XORLW  80
00A1A:  ADDWF  x68,F
00A1C:  BTFSC  FD8.0
00A1E:  BSF    x62.0
00A20:  BTFSC  x64.4
00A22:  BRA    0820
00A24:  BTFSC  x64.5
00A26:  BRA    08A6
00A28:  BRA    0912
00A2A:  RETURN 0
00A2C:  MOVFF  57,5E
00A30:  MOVF   5B,W
00A32:  XORWF  5E,F
00A34:  BTFSS  5E.7
00A36:  BRA    0A42
00A38:  BCF    FD8.2
00A3A:  BCF    FD8.0
00A3C:  BTFSC  57.7
00A3E:  BSF    FD8.0
00A40:  BRA    0AA0
00A42:  MOVFF  57,5E
00A46:  MOVFF  5A,5F
00A4A:  MOVF   56,W
00A4C:  SUBWF  5F,F
00A4E:  BZ    0A5C
00A50:  BTFSS  5E.7
00A52:  BRA    0AA0
00A54:  MOVF   FD8,W
00A56:  XORLW  01
00A58:  MOVWF  FD8
00A5A:  BRA    0AA0
00A5C:  MOVFF  5B,5F
00A60:  MOVF   57,W
00A62:  SUBWF  5F,F
00A64:  BZ    0A72
00A66:  BTFSS  5E.7
00A68:  BRA    0AA0
00A6A:  MOVF   FD8,W
00A6C:  XORLW  01
00A6E:  MOVWF  FD8
00A70:  BRA    0AA0
00A72:  MOVFF  5C,5F
00A76:  MOVF   58,W
00A78:  SUBWF  5F,F
00A7A:  BZ    0A88
00A7C:  BTFSS  5E.7
00A7E:  BRA    0AA0
00A80:  MOVF   FD8,W
00A82:  XORLW  01
00A84:  MOVWF  FD8
00A86:  BRA    0AA0
00A88:  MOVFF  5D,5F
00A8C:  MOVF   59,W
00A8E:  SUBWF  5F,F
00A90:  BZ    0A9E
00A92:  BTFSS  5E.7
00A94:  BRA    0AA0
00A96:  MOVF   FD8,W
00A98:  XORLW  01
00A9A:  MOVWF  FD8
00A9C:  BRA    0AA0
00A9E:  BCF    FD8.0
00AA0:  GOTO   0AF8 (RETURN)
00AA4:  MOVLW  8E
00AA6:  MOVWF  00
00AA8:  MOVF   56,W
00AAA:  SUBWF  00,F
00AAC:  MOVFF  57,02
00AB0:  MOVFF  58,01
00AB4:  BSF    02.7
00AB6:  MOVF   00,F
00AB8:  BZ    0ACC
00ABA:  BCF    FD8.0
00ABC:  MOVF   02,F
00ABE:  BNZ   0AC4
00AC0:  MOVF   01,F
00AC2:  BZ    0ACC
00AC4:  RRCF   02,F
00AC6:  RRCF   01,F
00AC8:  DECFSZ 00,F
00ACA:  BRA    0ABA
00ACC:  BTFSS  57.7
00ACE:  BRA    0ADA
00AD0:  COMF   01,F
00AD2:  COMF   02,F
00AD4:  INCF   01,F
00AD6:  BTFSC  FD8.2
00AD8:  INCF   02,F
00ADA:  GOTO   0C22 (RETURN)
.................... 
.................... #list
.................... 
.................... #fuses      INTRC, NOWDT, NOPROTECT, NOLVP, NOMCLR, CCP2C1, CCP3B5      // Fusibles (Multiplexado de P2B en C0)
.................... #use        delay(internal = 16MHz)                                     // Configuracion de frecuencia y delay
*
00454:  CLRF   FEA
00456:  MOVLW  3D
00458:  MOVWF  FE9
0045A:  MOVF   FEF,W
0045C:  BZ    047A
0045E:  MOVLW  05
00460:  MOVWF  01
00462:  CLRF   00
00464:  DECFSZ 00,F
00466:  BRA    0464
00468:  DECFSZ 01,F
0046A:  BRA    0462
0046C:  MOVLW  2E
0046E:  MOVWF  00
00470:  DECFSZ 00,F
00472:  BRA    0470
00474:  BRA    0476
00476:  DECFSZ FEF,F
00478:  BRA    045E
0047A:  GOTO   1120 (RETURN)
.................... #use        rs232(rcv = pin_c7, xmit = pin_c6, baud = 9600, bits = 8, parity = n) 
.................... 
.................... #include    <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
0010C:  CLRF   x83
....................    sign = 0;
0010E:  CLRF   x81
....................    base = 10;
00110:  MOVLW  0A
00112:  MOVWF  x82
....................    result = 0;
00114:  CLRF   x80
00116:  CLRF   x7F
.................... 
....................    if (!s)
00118:  MOVF   x7D,W
0011A:  IORWF  x7E,W
0011C:  BNZ   0126
....................       return 0;
0011E:  MOVLW  00
00120:  MOVWF  01
00122:  MOVWF  02
00124:  BRA    02DC
....................    c = s[index++];
00126:  MOVF   x83,W
00128:  INCF   x83,F
0012A:  ADDWF  x7D,W
0012C:  MOVWF  FE9
0012E:  MOVLW  00
00130:  ADDWFC x7E,W
00132:  MOVWF  FEA
00134:  MOVFF  FEF,84
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
00138:  MOVF   x84,W
0013A:  SUBLW  2D
0013C:  BNZ   0156
....................    {
....................       sign = 1;         // Set the sign to negative
0013E:  MOVLW  01
00140:  MOVWF  x81
....................       c = s[index++];
00142:  MOVF   x83,W
00144:  INCF   x83,F
00146:  ADDWF  x7D,W
00148:  MOVWF  FE9
0014A:  MOVLW  00
0014C:  ADDWFC x7E,W
0014E:  MOVWF  FEA
00150:  MOVFF  FEF,84
....................    }
00154:  BRA    016E
....................    else if (c == '+')
00156:  MOVF   x84,W
00158:  SUBLW  2B
0015A:  BNZ   016E
....................    {
....................       c = s[index++];
0015C:  MOVF   x83,W
0015E:  INCF   x83,F
00160:  ADDWF  x7D,W
00162:  MOVWF  FE9
00164:  MOVLW  00
00166:  ADDWFC x7E,W
00168:  MOVWF  FEA
0016A:  MOVFF  FEF,84
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
0016E:  MOVF   x84,W
00170:  SUBLW  2F
00172:  BTFSC  FD8.0
00174:  BRA    02C0
00176:  MOVF   x84,W
00178:  SUBLW  39
0017A:  BTFSS  FD8.0
0017C:  BRA    02C0
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
0017E:  MOVF   x84,W
00180:  SUBLW  30
00182:  BNZ   01C0
00184:  MOVF   x83,W
00186:  ADDWF  x7D,W
00188:  MOVWF  FE9
0018A:  MOVLW  00
0018C:  ADDWFC x7E,W
0018E:  MOVWF  FEA
00190:  MOVF   FEF,W
00192:  SUBLW  78
00194:  BZ    01A8
00196:  MOVF   x83,W
00198:  ADDWF  x7D,W
0019A:  MOVWF  FE9
0019C:  MOVLW  00
0019E:  ADDWFC x7E,W
001A0:  MOVWF  FEA
001A2:  MOVF   FEF,W
001A4:  SUBLW  58
001A6:  BNZ   01C0
....................       {
....................          base = 16;
001A8:  MOVLW  10
001AA:  MOVWF  x82
....................          index++;
001AC:  INCF   x83,F
....................          c = s[index++];
001AE:  MOVF   x83,W
001B0:  INCF   x83,F
001B2:  ADDWF  x7D,W
001B4:  MOVWF  FE9
001B6:  MOVLW  00
001B8:  ADDWFC x7E,W
001BA:  MOVWF  FEA
001BC:  MOVFF  FEF,84
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
001C0:  MOVF   x82,W
001C2:  SUBLW  0A
001C4:  BNZ   0206
....................       {
....................          while (c >= '0' && c <= '9')
001C6:  MOVF   x84,W
001C8:  SUBLW  2F
001CA:  BC    0204
001CC:  MOVF   x84,W
001CE:  SUBLW  39
001D0:  BNC   0204
....................          {
....................             result = 10*result + (c - '0');
001D2:  CLRF   x86
001D4:  MOVLW  0A
001D6:  MOVWF  x85
001D8:  MOVFF  80,88
001DC:  MOVFF  7F,87
001E0:  BRA    00BA
001E2:  MOVLW  30
001E4:  SUBWF  x84,W
001E6:  ADDWF  01,W
001E8:  MOVWF  x7F
001EA:  MOVLW  00
001EC:  ADDWFC 02,W
001EE:  MOVWF  x80
....................             c = s[index++];
001F0:  MOVF   x83,W
001F2:  INCF   x83,F
001F4:  ADDWF  x7D,W
001F6:  MOVWF  FE9
001F8:  MOVLW  00
001FA:  ADDWFC x7E,W
001FC:  MOVWF  FEA
001FE:  MOVFF  FEF,84
00202:  BRA    01C6
....................          }
....................       }
00204:  BRA    02C0
....................       else if (base == 16)    // The number is a hexa number
00206:  MOVF   x82,W
00208:  SUBLW  10
0020A:  BNZ   02C0
....................       {
....................          c = toupper(c);
0020C:  MOVF   x84,W
0020E:  SUBLW  60
00210:  BC    021E
00212:  MOVF   x84,W
00214:  SUBLW  7A
00216:  BNC   021E
00218:  MOVF   x84,W
0021A:  ANDLW  DF
0021C:  BRA    0220
0021E:  MOVF   x84,W
00220:  MOVWF  x84
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
00222:  MOVF   x84,W
00224:  SUBLW  2F
00226:  BC    022E
00228:  MOVF   x84,W
0022A:  SUBLW  39
0022C:  BC    023A
0022E:  MOVF   x84,W
00230:  SUBLW  40
00232:  BC    02C0
00234:  MOVF   x84,W
00236:  SUBLW  46
00238:  BNC   02C0
....................          {
....................             if (c >= '0' && c <= '9')
0023A:  MOVF   x84,W
0023C:  SUBLW  2F
0023E:  BC    026E
00240:  MOVF   x84,W
00242:  SUBLW  39
00244:  BNC   026E
....................                result = (result << 4) + (c - '0');
00246:  RLCF   x7F,W
00248:  MOVWF  x85
0024A:  RLCF   x80,W
0024C:  MOVWF  x86
0024E:  RLCF   x85,F
00250:  RLCF   x86,F
00252:  RLCF   x85,F
00254:  RLCF   x86,F
00256:  RLCF   x85,F
00258:  RLCF   x86,F
0025A:  MOVLW  F0
0025C:  ANDWF  x85,F
0025E:  MOVLW  30
00260:  SUBWF  x84,W
00262:  ADDWF  x85,W
00264:  MOVWF  x7F
00266:  MOVLW  00
00268:  ADDWFC x86,W
0026A:  MOVWF  x80
0026C:  BRA    0296
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
0026E:  RLCF   x7F,W
00270:  MOVWF  x85
00272:  RLCF   x80,W
00274:  MOVWF  x86
00276:  RLCF   x85,F
00278:  RLCF   x86,F
0027A:  RLCF   x85,F
0027C:  RLCF   x86,F
0027E:  RLCF   x85,F
00280:  RLCF   x86,F
00282:  MOVLW  F0
00284:  ANDWF  x85,F
00286:  MOVLW  41
00288:  SUBWF  x84,W
0028A:  ADDLW  0A
0028C:  ADDWF  x85,W
0028E:  MOVWF  x7F
00290:  MOVLW  00
00292:  ADDWFC x86,W
00294:  MOVWF  x80
.................... 
....................             c = s[index++];c = toupper(c);
00296:  MOVF   x83,W
00298:  INCF   x83,F
0029A:  ADDWF  x7D,W
0029C:  MOVWF  FE9
0029E:  MOVLW  00
002A0:  ADDWFC x7E,W
002A2:  MOVWF  FEA
002A4:  MOVFF  FEF,84
002A8:  MOVF   x84,W
002AA:  SUBLW  60
002AC:  BC    02BA
002AE:  MOVF   x84,W
002B0:  SUBLW  7A
002B2:  BNC   02BA
002B4:  MOVF   x84,W
002B6:  ANDLW  DF
002B8:  BRA    02BC
002BA:  MOVF   x84,W
002BC:  MOVWF  x84
002BE:  BRA    0222
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
002C0:  MOVF   x82,W
002C2:  SUBLW  0A
002C4:  BNZ   02D4
002C6:  DECFSZ x81,W
002C8:  BRA    02D4
....................       result = -result;
002CA:  COMF   x7F,F
002CC:  COMF   x80,F
002CE:  INCF   x7F,F
002D0:  BTFSC  FD8.2
002D2:  INCF   x80,F
.................... 
....................    return(result);
002D4:  MOVFF  7F,01
002D8:  MOVFF  80,02
002DC:  RETURN 0
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include    "motor_control.c"
.................... #define     FORWARD     1
.................... #define     BACK        0
.................... 
.................... #define     max_dutycicle       320
.................... #define     min_dutycicle       max_dutycicle / 15
.................... 
.................... #define     max_trigger_value   255
.................... #define     max_joystick_value  32767.0
.................... 
.................... // -------------------- Direcciones de registros -------------------- //
.................... #BYTE       CCPTMRS0        = 0xF49
.................... #BYTE       CCPTMRS1        = 0xF48
.................... 
.................... #BYTE       CCP1CON         = 0xFBD
.................... #BYTE       CCP2CON         = 0xF66
.................... #BYTE       CCP3CON         = 0xF5D
.................... #BYTE       CCP4CON         = 0xF57
.................... 
.................... #BYTE       T2CON           = 0xFBA
.................... #BYTE       PR2             = 0xFBB
.................... 
.................... // -------------------------- Estructuras --------------------------- //
.................... struct bth_conection_t
.................... {
....................     short updated_data;
....................     short IsConnected;
....................     short Check;
.................... };
.................... 
.................... struct motor_t
.................... {
....................     int     *DutyCicle;
....................     long    IN1_pin;
....................     long    IN2_pin;
.................... };
.................... 
.................... struct controller_t
.................... {
....................     signed long         JoystickX;      // Entero de -32768 a 32767 (0 eje x, 1 eje y)
....................     int                 Triggers[2];    // Entero de 0 a 255 (0 izquierdo, 1 derecho)
.................... };
.................... 
.................... // ---------------------------- Funciones --------------------------- //
.................... void motors_init(struct motor_t tires[2][2])
.................... {
....................     // Configuracion de Timers
....................     T2CON       = 0b00000100;
*
003D4:  MOVLW  04
003D6:  MOVWF  FBA
....................     PR2         = 79;
003D8:  MOVLW  4F
003DA:  MOVWF  FBB
....................     
....................     // Configuracion de CCPXCON para PWM
....................     CCPTMRS0 = CCPTMRS0 = 0b00000000;       // Configuramos CCPX con timer 2
003DC:  MOVLB  F
003DE:  CLRF   x49
....................     
....................     // Configiracion de modulo CCPX para PWM
....................     CCP4CON = 0b00001100, CCP3CON = 0b00001100, CCP2CON = 0b00001100, CCP1CON = 0b00001100;
003E0:  MOVLW  0C
003E2:  MOVWF  x57
003E4:  MOVWF  x5D
003E6:  MOVWF  F66
003E8:  MOVWF  FBD
.................... 
....................     for(int i = 0; i < 2 ; i++)
003EA:  CLRF   3F
003EC:  MOVF   3F,W
003EE:  SUBLW  01
003F0:  BNC   044E
....................         for(int j = 0; j < 2; j++)
003F2:  CLRF   40
003F4:  MOVF   40,W
003F6:  SUBLW  01
003F8:  BNC   044A
....................             *(tires[i][j].DutyCicle) = 0;
003FA:  CLRF   44
003FC:  MOVFF  3F,43
00400:  CLRF   46
00402:  MOVLW  0C
00404:  MOVWF  45
00406:  MOVLB  0
00408:  RCALL  03B6
0040A:  MOVFF  02,42
0040E:  MOVFF  01,41
00412:  CLRF   44
00414:  MOVFF  40,43
00418:  CLRF   46
0041A:  MOVLW  06
0041C:  MOVWF  45
0041E:  RCALL  03B6
00420:  MOVF   01,W
00422:  ADDWF  41,F
00424:  MOVF   02,W
00426:  ADDWFC 42,F
00428:  MOVF   3D,W
0042A:  ADDWF  41,W
0042C:  MOVWF  FE9
0042E:  MOVF   3E,W
00430:  ADDWFC 42,W
00432:  MOVWF  FEA
00434:  MOVFF  FEC,03
00438:  MOVF   FED,F
0043A:  MOVFF  FEF,FE9
0043E:  MOVFF  03,FEA
00442:  CLRF   FEF
00444:  INCF   40,F
00446:  MOVLB  F
00448:  BRA    03F4
0044A:  INCF   3F,F
0044C:  BRA    03EC
0044E:  MOVLB  0
00450:  GOTO   10F6 (RETURN)
.................... }
.................... 
.................... void motor_movement(struct motor_t *motor, float speed)   // Modo de movimiento normal
*
00ADE:  CLRF   59
00AE0:  CLRF   58
00AE2:  CLRF   57
00AE4:  CLRF   56
00AE6:  MOVFF  52,5D
00AEA:  MOVFF  51,5C
00AEE:  MOVFF  50,5B
00AF2:  MOVFF  4F,5A
00AF6:  BRA    0A2C
00AF8:  BC    0AFC
00AFA:  BNZ   0B00
00AFC:  MOVLW  01
00AFE:  BRA    0B02
00B00:  MOVLW  00
00B02:  BCF    53.0
00B04:  BTFSC  FE8.0
00B06:  BSF    53.0
.................... {
....................     short direction = (speed >= 0) ? FORWARD : BACK;
....................     
....................     // Establecemos direccion de giro
....................     output_bit(motor->IN1_pin, direction);
00B08:  MOVLW  02
00B0A:  ADDWF  4D,W
00B0C:  MOVWF  FE9
00B0E:  MOVLW  00
00B10:  ADDWFC 4E,W
00B12:  MOVWF  FEA
00B14:  MOVFF  FEC,57
00B18:  MOVF   FED,F
00B1A:  MOVFF  FEF,56
00B1E:  MOVLW  00
00B20:  BTFSC  53.0
00B22:  MOVLW  01
00B24:  MOVFF  56,58
00B28:  MOVWF  59
00B2A:  MOVLW  0F
00B2C:  MOVWF  5B
00B2E:  MOVLW  89
00B30:  MOVWF  5A
00B32:  RCALL  047E
00B34:  MOVFF  56,58
00B38:  CLRF   59
00B3A:  MOVLW  0F
00B3C:  MOVWF  5B
00B3E:  MOVLW  92
00B40:  MOVWF  5A
00B42:  RCALL  047E
....................     output_bit(motor->IN2_pin, !direction);
00B44:  MOVLW  04
00B46:  ADDWF  4D,W
00B48:  MOVWF  FE9
00B4A:  MOVLW  00
00B4C:  ADDWFC 4E,W
00B4E:  MOVWF  FEA
00B50:  MOVFF  FEC,57
00B54:  MOVF   FED,F
00B56:  MOVFF  FEF,56
00B5A:  MOVLW  00
00B5C:  BTFSS  53.0
00B5E:  MOVLW  01
00B60:  MOVFF  56,58
00B64:  MOVWF  59
00B66:  MOVLW  0F
00B68:  MOVWF  5B
00B6A:  MOVLW  89
00B6C:  MOVWF  5A
00B6E:  RCALL  047E
00B70:  MOVFF  56,58
00B74:  CLRF   59
00B76:  MOVLW  0F
00B78:  MOVWF  5B
00B7A:  MOVLW  92
00B7C:  MOVWF  5A
00B7E:  RCALL  047E
....................     
....................     // Establecemos DC para velocidad
....................     long aux = ((max_dutycicle - min_dutycicle) * abs(speed) / 100) + min_dutycicle;
00B80:  MOVFF  4F,00
00B84:  MOVFF  50,01
00B88:  MOVFF  51,02
00B8C:  MOVFF  52,03
00B90:  BCF    01.7
00B92:  CLRF   59
00B94:  MOVLW  80
00B96:  MOVWF  58
00B98:  MOVLW  15
00B9A:  MOVWF  57
00B9C:  MOVLW  87
00B9E:  MOVWF  56
00BA0:  MOVFF  52,5D
00BA4:  MOVFF  51,5C
00BA8:  MOVFF  01,5B
00BAC:  MOVFF  4F,5A
00BB0:  RCALL  0576
00BB2:  MOVFF  03,59
00BB6:  MOVFF  02,58
00BBA:  MOVFF  01,57
00BBE:  MOVFF  00,56
00BC2:  MOVFF  03,5D
00BC6:  MOVFF  02,5C
00BCA:  MOVFF  01,5B
00BCE:  MOVFF  00,5A
00BD2:  CLRF   x61
00BD4:  CLRF   x60
00BD6:  MOVLW  48
00BD8:  MOVWF  5F
00BDA:  MOVLW  85
00BDC:  MOVWF  5E
00BDE:  RCALL  0668
00BE0:  MOVFF  03,59
00BE4:  MOVFF  02,58
00BE8:  MOVFF  01,57
00BEC:  MOVFF  00,56
00BF0:  BCF    FD8.1
00BF2:  MOVFF  03,5D
00BF6:  MOVFF  02,5C
00BFA:  MOVFF  01,5B
00BFE:  MOVFF  00,5A
00C02:  CLRF   x61
00C04:  CLRF   x60
00C06:  MOVLW  28
00C08:  MOVWF  5F
00C0A:  MOVLW  83
00C0C:  MOVWF  5E
00C0E:  RCALL  07C2
00C10:  MOVFF  03,59
00C14:  MOVFF  02,58
00C18:  MOVFF  01,57
00C1C:  MOVFF  00,56
00C20:  BRA    0AA4
00C22:  MOVFF  02,55
00C26:  MOVFF  01,54
....................     *(motor->DutyCicle) = aux >> 2;
00C2A:  MOVFF  4D,FE9
00C2E:  MOVFF  4E,FEA
00C32:  MOVFF  FEC,03
00C36:  MOVF   FED,F
00C38:  MOVFF  FEF,FE9
00C3C:  MOVFF  03,FEA
00C40:  RRCF   55,W
00C42:  MOVWF  03
00C44:  RRCF   54,W
00C46:  MOVWF  02
00C48:  RRCF   03,F
00C4A:  RRCF   02,F
00C4C:  MOVLW  3F
00C4E:  ANDWF  03,F
00C50:  MOVFF  02,FEF
00C54:  RETURN 0
.................... }
.................... 
.................... void motor_movement(struct motor_t *motor)    // Modo de freno de corto (Solo para emergencias)
.................... {
....................     output_high(motor->IN1_pin);
*
004BC:  MOVLW  02
004BE:  ADDWF  4D,W
004C0:  MOVWF  FE9
004C2:  MOVLW  00
004C4:  ADDWFC 4E,W
004C6:  MOVWF  FEA
004C8:  MOVFF  FEC,50
004CC:  MOVF   FED,F
004CE:  MOVFF  FEF,4F
004D2:  MOVFF  4F,58
004D6:  MOVLW  01
004D8:  MOVWF  59
004DA:  MOVLW  0F
004DC:  MOVWF  5B
004DE:  MOVLW  89
004E0:  MOVWF  5A
004E2:  RCALL  047E
004E4:  MOVFF  4F,58
004E8:  CLRF   59
004EA:  MOVLW  0F
004EC:  MOVWF  5B
004EE:  MOVLW  92
004F0:  MOVWF  5A
004F2:  RCALL  047E
....................     output_high(motor->IN2_pin);
004F4:  MOVLW  04
004F6:  ADDWF  4D,W
004F8:  MOVWF  FE9
004FA:  MOVLW  00
004FC:  ADDWFC 4E,W
004FE:  MOVWF  FEA
00500:  MOVFF  FEC,50
00504:  MOVF   FED,F
00506:  MOVFF  FEF,4F
0050A:  MOVFF  4F,58
0050E:  MOVLW  01
00510:  MOVWF  59
00512:  MOVLW  0F
00514:  MOVWF  5B
00516:  MOVLW  89
00518:  MOVWF  5A
0051A:  RCALL  047E
0051C:  MOVFF  4F,58
00520:  CLRF   59
00522:  MOVLW  0F
00524:  MOVWF  5B
00526:  MOVLW  92
00528:  MOVWF  5A
0052A:  RCALL  047E
0052C:  RETURN 0
.................... }
.................... 
.................... void drive_tires(struct controller_t *xbox_controller, struct motor_t tires[2][2])
.................... {    
....................     // Si estan presionados los 2 al maximo, aplicamos freno de corto y salimos de funcion
....................     if((xbox_controller->Triggers[0] == 255) && (xbox_controller->Triggers[1] == 255))
*
00C56:  MOVLW  02
00C58:  ADDWF  3D,W
00C5A:  MOVWF  FE9
00C5C:  MOVLW  00
00C5E:  ADDWFC 3E,W
00C60:  MOVWF  FEA
00C62:  INCFSZ FEF,W
00C64:  BRA    0CDA
00C66:  MOVLW  03
00C68:  ADDWF  3D,W
00C6A:  MOVWF  FE9
00C6C:  MOVLW  00
00C6E:  ADDWFC 3E,W
00C70:  MOVWF  FEA
00C72:  INCFSZ FEF,W
00C74:  BRA    0CDA
....................     {
....................         // Activamos modo short brake
....................         motor_movement(&tires[0][0]), motor_movement(&tires[0][1]);
00C76:  MOVFF  3F,01
00C7A:  MOVFF  40,03
00C7E:  MOVFF  40,4E
00C82:  MOVFF  3F,4D
00C86:  RCALL  04BC
00C88:  MOVLW  06
00C8A:  ADDWF  3F,W
00C8C:  MOVWF  01
00C8E:  MOVLW  00
00C90:  ADDWFC 40,W
00C92:  MOVWF  03
00C94:  MOVFF  01,4B
00C98:  MOVWF  4C
00C9A:  MOVWF  4E
00C9C:  MOVFF  01,4D
00CA0:  RCALL  04BC
....................         motor_movement(&tires[1][0]), motor_movement(&tires[1][1]);
00CA2:  MOVLW  0C
00CA4:  ADDWF  3F,W
00CA6:  MOVWF  01
00CA8:  MOVLW  00
00CAA:  ADDWFC 40,W
00CAC:  MOVWF  03
00CAE:  MOVFF  01,4B
00CB2:  MOVWF  4C
00CB4:  MOVWF  4E
00CB6:  MOVFF  01,4D
00CBA:  RCALL  04BC
00CBC:  MOVLW  12
00CBE:  ADDWF  3F,W
00CC0:  MOVWF  01
00CC2:  MOVLW  00
00CC4:  ADDWFC 40,W
00CC6:  MOVWF  03
00CC8:  MOVFF  01,4B
00CCC:  MOVWF  4C
00CCE:  MOVWF  4E
00CD0:  MOVFF  01,4D
00CD4:  CALL   04BC
....................         return;
00CD8:  BRA    104E
....................     }
.................... 
....................     /*  Notas para comprender
....................     * Llanta contraria al giro, avanza con normalidad a la velocidad indicada (speed)
....................     * Llanta de apoyo, gira a menor velocidad en funcion de que tan desviado hacia la direccion esta el joystick 
....................         ∵ (-speed < turning_speed < speed)
....................     */
.................... 
....................     // Si no se aplico freno de corto, calculamos velocidad y direccion de movimiento
....................     
....................     float speed[2];
....................     signed long trigger_diff = (signed long) xbox_controller->Triggers[1] - xbox_controller->Triggers[0];
00CDA:  MOVLW  03
00CDC:  ADDWF  3D,W
00CDE:  MOVWF  FE9
00CE0:  MOVLW  00
00CE2:  ADDWFC 3E,W
00CE4:  MOVWF  FEA
00CE6:  MOVF   FEF,W
00CE8:  CLRF   4C
00CEA:  MOVWF  4B
00CEC:  MOVLW  02
00CEE:  ADDWF  3D,W
00CF0:  MOVWF  FE9
00CF2:  MOVLW  00
00CF4:  ADDWFC 3E,W
00CF6:  MOVWF  FEA
00CF8:  MOVF   FEF,W
00CFA:  SUBWF  4B,W
00CFC:  MOVWF  49
00CFE:  MOVLW  00
00D00:  SUBWFB 4C,W
00D02:  MOVWF  4A
.................... 
....................     if(xbox_controller->JoystickX >= 0)        // El movimiento es a la derecha o al centro
00D04:  MOVFF  3D,FE9
00D08:  MOVFF  3E,FEA
00D0C:  MOVFF  FEC,4C
00D10:  MOVF   FED,F
00D12:  MOVFF  FEF,4B
00D16:  BTFSC  4C.7
00D18:  BRA    0E62
....................     {
....................         speed[0] = trigger_diff * 100.0 / max_trigger_value;
00D1A:  MOVFF  4A,50
00D1E:  MOVFF  49,4F
00D22:  RCALL  052E
00D24:  MOVFF  03,59
00D28:  MOVFF  02,58
00D2C:  MOVFF  01,57
00D30:  MOVFF  00,56
00D34:  CLRF   5D
00D36:  CLRF   5C
00D38:  MOVLW  48
00D3A:  MOVWF  5B
00D3C:  MOVLW  85
00D3E:  MOVWF  5A
00D40:  RCALL  0576
00D42:  MOVFF  03,4E
00D46:  MOVFF  02,4D
00D4A:  MOVFF  01,4C
00D4E:  MOVFF  00,4B
00D52:  MOVFF  03,5D
00D56:  MOVFF  02,5C
00D5A:  MOVFF  01,5B
00D5E:  MOVFF  00,5A
00D62:  CLRF   x61
00D64:  CLRF   x60
00D66:  MOVLW  7F
00D68:  MOVWF  5F
00D6A:  MOVLW  86
00D6C:  MOVWF  5E
00D6E:  RCALL  0668
00D70:  MOVFF  03,44
00D74:  MOVFF  02,43
00D78:  MOVFF  01,42
00D7C:  MOVFF  00,41
....................         // Flotante de -100 a 100 que indica la velocidad y direccion de movimiento (+ adelante, - atras)
....................         speed[1] = speed[0] - (2 * speed[0] * xbox_controller->JoystickX / max_joystick_value);
00D80:  CLRF   59
00D82:  CLRF   58
00D84:  CLRF   57
00D86:  MOVLW  80
00D88:  MOVWF  56
00D8A:  MOVFF  44,5D
00D8E:  MOVFF  43,5C
00D92:  MOVFF  42,5B
00D96:  MOVFF  41,5A
00D9A:  CALL   0576
00D9E:  MOVFF  03,4E
00DA2:  MOVFF  02,4D
00DA6:  MOVFF  01,4C
00DAA:  MOVFF  00,4B
00DAE:  MOVFF  3D,FE9
00DB2:  MOVFF  3E,FEA
00DB6:  MOVFF  FEC,03
00DBA:  MOVF   FED,F
00DBC:  MOVFF  FEF,4F
00DC0:  MOVFF  03,50
00DC4:  CALL   052E
00DC8:  MOVFF  4E,59
00DCC:  MOVFF  4D,58
00DD0:  MOVFF  4C,57
00DD4:  MOVFF  4B,56
00DD8:  MOVFF  03,5D
00DDC:  MOVFF  02,5C
00DE0:  MOVFF  01,5B
00DE4:  MOVFF  00,5A
00DE8:  CALL   0576
00DEC:  MOVFF  03,4E
00DF0:  MOVFF  02,4D
00DF4:  MOVFF  01,4C
00DF8:  MOVFF  00,4B
00DFC:  MOVFF  03,5D
00E00:  MOVFF  02,5C
00E04:  MOVFF  01,5B
00E08:  MOVFF  00,5A
00E0C:  CLRF   x61
00E0E:  MOVLW  FE
00E10:  MOVWF  x60
00E12:  MOVLW  7F
00E14:  MOVWF  5F
00E16:  MOVLW  8D
00E18:  MOVWF  5E
00E1A:  RCALL  0668
00E1C:  MOVFF  FEA,4C
00E20:  MOVFF  FE9,4B
00E24:  BSF    FD8.1
00E26:  MOVFF  44,5D
00E2A:  MOVFF  43,5C
00E2E:  MOVFF  42,5B
00E32:  MOVFF  41,5A
00E36:  MOVFF  03,61
00E3A:  MOVFF  02,60
00E3E:  MOVFF  01,5F
00E42:  MOVFF  00,5E
00E46:  RCALL  07C2
00E48:  MOVFF  4C,FEA
00E4C:  MOVFF  4B,FE9
00E50:  MOVFF  03,48
00E54:  MOVFF  02,47
00E58:  MOVFF  01,46
00E5C:  MOVFF  00,45
....................         // Velocidad - (2 veces Velocidad * (Valor Joystick X / Valor maximo Joystick X))
....................     }
00E60:  BRA    0FAE
....................     else                                        // El movimiento es a la izquierda
....................     {
....................         speed[1] = trigger_diff * 100.0 / max_trigger_value;
00E62:  MOVFF  4A,50
00E66:  MOVFF  49,4F
00E6A:  CALL   052E
00E6E:  MOVFF  03,59
00E72:  MOVFF  02,58
00E76:  MOVFF  01,57
00E7A:  MOVFF  00,56
00E7E:  CLRF   5D
00E80:  CLRF   5C
00E82:  MOVLW  48
00E84:  MOVWF  5B
00E86:  MOVLW  85
00E88:  MOVWF  5A
00E8A:  CALL   0576
00E8E:  MOVFF  03,4E
00E92:  MOVFF  02,4D
00E96:  MOVFF  01,4C
00E9A:  MOVFF  00,4B
00E9E:  MOVFF  03,5D
00EA2:  MOVFF  02,5C
00EA6:  MOVFF  01,5B
00EAA:  MOVFF  00,5A
00EAE:  CLRF   x61
00EB0:  CLRF   x60
00EB2:  MOVLW  7F
00EB4:  MOVWF  5F
00EB6:  MOVLW  86
00EB8:  MOVWF  5E
00EBA:  CALL   0668
00EBE:  MOVFF  03,48
00EC2:  MOVFF  02,47
00EC6:  MOVFF  01,46
00ECA:  MOVFF  00,45
....................         // Flotante de -100 a 100 que indica la velocidad y direccion de movimiento (+ adelante, - atras)
....................         speed[0] = speed[1] - (2 * speed[1] * xbox_controller->JoystickX / -32768.0);
00ECE:  CLRF   59
00ED0:  CLRF   58
00ED2:  CLRF   57
00ED4:  MOVLW  80
00ED6:  MOVWF  56
00ED8:  MOVFF  48,5D
00EDC:  MOVFF  47,5C
00EE0:  MOVFF  46,5B
00EE4:  MOVFF  45,5A
00EE8:  CALL   0576
00EEC:  MOVFF  03,4E
00EF0:  MOVFF  02,4D
00EF4:  MOVFF  01,4C
00EF8:  MOVFF  00,4B
00EFC:  MOVFF  3D,FE9
00F00:  MOVFF  3E,FEA
00F04:  MOVFF  FEC,03
00F08:  MOVF   FED,F
00F0A:  MOVFF  FEF,4F
00F0E:  MOVFF  03,50
00F12:  CALL   052E
00F16:  MOVFF  4E,59
00F1A:  MOVFF  4D,58
00F1E:  MOVFF  4C,57
00F22:  MOVFF  4B,56
00F26:  MOVFF  03,5D
00F2A:  MOVFF  02,5C
00F2E:  MOVFF  01,5B
00F32:  MOVFF  00,5A
00F36:  CALL   0576
00F3A:  MOVFF  03,4E
00F3E:  MOVFF  02,4D
00F42:  MOVFF  01,4C
00F46:  MOVFF  00,4B
00F4A:  MOVFF  03,5D
00F4E:  MOVFF  02,5C
00F52:  MOVFF  01,5B
00F56:  MOVFF  00,5A
00F5A:  CLRF   x61
00F5C:  CLRF   x60
00F5E:  MOVLW  80
00F60:  MOVWF  5F
00F62:  MOVLW  8E
00F64:  MOVWF  5E
00F66:  CALL   0668
00F6A:  MOVFF  FEA,4C
00F6E:  MOVFF  FE9,4B
00F72:  BSF    FD8.1
00F74:  MOVFF  48,5D
00F78:  MOVFF  47,5C
00F7C:  MOVFF  46,5B
00F80:  MOVFF  45,5A
00F84:  MOVFF  03,61
00F88:  MOVFF  02,60
00F8C:  MOVFF  01,5F
00F90:  MOVFF  00,5E
00F94:  RCALL  07C2
00F96:  MOVFF  4C,FEA
00F9A:  MOVFF  4B,FE9
00F9E:  MOVFF  03,44
00FA2:  MOVFF  02,43
00FA6:  MOVFF  01,42
00FAA:  MOVFF  00,41
....................         // Velocidad - (2 veces Velocidad * (Valor Joystick X / Valor maximo Joystick X))
....................     }
.................... 
....................     // Enviamos movimiento a las llantas //
....................     motor_movement(&tires[0][0], speed[0]);      // Llanta delantera izquierda
00FAE:  MOVFF  3F,01
00FB2:  MOVFF  40,03
00FB6:  MOVFF  40,4E
00FBA:  MOVFF  3F,4D
00FBE:  MOVFF  44,52
00FC2:  MOVFF  43,51
00FC6:  MOVFF  42,50
00FCA:  MOVFF  41,4F
00FCE:  RCALL  0ADE
....................     motor_movement(&tires[1][0], speed[0]);      // Llanta trasera izquierda
00FD0:  MOVLW  0C
00FD2:  ADDWF  3F,W
00FD4:  MOVWF  01
00FD6:  MOVLW  00
00FD8:  ADDWFC 40,W
00FDA:  MOVWF  03
00FDC:  MOVFF  01,4B
00FE0:  MOVWF  4C
00FE2:  MOVWF  4E
00FE4:  MOVFF  01,4D
00FE8:  MOVFF  44,52
00FEC:  MOVFF  43,51
00FF0:  MOVFF  42,50
00FF4:  MOVFF  41,4F
00FF8:  RCALL  0ADE
....................     
....................     motor_movement(&tires[0][1], speed[1]);      // Llanta delantera derecha
00FFA:  MOVLW  06
00FFC:  ADDWF  3F,W
00FFE:  MOVWF  01
01000:  MOVLW  00
01002:  ADDWFC 40,W
01004:  MOVWF  03
01006:  MOVFF  01,4B
0100A:  MOVWF  4C
0100C:  MOVWF  4E
0100E:  MOVFF  01,4D
01012:  MOVFF  48,52
01016:  MOVFF  47,51
0101A:  MOVFF  46,50
0101E:  MOVFF  45,4F
01022:  RCALL  0ADE
....................     motor_movement(&tires[1][1], speed[1]);      // Llanta trasera derecha
01024:  MOVLW  12
01026:  ADDWF  3F,W
01028:  MOVWF  01
0102A:  MOVLW  00
0102C:  ADDWFC 40,W
0102E:  MOVWF  03
01030:  MOVFF  01,4B
01034:  MOVWF  4C
01036:  MOVWF  4E
01038:  MOVFF  01,4D
0103C:  MOVFF  48,52
01040:  MOVFF  47,51
01044:  MOVFF  46,50
01048:  MOVFF  45,4F
0104C:  RCALL  0ADE
0104E:  GOTO   116A (RETURN)
.................... }
.................... 
.................... /*
.................... Los gatillos establecen la velocidad maxima de giro, y la posicion del joystick establece como se repartira esta velocidad en las llantas, para poder hacer diferentes maniobras, por ejemlo:
.................... 
.................... * Cuanto mas pegado al maximo o minimo del eje Y, mayor sera la diferencia de velocidad entre las llantas de la izquierda con las de la derecha
.................... * Cuanto mas pegado al maximo o minimo del eje X, mayor sera la diferencia de velocidad entre las llantas de arriba y abajo
.................... 
.................... Por lo tanto: 
.................... * La llanta mas lejana a la direccion de movimiento en X tendra mas velocidad que la mas pegada
.................... * La llanta mas lejana a la direccion de movimiento en Y tendra mas velocidad que la mas pegada
.................... */ 
.................... 
.................... 
.................... // --------------------- Direccion de registros --------------------- //
.................... #BYTE       TRISA               = 0xF92
.................... #BYTE       TRISB               = 0xF93
.................... #BYTE       TRISC               = 0xF94
.................... #BIT        status_LED          = 0xF89.0   // LATA
.................... 
.................... #BYTE       INTCON              = 0xFF2
.................... #BIT        INT1IE              = 0xFF0.3   // INTCON3
.................... #BIT        INTEDG1             = 0xFF1.5   // INTCON2
.................... #BIT        RC1IE               = 0xF9D.5   // PIE1
.................... #BIT        IPEN                = 0xFD0.7   // RCON
.................... #BIT        RC1IP               = 0xF9F.5   // IPR1
.................... 
.................... #BYTE       T0CON               = 0xFD5
.................... #BIT        TMR0ON              = 0xFD5.7   // T0CON
.................... const int16 *TMR0               = 0xFD6;
.................... #BIT        TMR0IP              = 0xFF1.2   // INTCON2
.................... 
.................... // ----------------------- Variable Globales ------------------------ //
.................... struct motor_t  tires[2][2]   = 
.................... {
....................     {   // Llantas delanteras
....................         { 0xFBE, PIN_B3, PIN_B4 },  // Izquierda
....................         { 0xF67, PIN_B6, PIN_B7 }   // Derecha
....................     },
....................     {   // Llantas traseras
....................         { 0xF5E, PIN_A4, PIN_A5 },  // Izquierda
....................         { 0xF58, PIN_A6, PIN_A7 }   // Derecha
....................     }
.................... };
.................... 
.................... struct          controller_t xbox_controller;
.................... struct          bth_conection_t PC = { FALSE, FALSE };
.................... 
.................... // -------------------------- Interrupciones ------------------------ //
.................... #INT_RDA
.................... void control_instructions()
*
002DE:  BTFSS  F9E.5
002E0:  BRA    02DE
002E2:  MOVFF  FAE,6A
.................... {
....................     int data = getch();
....................     
....................     if(data == '*')     // Recibimos caracter de inicio de datos
002E6:  MOVF   x6A,W
002E8:  SUBLW  2A
002EA:  BNZ   0370
....................     {           
....................         char XJoystick[8], LeftTrigger[5], RightTrigger[5];
....................         
....................         // Obtenemos cadenas de caracteres con los valores a recibir
....................         gets(XJoystick);
002EC:  CLRF   FEA
002EE:  MOVLW  6B
002F0:  MOVWF  FE9
002F2:  CLRF   FED
002F4:  BTFSS  F9E.5
002F6:  BRA    02F4
002F8:  MOVFF  FAE,FEC
002FC:  MOVLW  0D
002FE:  SUBWF  FEF,W
00300:  BNZ   02F4
00302:  CLRF   FEC
....................         gets(LeftTrigger);
00304:  CLRF   FEA
00306:  MOVLW  73
00308:  MOVWF  FE9
0030A:  CLRF   FED
0030C:  BTFSS  F9E.5
0030E:  BRA    030C
00310:  MOVFF  FAE,FEC
00314:  MOVLW  0D
00316:  SUBWF  FEF,W
00318:  BNZ   030C
0031A:  CLRF   FEC
....................         gets(RightTrigger);
0031C:  CLRF   FEA
0031E:  MOVLW  78
00320:  MOVWF  FE9
00322:  CLRF   FED
00324:  BTFSS  F9E.5
00326:  BRA    0324
00328:  MOVFF  FAE,FEC
0032C:  MOVLW  0D
0032E:  SUBWF  FEF,W
00330:  BNZ   0324
00332:  CLRF   FEC
.................... 
....................         // Realizamos la conversion y actualizamos los valores del control
....................         xbox_controller.JoystickX   =  atol(XJoystick);        
00334:  CLRF   x7E
00336:  MOVLW  6B
00338:  MOVWF  x7D
0033A:  RCALL  010C
0033C:  MOVFF  02,38
00340:  MOVFF  01,37
....................         xbox_controller.Triggers[0] =  atol(LeftTrigger);
00344:  CLRF   x7E
00346:  MOVLW  73
00348:  MOVWF  x7D
0034A:  RCALL  010C
0034C:  MOVFF  01,39
....................         xbox_controller.Triggers[1] =  atol(RightTrigger);
00350:  CLRF   x7E
00352:  MOVLW  78
00354:  MOVWF  x7D
00356:  RCALL  010C
00358:  MOVFF  01,3A
.................... 
....................         if(!PC.IsConnected)     // Si no habia conexion
0035C:  BTFSC  3B.1
0035E:  BRA    036A
....................             *TMR0 = 40535, TMR0ON = TRUE;
00360:  MOVLW  9E
00362:  MOVWF  FD7
00364:  MOVLW  57
00366:  MOVWF  FD6
00368:  BSF    FD5.7
.................... 
....................         // Actualizamos variables de conexion
....................         PC.updated_data = PC.IsConnected = PC.Check = TRUE;
0036A:  BSF    3B.2
0036C:  BSF    3B.1
0036E:  BSF    3B.0
....................     }
.................... }
.................... 
00370:  BCF    F9E.5
00372:  GOTO   006C
.................... #INT_TIMER0
.................... void connection_check()
.................... {
....................     if(PC.Check)        // Hubo confirmacion de conexion
00376:  BTFSS  3B.2
00378:  BRA    0386
....................     {
....................         PC.Check = FALSE;       // Solicitamos nueva confirmacion
0037A:  BCF    3B.2
....................         *TMR0 = 40535;
0037C:  MOVLW  9E
0037E:  MOVWF  FD7
00380:  MOVLW  57
00382:  MOVWF  FD6
....................     }
00384:  BRA    038A
....................     else                // No hubo confirmacion de conexion
....................         PC.IsConnected = TMR0ON = FALSE;    // Desactivamos timer y booleano de conexion
00386:  BCF    FD5.7
00388:  BCF    3B.1
0038A:  BCF    FF2.2
0038C:  GOTO   006C
.................... }
.................... 
.................... /* Inforamcion de variables
.................... * updated_data: Booleano para señalar que hubo una actualizacion de informacion y no ha sido aplicada.
....................     * updated_data = FALSE   : No hay nueva informacion
....................     * updated_data = TRUE    : Hay informacion pendiente de aplicar
.................... * isConnected: Booleno para saber el estatus de la conexion de bluetooth
.................... */
.................... 
.................... // ---------------------------- Funciones --------------------------- //
.................... void log_init()
.................... {
....................     // Configuracion de pines GPIO
....................     TRISA       = 0b00000000;
00390:  CLRF   F92
....................     TRISB       = 0b00000010;
00392:  MOVLW  02
00394:  MOVWF  F93
....................     TRISC       = 0b10000000;
00396:  MOVLW  80
00398:  MOVWF  F94
.................... 
....................     INTCON = 0b11100000;
0039A:  MOVLW  E0
0039C:  MOVWF  FF2
.................... 
....................     // Interrupcion de timer 0 para comprobar conexion
....................     T0CON = 0b00000011;     // 10 Hz
0039E:  MOVLW  03
003A0:  MOVWF  FD5
....................     *TMR0 = 40535;
003A2:  MOVLW  9E
003A4:  MOVWF  FD7
003A6:  MOVLW  57
003A8:  MOVWF  FD6
.................... 
....................     // Configuracion de Interrupciones
....................     IPEN = RC1IE = RC1IP =  TRUE;       // Establecemos la interrupcion de recepcion serial como prioridad
003AA:  BSF    F9F.5
003AC:  BSF    F9D.5
003AE:  BSF    FD0.7
....................     TMR0IP = FALSE;
003B0:  BCF    FF1.2
003B2:  GOTO   10EC (RETURN)
.................... }
.................... 
.................... // ------------------------ Codigo Principal ----------------------- //
.................... void main()
*
01052:  CLRF   FF8
01054:  BCF    FD0.7
01056:  BSF    07.7
01058:  MOVLW  70
0105A:  MOVWF  FD3
0105C:  BCF    F9B.6
0105E:  BCF    F9B.7
01060:  BSF    FB8.3
01062:  MOVLW  A0
01064:  MOVWF  FAF
01066:  MOVLW  01
01068:  MOVWF  FB0
0106A:  MOVLW  A6
0106C:  MOVWF  FAC
0106E:  MOVLW  90
01070:  MOVWF  FAB
01072:  MOVLB  F
01074:  CLRF   x38
01076:  CLRF   x39
01078:  CLRF   x3A
0107A:  CLRF   F77
0107C:  CLRF   F78
0107E:  CLRF   F79
01080:  BRA    10A8
01082:  DATA 02,00
01084:  DATA 19,00
01086:  DATA 00,18
01088:  DATA 00,1F
0108A:  DATA BE,0F
0108C:  DATA 0B,7C
0108E:  DATA 0C,7C
01090:  DATA 67,0F
01092:  DATA 0E,7C
01094:  DATA 0F,7C
01096:  DATA 5E,0F
01098:  DATA 04,7C
0109A:  DATA 05,7C
0109C:  DATA 58,0F
0109E:  DATA 06,7C
010A0:  DATA 07,7C
010A2:  DATA 01,00
010A4:  DATA 3B,00
010A6:  DATA 00,00
010A8:  MOVLW  00
010AA:  MOVWF  FF8
010AC:  MOVLW  10
010AE:  MOVWF  FF7
010B0:  MOVLW  82
010B2:  MOVWF  FF6
010B4:  TBLRD*+
010B6:  MOVF   FF5,W
010B8:  MOVWF  00
010BA:  XORLW  00
010BC:  BZ    10E4
010BE:  TBLRD*+
010C0:  MOVF   FF5,W
010C2:  MOVWF  01
010C4:  BTFSC  FE8.7
010C6:  BRA    10D2
010C8:  ANDLW  3F
010CA:  MOVWF  FEA
010CC:  TBLRD*+
010CE:  MOVFF  FF5,FE9
010D2:  BTFSC  01.6
010D4:  TBLRD*+
010D6:  BTFSS  01.6
010D8:  TBLRD*+
010DA:  MOVFF  FF5,FEE
010DE:  DCFSNZ 00,F
010E0:  BRA    10B4
010E2:  BRA    10D6
010E4:  CLRF   FF8
.................... {
....................     log_init();
010E6:  MOVLB  0
010E8:  GOTO   0390
....................     motors_init(tires);
010EC:  CLRF   3E
010EE:  MOVLW  1F
010F0:  MOVWF  3D
010F2:  GOTO   03D4
.................... 
....................     Connection_animation:    
....................     // Esperamos conexion bluetooth con una animacion del LED indicador
....................     for(int time = 0; !PC.IsConnected; time++, delay_ms(1))
010F6:  CLRF   3C
010F8:  BTFSC  3B.1
010FA:  BRA    1124
....................     {
....................         if(time == 200)
010FC:  MOVF   3C,W
010FE:  SUBLW  C8
01100:  BNZ   1112
....................         {
....................             status_LED ^= TRUE;
01102:  MOVLW  00
01104:  BTFSC  F89.0
01106:  MOVLW  01
01108:  XORLW  01
0110A:  BCF    F89.0
0110C:  BTFSC  FE8.0
0110E:  BSF    F89.0
....................             time = 0;
01110:  CLRF   3C
....................         }
01112:  MOVF   3C,W
01114:  INCF   3C,F
01116:  MOVLW  01
01118:  MOVWF  3D
0111A:  MOVLB  0
0111C:  GOTO   0454
01120:  MOVLB  0
01122:  BRA    10F8
....................     }
.................... 
....................     status_LED = TRUE;      // Ya hubo conexion
01124:  BSF    F89.0
.................... 
....................     while (TRUE)
....................     {   
....................         //*/
....................         if(!PC.IsConnected)                 // Si se pierde la conexion
01126:  BTFSC  3B.1
01128:  BRA    1156
....................         {
....................             // Aplicamos freno de corto cuando no hay conexion
....................             motor_movement(&tires[0][0]), motor_movement(&tires[0][1]);
0112A:  CLRF   4E
0112C:  MOVLW  1F
0112E:  MOVWF  4D
01130:  MOVLB  0
01132:  CALL   04BC
01136:  CLRF   4E
01138:  MOVLW  25
0113A:  MOVWF  4D
0113C:  CALL   04BC
....................             motor_movement(&tires[1][0]), motor_movement(&tires[1][1]);
01140:  CLRF   4E
01142:  MOVLW  2B
01144:  MOVWF  4D
01146:  CALL   04BC
0114A:  CLRF   4E
0114C:  MOVLW  31
0114E:  MOVWF  4D
01150:  CALL   04BC
....................             
....................             goto Connection_animation;
01154:  BRA    10F6
....................         }
.................... 
....................         // Si hay conexion
....................         if(PC.updated_data)                // Si se actualizo la posicion
01156:  BTFSS  3B.0
01158:  BRA    116C
....................         {
....................             // Enviamos instrucciones a motores
....................             drive_tires(&xbox_controller, tires);
0115A:  CLRF   3E
0115C:  MOVLW  37
0115E:  MOVWF  3D
01160:  CLRF   40
01162:  MOVLW  1F
01164:  MOVWF  3F
01166:  MOVLB  0
01168:  BRA    0C56
....................             PC.updated_data = FALSE;
0116A:  BCF    3B.0
....................         }
0116C:  BRA    1126
....................         //*/
.................... 
....................         /*/ Revision de  almacenamiento de variables
....................         printf("Joystick X = %ld | Y = %ld\r\n", xbox_controller.Joystick[0], xbox_controller.Joystick[1]);
....................         printf("Triggers 1 =  %u | 2 = %u\r\n", xbox_controller.Triggers[0],  xbox_controller.Triggers[1]);
....................         delay_ms(100);
....................         //*/
....................     }
.................... }
.................... 
0116E:  SLEEP 
.................... /*
.................... El codigo esta compuesto de las siguientes partes
.................... 
....................     * Interrupcion de recepcion de datos en puerto serial: Recibe los datos actualizados del control de XBOX desde el programa de computadora en C#
.................... 
....................     * Interrupcion de Timer 0: Se activa al detectar por primera vez la conexion, y monitorea la continuidad de la conexion
.................... 
....................     * Funcion principal: Inicializa los registros, y mueve las ruedas cuando hay nueva informacion
.................... */
.................... 
.................... // Falta hacer interrupcion cada 150 ms para revisar conexion y corregir no llegar a velocidad maxima con 2 llantas por falta de precision de joystick, ademas de eliminar la lectura de joystick en Y.

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY FCMEN IESO
   Word  2: 3C1E   PUT BROWNOUT BORV19 NOWDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2B5 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
