CCS PCH C Compiler, Version 5.112, 29001               15-abr.-24 00:22

               Filename:   C:\Users\diego\Desktop\Terreneitor\Firmware\Microcontoller-Code\main.lst

               ROM used:   4424 bytes (7%)
                           Largest free fragment is 61108
               RAM used:   91 (2%) at main() level
                           149 (4%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   103E
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF0.3
00056:  GOTO   0060
0005A:  BTFSC  FF0.0
0005C:  GOTO   0392
00060:  BTFSS  F9D.5
00062:  GOTO   006C
00066:  BTFSC  F9E.5
00068:  GOTO   02E4
0006C:  MOVFF  0E,00
00070:  MOVFF  0F,01
00074:  MOVFF  10,02
00078:  MOVFF  11,03
0007C:  MOVFF  0C,FE9
00080:  MOVFF  07,FEA
00084:  BSF    07.7
00086:  MOVFF  08,FE1
0008A:  MOVFF  09,FE2
0008E:  MOVFF  0A,FD9
00092:  MOVFF  0B,FDA
00096:  MOVFF  12,FF3
0009A:  MOVFF  13,FF4
0009E:  MOVFF  14,FFA
000A2:  MOVFF  15,FF5
000A6:  MOVFF  16,FF6
000AA:  MOVFF  17,FF7
000AE:  MOVF   04,W
000B0:  MOVFF  06,FE0
000B4:  MOVFF  05,FD8
000B8:  RETFIE 0
.................... // --------------- Preprocesadores de microcontrolador -------------- //
.................... #include    <18F26K22.h>                                                // Libreria del Microcontrolador
.................... //////////// Standard Header file for the PIC18F26K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F26K22
000BA:  DATA 00,00
000BC:  DATA 00,00
000BE:  DATA 00,00
000C0:  MOVF   x90,W
000C2:  XORWF  x92,W
000C4:  ANDLW  80
000C6:  MOVWF  x94
000C8:  BTFSS  x90.7
000CA:  BRA    00D6
000CC:  COMF   x8F,F
000CE:  COMF   x90,F
000D0:  INCF   x8F,F
000D2:  BTFSC  FD8.2
000D4:  INCF   x90,F
000D6:  BTFSS  x92.7
000D8:  BRA    00E4
000DA:  COMF   x91,F
000DC:  COMF   x92,F
000DE:  INCF   x91,F
000E0:  BTFSC  FD8.2
000E2:  INCF   x92,F
000E4:  MOVF   x8F,W
000E6:  MULWF  x91
000E8:  MOVFF  FF3,01
000EC:  MOVFF  FF4,00
000F0:  MULWF  x92
000F2:  MOVF   FF3,W
000F4:  ADDWF  00,F
000F6:  MOVF   x90,W
000F8:  MULWF  x91
000FA:  MOVF   FF3,W
000FC:  ADDWFC 00,W
000FE:  MOVWF  02
00100:  BTFSS  x94.7
00102:  BRA    010E
00104:  COMF   01,F
00106:  COMF   02,F
00108:  INCF   01,F
0010A:  BTFSC  FD8.2
0010C:  INCF   02,F
0010E:  GOTO   01E8 (RETURN)
*
003D4:  MOVF   5F,W
003D6:  MULWF  x61
003D8:  MOVFF  FF3,01
003DC:  MOVFF  FF4,00
003E0:  MULWF  x62
003E2:  MOVF   FF3,W
003E4:  ADDWF  00,F
003E6:  MOVF   x60,W
003E8:  MULWF  x61
003EA:  MOVF   FF3,W
003EC:  ADDWFC 00,W
003EE:  MOVWF  02
003F0:  RETURN 0
*
0049C:  MOVF   x76,W
0049E:  ANDLW  07
004A0:  MOVWF  00
004A2:  RRCF   x76,W
004A4:  MOVWF  01
004A6:  RRCF   01,F
004A8:  RRCF   01,F
004AA:  MOVLW  1F
004AC:  ANDWF  01,F
004AE:  MOVF   01,W
004B0:  ADDWF  x78,W
004B2:  MOVWF  FE9
004B4:  MOVLW  00
004B6:  ADDWFC x79,W
004B8:  MOVWF  FEA
004BA:  CLRF   01
004BC:  INCF   01,F
004BE:  INCF   00,F
004C0:  BRA    04C4
004C2:  RLCF   01,F
004C4:  DECFSZ 00,F
004C6:  BRA    04C2
004C8:  MOVF   x77,F
004CA:  BZ    04D2
004CC:  MOVF   01,W
004CE:  IORWF  FEF,F
004D0:  BRA    04D8
004D2:  COMF   01,F
004D4:  MOVF   01,W
004D6:  ANDWF  FEF,F
004D8:  RETURN 0
*
0054C:  MOVLW  8E
0054E:  MOVWF  00
00550:  MOVFF  6E,01
00554:  MOVFF  6D,02
00558:  CLRF   03
0055A:  BTFSS  x6E.7
0055C:  BRA    0568
0055E:  COMF   01,F
00560:  COMF   02,F
00562:  INCF   02,F
00564:  BNZ   0568
00566:  INCF   01,F
00568:  MOVF   01,F
0056A:  BNZ   057E
0056C:  MOVFF  02,01
00570:  CLRF   02
00572:  MOVLW  08
00574:  SUBWF  00,F
00576:  MOVF   01,F
00578:  BNZ   057E
0057A:  CLRF   00
0057C:  BRA    0592
0057E:  BCF    FD8.0
00580:  BTFSC  01.7
00582:  BRA    058C
00584:  RLCF   02,F
00586:  RLCF   01,F
00588:  DECF   00,F
0058A:  BRA    057E
0058C:  BTFSC  x6E.7
0058E:  BRA    0592
00590:  BCF    01.7
00592:  RETURN 0
00594:  MOVF   x74,W
00596:  BTFSC  FD8.2
00598:  BRA    067C
0059A:  MOVWF  00
0059C:  MOVF   x78,W
0059E:  BTFSC  FD8.2
005A0:  BRA    067C
005A2:  ADDWF  00,F
005A4:  BNC   05AE
005A6:  MOVLW  81
005A8:  ADDWF  00,F
005AA:  BC    067C
005AC:  BRA    05B6
005AE:  MOVLW  7F
005B0:  SUBWF  00,F
005B2:  BNC   067C
005B4:  BZ    067C
005B6:  MOVFF  75,7C
005BA:  MOVF   x79,W
005BC:  XORWF  x7C,F
005BE:  BSF    x75.7
005C0:  BSF    x79.7
005C2:  MOVF   x77,W
005C4:  MULWF  x7B
005C6:  MOVFF  FF4,7E
005CA:  MOVF   x76,W
005CC:  MULWF  x7A
005CE:  MOVFF  FF4,03
005D2:  MOVFF  FF3,7D
005D6:  MULWF  x7B
005D8:  MOVF   FF3,W
005DA:  ADDWF  x7E,F
005DC:  MOVF   FF4,W
005DE:  ADDWFC x7D,F
005E0:  MOVLW  00
005E2:  ADDWFC 03,F
005E4:  MOVF   x77,W
005E6:  MULWF  x7A
005E8:  MOVF   FF3,W
005EA:  ADDWF  x7E,F
005EC:  MOVF   FF4,W
005EE:  ADDWFC x7D,F
005F0:  MOVLW  00
005F2:  CLRF   02
005F4:  ADDWFC 03,F
005F6:  ADDWFC 02,F
005F8:  MOVF   x75,W
005FA:  MULWF  x7B
005FC:  MOVF   FF3,W
005FE:  ADDWF  x7D,F
00600:  MOVF   FF4,W
00602:  ADDWFC 03,F
00604:  MOVLW  00
00606:  ADDWFC 02,F
00608:  MOVF   x75,W
0060A:  MULWF  x7A
0060C:  MOVF   FF3,W
0060E:  ADDWF  03,F
00610:  MOVF   FF4,W
00612:  ADDWFC 02,F
00614:  MOVLW  00
00616:  CLRF   01
00618:  ADDWFC 01,F
0061A:  MOVF   x77,W
0061C:  MULWF  x79
0061E:  MOVF   FF3,W
00620:  ADDWF  x7D,F
00622:  MOVF   FF4,W
00624:  ADDWFC 03,F
00626:  MOVLW  00
00628:  ADDWFC 02,F
0062A:  ADDWFC 01,F
0062C:  MOVF   x76,W
0062E:  MULWF  x79
00630:  MOVF   FF3,W
00632:  ADDWF  03,F
00634:  MOVF   FF4,W
00636:  ADDWFC 02,F
00638:  MOVLW  00
0063A:  ADDWFC 01,F
0063C:  MOVF   x75,W
0063E:  MULWF  x79
00640:  MOVF   FF3,W
00642:  ADDWF  02,F
00644:  MOVF   FF4,W
00646:  ADDWFC 01,F
00648:  INCF   00,F
0064A:  BTFSC  01.7
0064C:  BRA    0658
0064E:  RLCF   x7D,F
00650:  RLCF   03,F
00652:  RLCF   02,F
00654:  RLCF   01,F
00656:  DECF   00,F
00658:  MOVLW  00
0065A:  BTFSS  x7D.7
0065C:  BRA    0672
0065E:  INCF   03,F
00660:  ADDWFC 02,F
00662:  ADDWFC 01,F
00664:  MOVF   01,W
00666:  BNZ   0672
00668:  MOVF   02,W
0066A:  BNZ   0672
0066C:  MOVF   03,W
0066E:  BNZ   0672
00670:  INCF   00,F
00672:  BTFSC  x7C.7
00674:  BSF    01.7
00676:  BTFSS  x7C.7
00678:  BCF    01.7
0067A:  BRA    0684
0067C:  CLRF   00
0067E:  CLRF   01
00680:  CLRF   02
00682:  CLRF   03
00684:  RETURN 0
00686:  MOVF   x78,W
00688:  BTFSC  FD8.2
0068A:  BRA    07D6
0068C:  MOVWF  x84
0068E:  MOVF   x7C,W
00690:  BTFSC  FD8.2
00692:  BRA    07D6
00694:  SUBWF  x84,F
00696:  BNC   06A2
00698:  MOVLW  7F
0069A:  ADDWF  x84,F
0069C:  BTFSC  FD8.0
0069E:  BRA    07D6
006A0:  BRA    06AE
006A2:  MOVLW  81
006A4:  SUBWF  x84,F
006A6:  BTFSS  FD8.0
006A8:  BRA    07D6
006AA:  BTFSC  FD8.2
006AC:  BRA    07D6
006AE:  MOVFF  84,00
006B2:  CLRF   01
006B4:  CLRF   02
006B6:  CLRF   03
006B8:  CLRF   x83
006BA:  MOVFF  79,82
006BE:  BSF    x82.7
006C0:  MOVFF  7A,81
006C4:  MOVFF  7B,80
006C8:  MOVLW  19
006CA:  MOVWF  x84
006CC:  MOVF   x7F,W
006CE:  SUBWF  x80,F
006D0:  BC    06EC
006D2:  MOVLW  01
006D4:  SUBWF  x81,F
006D6:  BC    06EC
006D8:  SUBWF  x82,F
006DA:  BC    06EC
006DC:  SUBWF  x83,F
006DE:  BC    06EC
006E0:  INCF   x83,F
006E2:  INCF   x82,F
006E4:  INCF   x81,F
006E6:  MOVF   x7F,W
006E8:  ADDWF  x80,F
006EA:  BRA    073C
006EC:  MOVF   x7E,W
006EE:  SUBWF  x81,F
006F0:  BC    0716
006F2:  MOVLW  01
006F4:  SUBWF  x82,F
006F6:  BC    0716
006F8:  SUBWF  x83,F
006FA:  BC    0716
006FC:  INCF   x83,F
006FE:  INCF   x82,F
00700:  MOVF   x7E,W
00702:  ADDWF  x81,F
00704:  MOVF   x7F,W
00706:  ADDWF  x80,F
00708:  BNC   073C
0070A:  INCF   x81,F
0070C:  BNZ   073C
0070E:  INCF   x82,F
00710:  BNZ   073C
00712:  INCF   x83,F
00714:  BRA    073C
00716:  MOVF   x7D,W
00718:  IORLW  80
0071A:  SUBWF  x82,F
0071C:  BC    073A
0071E:  MOVLW  01
00720:  SUBWF  x83,F
00722:  BC    073A
00724:  INCF   x83,F
00726:  MOVF   x7D,W
00728:  IORLW  80
0072A:  ADDWF  x82,F
0072C:  MOVF   x7E,W
0072E:  ADDWF  x81,F
00730:  BNC   0704
00732:  INCF   x82,F
00734:  BNZ   0704
00736:  INCF   x83,F
00738:  BRA    0704
0073A:  BSF    03.0
0073C:  DECFSZ x84,F
0073E:  BRA    0742
00740:  BRA    0758
00742:  BCF    FD8.0
00744:  RLCF   x80,F
00746:  RLCF   x81,F
00748:  RLCF   x82,F
0074A:  RLCF   x83,F
0074C:  BCF    FD8.0
0074E:  RLCF   03,F
00750:  RLCF   02,F
00752:  RLCF   01,F
00754:  RLCF   x85,F
00756:  BRA    06CC
00758:  BTFSS  x85.0
0075A:  BRA    0768
0075C:  BCF    FD8.0
0075E:  RRCF   01,F
00760:  RRCF   02,F
00762:  RRCF   03,F
00764:  RRCF   x85,F
00766:  BRA    076C
00768:  DECF   00,F
0076A:  BZ    07D6
0076C:  BTFSC  x85.7
0076E:  BRA    07AC
00770:  BCF    FD8.0
00772:  RLCF   x80,F
00774:  RLCF   x81,F
00776:  RLCF   x82,F
00778:  RLCF   x83,F
0077A:  MOVF   x7F,W
0077C:  SUBWF  x80,F
0077E:  BC    078E
00780:  MOVLW  01
00782:  SUBWF  x81,F
00784:  BC    078E
00786:  SUBWF  x82,F
00788:  BC    078E
0078A:  SUBWF  x83,F
0078C:  BNC   07C2
0078E:  MOVF   x7E,W
00790:  SUBWF  x81,F
00792:  BC    079E
00794:  MOVLW  01
00796:  SUBWF  x82,F
00798:  BC    079E
0079A:  SUBWF  x83,F
0079C:  BNC   07C2
0079E:  MOVF   x7D,W
007A0:  IORLW  80
007A2:  SUBWF  x82,F
007A4:  BC    07AC
007A6:  MOVLW  01
007A8:  SUBWF  x83,F
007AA:  BNC   07C2
007AC:  INCF   03,F
007AE:  BNZ   07C2
007B0:  INCF   02,F
007B2:  BNZ   07C2
007B4:  INCF   01,F
007B6:  BNZ   07C2
007B8:  INCF   00,F
007BA:  BZ    07D6
007BC:  RRCF   01,F
007BE:  RRCF   02,F
007C0:  RRCF   03,F
007C2:  MOVFF  79,84
007C6:  MOVF   x7D,W
007C8:  XORWF  x84,F
007CA:  BTFSS  x84.7
007CC:  BRA    07D2
007CE:  BSF    01.7
007D0:  BRA    07DE
007D2:  BCF    01.7
007D4:  BRA    07DE
007D6:  CLRF   00
007D8:  CLRF   01
007DA:  CLRF   02
007DC:  CLRF   03
007DE:  RETURN 0
007E0:  MOVLW  80
007E2:  BTFSC  FD8.1
007E4:  XORWF  x70,F
007E6:  CLRF   x75
007E8:  CLRF   x76
007EA:  MOVFF  6C,74
007EE:  MOVF   x70,W
007F0:  XORWF  x74,F
007F2:  MOVF   x6B,W
007F4:  BTFSC  FD8.2
007F6:  BRA    09B0
007F8:  MOVWF  x73
007FA:  MOVWF  00
007FC:  MOVF   x6F,W
007FE:  BTFSC  FD8.2
00800:  BRA    09C2
00802:  SUBWF  x73,F
00804:  BTFSC  FD8.2
00806:  BRA    090A
00808:  BNC   0884
0080A:  MOVFF  70,79
0080E:  BSF    x79.7
00810:  MOVFF  71,78
00814:  MOVFF  72,77
00818:  CLRF   x76
0081A:  BCF    FD8.0
0081C:  RRCF   x79,F
0081E:  RRCF   x78,F
00820:  RRCF   x77,F
00822:  RRCF   x76,F
00824:  DECFSZ x73,F
00826:  BRA    0818
00828:  BTFSS  x74.7
0082A:  BRA    0832
0082C:  BSF    x75.0
0082E:  BRA    09EA
00830:  BCF    x75.0
00832:  BCF    x73.0
00834:  BSF    x75.4
00836:  CLRF   FEA
00838:  MOVLW  6E
0083A:  MOVWF  FE9
0083C:  BRA    0A10
0083E:  BCF    x75.4
00840:  BTFSC  x74.7
00842:  BRA    0858
00844:  BTFSS  x73.0
00846:  BRA    086E
00848:  RRCF   x79,F
0084A:  RRCF   x78,F
0084C:  RRCF   x77,F
0084E:  RRCF   x76,F
00850:  INCF   00,F
00852:  BTFSC  FD8.2
00854:  BRA    09E0
00856:  BRA    086E
00858:  BTFSC  x79.7
0085A:  BRA    0874
0085C:  BCF    FD8.0
0085E:  RLCF   x76,F
00860:  RLCF   x77,F
00862:  RLCF   x78,F
00864:  RLCF   x79,F
00866:  DECF   00,F
00868:  BTFSC  FD8.2
0086A:  BRA    09E0
0086C:  BRA    0858
0086E:  BSF    x75.6
00870:  BRA    0948
00872:  BCF    x75.6
00874:  MOVFF  6C,74
00878:  BTFSS  x6C.7
0087A:  BRA    0880
0087C:  BSF    x79.7
0087E:  BRA    09D2
00880:  BCF    x79.7
00882:  BRA    09D2
00884:  MOVFF  6F,73
00888:  MOVFF  6F,00
0088C:  MOVF   x6B,W
0088E:  SUBWF  x73,F
00890:  MOVFF  6C,79
00894:  BSF    x79.7
00896:  MOVFF  6D,78
0089A:  MOVFF  6E,77
0089E:  CLRF   x76
008A0:  BCF    FD8.0
008A2:  RRCF   x79,F
008A4:  RRCF   x78,F
008A6:  RRCF   x77,F
008A8:  RRCF   x76,F
008AA:  DECFSZ x73,F
008AC:  BRA    089E
008AE:  BTFSS  x74.7
008B0:  BRA    08B8
008B2:  BSF    x75.1
008B4:  BRA    09EA
008B6:  BCF    x75.1
008B8:  BCF    x73.0
008BA:  BSF    x75.5
008BC:  CLRF   FEA
008BE:  MOVLW  72
008C0:  MOVWF  FE9
008C2:  BRA    0A10
008C4:  BCF    x75.5
008C6:  BTFSC  x74.7
008C8:  BRA    08DE
008CA:  BTFSS  x73.0
008CC:  BRA    08F4
008CE:  RRCF   x79,F
008D0:  RRCF   x78,F
008D2:  RRCF   x77,F
008D4:  RRCF   x76,F
008D6:  INCF   00,F
008D8:  BTFSC  FD8.2
008DA:  BRA    09E0
008DC:  BRA    08F4
008DE:  BTFSC  x79.7
008E0:  BRA    08FA
008E2:  BCF    FD8.0
008E4:  RLCF   x76,F
008E6:  RLCF   x77,F
008E8:  RLCF   x78,F
008EA:  RLCF   x79,F
008EC:  DECF   00,F
008EE:  BTFSC  FD8.2
008F0:  BRA    09E0
008F2:  BRA    08DE
008F4:  BSF    x75.7
008F6:  BRA    0948
008F8:  BCF    x75.7
008FA:  MOVFF  70,74
008FE:  BTFSS  x70.7
00900:  BRA    0906
00902:  BSF    x79.7
00904:  BRA    09D2
00906:  BCF    x79.7
00908:  BRA    09D2
0090A:  MOVFF  70,79
0090E:  BSF    x79.7
00910:  MOVFF  71,78
00914:  MOVFF  72,77
00918:  BTFSS  x74.7
0091A:  BRA    0924
0091C:  BCF    x79.7
0091E:  BSF    x75.2
00920:  BRA    09EA
00922:  BCF    x75.2
00924:  CLRF   x76
00926:  BCF    x73.0
00928:  CLRF   FEA
0092A:  MOVLW  6E
0092C:  MOVWF  FE9
0092E:  BRA    0A10
00930:  BTFSC  x74.7
00932:  BRA    096C
00934:  MOVFF  6C,74
00938:  BTFSS  x73.0
0093A:  BRA    0948
0093C:  RRCF   x79,F
0093E:  RRCF   x78,F
00940:  RRCF   x77,F
00942:  RRCF   x76,F
00944:  INCF   00,F
00946:  BZ    09E0
00948:  BTFSS  x76.7
0094A:  BRA    0962
0094C:  INCF   x77,F
0094E:  BNZ   0962
00950:  INCF   x78,F
00952:  BNZ   0962
00954:  INCF   x79,F
00956:  BNZ   0962
00958:  RRCF   x79,F
0095A:  RRCF   x78,F
0095C:  RRCF   x77,F
0095E:  INCF   00,F
00960:  BZ    09E0
00962:  BTFSC  x75.6
00964:  BRA    0872
00966:  BTFSC  x75.7
00968:  BRA    08F8
0096A:  BRA    09A4
0096C:  MOVLW  80
0096E:  XORWF  x79,F
00970:  BTFSS  x79.7
00972:  BRA    097C
00974:  BRA    09EA
00976:  MOVFF  70,74
0097A:  BRA    0990
0097C:  MOVFF  6C,74
00980:  MOVF   x79,F
00982:  BNZ   0990
00984:  MOVF   x78,F
00986:  BNZ   0990
00988:  MOVF   x77,F
0098A:  BNZ   0990
0098C:  CLRF   00
0098E:  BRA    09D2
00990:  BTFSC  x79.7
00992:  BRA    09A4
00994:  BCF    FD8.0
00996:  RLCF   x76,F
00998:  RLCF   x77,F
0099A:  RLCF   x78,F
0099C:  RLCF   x79,F
0099E:  DECFSZ 00,F
009A0:  BRA    0990
009A2:  BRA    09E0
009A4:  BTFSS  x74.7
009A6:  BRA    09AC
009A8:  BSF    x79.7
009AA:  BRA    09D2
009AC:  BCF    x79.7
009AE:  BRA    09D2
009B0:  MOVFF  6F,00
009B4:  MOVFF  70,79
009B8:  MOVFF  71,78
009BC:  MOVFF  72,77
009C0:  BRA    09D2
009C2:  MOVFF  6B,00
009C6:  MOVFF  6C,79
009CA:  MOVFF  6D,78
009CE:  MOVFF  6E,77
009D2:  MOVFF  79,01
009D6:  MOVFF  78,02
009DA:  MOVFF  77,03
009DE:  BRA    0A48
009E0:  CLRF   00
009E2:  CLRF   01
009E4:  CLRF   02
009E6:  CLRF   03
009E8:  BRA    0A48
009EA:  CLRF   x76
009EC:  COMF   x77,F
009EE:  COMF   x78,F
009F0:  COMF   x79,F
009F2:  COMF   x76,F
009F4:  INCF   x76,F
009F6:  BNZ   0A02
009F8:  INCF   x77,F
009FA:  BNZ   0A02
009FC:  INCF   x78,F
009FE:  BNZ   0A02
00A00:  INCF   x79,F
00A02:  BTFSC  x75.0
00A04:  BRA    0830
00A06:  BTFSC  x75.1
00A08:  BRA    08B6
00A0A:  BTFSC  x75.2
00A0C:  BRA    0922
00A0E:  BRA    0976
00A10:  MOVF   FEF,W
00A12:  ADDWF  x77,F
00A14:  BNC   0A20
00A16:  INCF   x78,F
00A18:  BNZ   0A20
00A1A:  INCF   x79,F
00A1C:  BTFSC  FD8.2
00A1E:  BSF    x73.0
00A20:  MOVF   FED,F
00A22:  MOVF   FEF,W
00A24:  ADDWF  x78,F
00A26:  BNC   0A2E
00A28:  INCF   x79,F
00A2A:  BTFSC  FD8.2
00A2C:  BSF    x73.0
00A2E:  MOVF   FED,F
00A30:  MOVF   FEF,W
00A32:  BTFSC  FEF.7
00A34:  BRA    0A38
00A36:  XORLW  80
00A38:  ADDWF  x79,F
00A3A:  BTFSC  FD8.0
00A3C:  BSF    x73.0
00A3E:  BTFSC  x75.4
00A40:  BRA    083E
00A42:  BTFSC  x75.5
00A44:  BRA    08C4
00A46:  BRA    0930
00A48:  RETURN 0
00A4A:  MOVFF  75,7C
00A4E:  MOVF   x79,W
00A50:  XORWF  x7C,F
00A52:  BTFSS  x7C.7
00A54:  BRA    0A60
00A56:  BCF    FD8.2
00A58:  BCF    FD8.0
00A5A:  BTFSC  x75.7
00A5C:  BSF    FD8.0
00A5E:  BRA    0ABE
00A60:  MOVFF  75,7C
00A64:  MOVFF  78,7D
00A68:  MOVF   x74,W
00A6A:  SUBWF  x7D,F
00A6C:  BZ    0A7A
00A6E:  BTFSS  x7C.7
00A70:  BRA    0ABE
00A72:  MOVF   FD8,W
00A74:  XORLW  01
00A76:  MOVWF  FD8
00A78:  BRA    0ABE
00A7A:  MOVFF  79,7D
00A7E:  MOVF   x75,W
00A80:  SUBWF  x7D,F
00A82:  BZ    0A90
00A84:  BTFSS  x7C.7
00A86:  BRA    0ABE
00A88:  MOVF   FD8,W
00A8A:  XORLW  01
00A8C:  MOVWF  FD8
00A8E:  BRA    0ABE
00A90:  MOVFF  7A,7D
00A94:  MOVF   x76,W
00A96:  SUBWF  x7D,F
00A98:  BZ    0AA6
00A9A:  BTFSS  x7C.7
00A9C:  BRA    0ABE
00A9E:  MOVF   FD8,W
00AA0:  XORLW  01
00AA2:  MOVWF  FD8
00AA4:  BRA    0ABE
00AA6:  MOVFF  7B,7D
00AAA:  MOVF   x77,W
00AAC:  SUBWF  x7D,F
00AAE:  BZ    0ABC
00AB0:  BTFSS  x7C.7
00AB2:  BRA    0ABE
00AB4:  MOVF   FD8,W
00AB6:  XORLW  01
00AB8:  MOVWF  FD8
00ABA:  BRA    0ABE
00ABC:  BCF    FD8.0
00ABE:  RETURN 0
00AC0:  MOVLW  8E
00AC2:  MOVWF  00
00AC4:  MOVF   x74,W
00AC6:  SUBWF  00,F
00AC8:  MOVFF  75,02
00ACC:  MOVFF  76,01
00AD0:  BSF    02.7
00AD2:  MOVF   00,F
00AD4:  BZ    0AE8
00AD6:  BCF    FD8.0
00AD8:  MOVF   02,F
00ADA:  BNZ   0AE0
00ADC:  MOVF   01,F
00ADE:  BZ    0AE8
00AE0:  RRCF   02,F
00AE2:  RRCF   01,F
00AE4:  DECFSZ 00,F
00AE6:  BRA    0AD6
00AE8:  BTFSS  x75.7
00AEA:  BRA    0AF6
00AEC:  COMF   01,F
00AEE:  COMF   02,F
00AF0:  INCF   01,F
00AF2:  BTFSC  FD8.2
00AF4:  INCF   02,F
00AF6:  GOTO   0C16 (RETURN)
.................... 
.................... #list
.................... 
.................... #fuses      INTRC, NOWDT, NOPROTECT, NOLVP, CCP2C1, CCP3B5              // Fusibles (Multiplexado de P2B en C0)
.................... #use        delay(internal = 16MHz)                                     // Configuracion de frecuencia y delay
*
00472:  CLRF   FEA
00474:  MOVLW  59
00476:  MOVWF  FE9
00478:  MOVF   FEF,W
0047A:  BZ    0498
0047C:  MOVLW  05
0047E:  MOVWF  01
00480:  CLRF   00
00482:  DECFSZ 00,F
00484:  BRA    0482
00486:  DECFSZ 01,F
00488:  BRA    0480
0048A:  MOVLW  2E
0048C:  MOVWF  00
0048E:  DECFSZ 00,F
00490:  BRA    048E
00492:  BRA    0494
00494:  DECFSZ FEF,F
00496:  BRA    047C
00498:  GOTO   110C (RETURN)
.................... #use        rs232(rcv = pin_c7, xmit = pin_c6, baud = 9600, bits = 8, parity = n) 
.................... 
.................... #include    <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
00112:  CLRF   x8D
....................    sign = 0;
00114:  CLRF   x8B
....................    base = 10;
00116:  MOVLW  0A
00118:  MOVWF  x8C
....................    result = 0;
0011A:  CLRF   x8A
0011C:  CLRF   x89
.................... 
....................    if (!s)
0011E:  MOVF   x87,W
00120:  IORWF  x88,W
00122:  BNZ   012C
....................       return 0;
00124:  MOVLW  00
00126:  MOVWF  01
00128:  MOVWF  02
0012A:  BRA    02E2
....................    c = s[index++];
0012C:  MOVF   x8D,W
0012E:  INCF   x8D,F
00130:  ADDWF  x87,W
00132:  MOVWF  FE9
00134:  MOVLW  00
00136:  ADDWFC x88,W
00138:  MOVWF  FEA
0013A:  MOVFF  FEF,8E
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
0013E:  MOVF   x8E,W
00140:  SUBLW  2D
00142:  BNZ   015C
....................    {
....................       sign = 1;         // Set the sign to negative
00144:  MOVLW  01
00146:  MOVWF  x8B
....................       c = s[index++];
00148:  MOVF   x8D,W
0014A:  INCF   x8D,F
0014C:  ADDWF  x87,W
0014E:  MOVWF  FE9
00150:  MOVLW  00
00152:  ADDWFC x88,W
00154:  MOVWF  FEA
00156:  MOVFF  FEF,8E
....................    }
0015A:  BRA    0174
....................    else if (c == '+')
0015C:  MOVF   x8E,W
0015E:  SUBLW  2B
00160:  BNZ   0174
....................    {
....................       c = s[index++];
00162:  MOVF   x8D,W
00164:  INCF   x8D,F
00166:  ADDWF  x87,W
00168:  MOVWF  FE9
0016A:  MOVLW  00
0016C:  ADDWFC x88,W
0016E:  MOVWF  FEA
00170:  MOVFF  FEF,8E
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
00174:  MOVF   x8E,W
00176:  SUBLW  2F
00178:  BTFSC  FD8.0
0017A:  BRA    02C6
0017C:  MOVF   x8E,W
0017E:  SUBLW  39
00180:  BTFSS  FD8.0
00182:  BRA    02C6
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
00184:  MOVF   x8E,W
00186:  SUBLW  30
00188:  BNZ   01C6
0018A:  MOVF   x8D,W
0018C:  ADDWF  x87,W
0018E:  MOVWF  FE9
00190:  MOVLW  00
00192:  ADDWFC x88,W
00194:  MOVWF  FEA
00196:  MOVF   FEF,W
00198:  SUBLW  78
0019A:  BZ    01AE
0019C:  MOVF   x8D,W
0019E:  ADDWF  x87,W
001A0:  MOVWF  FE9
001A2:  MOVLW  00
001A4:  ADDWFC x88,W
001A6:  MOVWF  FEA
001A8:  MOVF   FEF,W
001AA:  SUBLW  58
001AC:  BNZ   01C6
....................       {
....................          base = 16;
001AE:  MOVLW  10
001B0:  MOVWF  x8C
....................          index++;
001B2:  INCF   x8D,F
....................          c = s[index++];
001B4:  MOVF   x8D,W
001B6:  INCF   x8D,F
001B8:  ADDWF  x87,W
001BA:  MOVWF  FE9
001BC:  MOVLW  00
001BE:  ADDWFC x88,W
001C0:  MOVWF  FEA
001C2:  MOVFF  FEF,8E
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
001C6:  MOVF   x8C,W
001C8:  SUBLW  0A
001CA:  BNZ   020C
....................       {
....................          while (c >= '0' && c <= '9')
001CC:  MOVF   x8E,W
001CE:  SUBLW  2F
001D0:  BC    020A
001D2:  MOVF   x8E,W
001D4:  SUBLW  39
001D6:  BNC   020A
....................          {
....................             result = 10*result + (c - '0');
001D8:  CLRF   x90
001DA:  MOVLW  0A
001DC:  MOVWF  x8F
001DE:  MOVFF  8A,92
001E2:  MOVFF  89,91
001E6:  BRA    00C0
001E8:  MOVLW  30
001EA:  SUBWF  x8E,W
001EC:  ADDWF  01,W
001EE:  MOVWF  x89
001F0:  MOVLW  00
001F2:  ADDWFC 02,W
001F4:  MOVWF  x8A
....................             c = s[index++];
001F6:  MOVF   x8D,W
001F8:  INCF   x8D,F
001FA:  ADDWF  x87,W
001FC:  MOVWF  FE9
001FE:  MOVLW  00
00200:  ADDWFC x88,W
00202:  MOVWF  FEA
00204:  MOVFF  FEF,8E
00208:  BRA    01CC
....................          }
....................       }
0020A:  BRA    02C6
....................       else if (base == 16)    // The number is a hexa number
0020C:  MOVF   x8C,W
0020E:  SUBLW  10
00210:  BNZ   02C6
....................       {
....................          c = toupper(c);
00212:  MOVF   x8E,W
00214:  SUBLW  60
00216:  BC    0224
00218:  MOVF   x8E,W
0021A:  SUBLW  7A
0021C:  BNC   0224
0021E:  MOVF   x8E,W
00220:  ANDLW  DF
00222:  BRA    0226
00224:  MOVF   x8E,W
00226:  MOVWF  x8E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
00228:  MOVF   x8E,W
0022A:  SUBLW  2F
0022C:  BC    0234
0022E:  MOVF   x8E,W
00230:  SUBLW  39
00232:  BC    0240
00234:  MOVF   x8E,W
00236:  SUBLW  40
00238:  BC    02C6
0023A:  MOVF   x8E,W
0023C:  SUBLW  46
0023E:  BNC   02C6
....................          {
....................             if (c >= '0' && c <= '9')
00240:  MOVF   x8E,W
00242:  SUBLW  2F
00244:  BC    0274
00246:  MOVF   x8E,W
00248:  SUBLW  39
0024A:  BNC   0274
....................                result = (result << 4) + (c - '0');
0024C:  RLCF   x89,W
0024E:  MOVWF  x8F
00250:  RLCF   x8A,W
00252:  MOVWF  x90
00254:  RLCF   x8F,F
00256:  RLCF   x90,F
00258:  RLCF   x8F,F
0025A:  RLCF   x90,F
0025C:  RLCF   x8F,F
0025E:  RLCF   x90,F
00260:  MOVLW  F0
00262:  ANDWF  x8F,F
00264:  MOVLW  30
00266:  SUBWF  x8E,W
00268:  ADDWF  x8F,W
0026A:  MOVWF  x89
0026C:  MOVLW  00
0026E:  ADDWFC x90,W
00270:  MOVWF  x8A
00272:  BRA    029C
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
00274:  RLCF   x89,W
00276:  MOVWF  x8F
00278:  RLCF   x8A,W
0027A:  MOVWF  x90
0027C:  RLCF   x8F,F
0027E:  RLCF   x90,F
00280:  RLCF   x8F,F
00282:  RLCF   x90,F
00284:  RLCF   x8F,F
00286:  RLCF   x90,F
00288:  MOVLW  F0
0028A:  ANDWF  x8F,F
0028C:  MOVLW  41
0028E:  SUBWF  x8E,W
00290:  ADDLW  0A
00292:  ADDWF  x8F,W
00294:  MOVWF  x89
00296:  MOVLW  00
00298:  ADDWFC x90,W
0029A:  MOVWF  x8A
.................... 
....................             c = s[index++];c = toupper(c);
0029C:  MOVF   x8D,W
0029E:  INCF   x8D,F
002A0:  ADDWF  x87,W
002A2:  MOVWF  FE9
002A4:  MOVLW  00
002A6:  ADDWFC x88,W
002A8:  MOVWF  FEA
002AA:  MOVFF  FEF,8E
002AE:  MOVF   x8E,W
002B0:  SUBLW  60
002B2:  BC    02C0
002B4:  MOVF   x8E,W
002B6:  SUBLW  7A
002B8:  BNC   02C0
002BA:  MOVF   x8E,W
002BC:  ANDLW  DF
002BE:  BRA    02C2
002C0:  MOVF   x8E,W
002C2:  MOVWF  x8E
002C4:  BRA    0228
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
002C6:  MOVF   x8C,W
002C8:  SUBLW  0A
002CA:  BNZ   02DA
002CC:  DECFSZ x8B,W
002CE:  BRA    02DA
....................       result = -result;
002D0:  COMF   x89,F
002D2:  COMF   x8A,F
002D4:  INCF   x89,F
002D6:  BTFSC  FD8.2
002D8:  INCF   x8A,F
.................... 
....................    return(result);
002DA:  MOVFF  89,01
002DE:  MOVFF  8A,02
002E2:  RETURN 0
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include    "wheel_control.c"
.................... #define     FORWARD     1
.................... #define     BACK        0
.................... 
.................... #define     max_dutycicle       320
.................... #define     max_trigger_value   255
.................... #define     max_joystick_value  32767
.................... 
.................... // -------------------- Direcciones de registros -------------------- //
.................... #BYTE       CCPTMRS0        = 0xF49
.................... #BYTE       CCPTMRS1        = 0xF48
.................... 
.................... #BYTE       CCP1CON         = 0xFBD
.................... #BYTE       CCP2CON         = 0xF66
.................... #BYTE       CCP3CON         = 0xF5D
.................... #BYTE       CCP4CON         = 0xF57
.................... 
.................... #BYTE       T2CON           = 0xFBA
.................... #BYTE       PR2             = 0xFBB
.................... 
.................... // -------------------------- Estructuras --------------------------- //
.................... struct bth_conection_t
.................... {
....................     short updated_data;
....................     short IsConnected;
.................... };
.................... 
.................... struct motor_t
.................... {
....................     int     *DutyCicle;
....................     long    IN1_pin;
....................     long    IN2_pin;
.................... };
.................... 
.................... struct controller_t
.................... {
....................     signed long     Joystick[2];    // Entero de -32768 a 32767 (0 eje x, 1 eje y)
....................     int             Triggers[2];    // Entero de 0 a 255 (0 izquierdo, 1 derecho)
.................... };
.................... 
.................... // ---------------------------- Funciones --------------------------- //
.................... void motors_init(struct motor_t tires[2][2])
.................... {
....................     // Configuracion de Timers
....................     T2CON       = 0b00000100;
*
003F2:  MOVLW  04
003F4:  MOVWF  FBA
....................     PR2         = 79;
003F6:  MOVLW  4F
003F8:  MOVWF  FBB
....................     
....................     // Configuracion de CCPXCON para PWM
....................     CCPTMRS0 = CCPTMRS0 = 0b00000000;       // Configuramos CCPX con timer 2
003FA:  MOVLB  F
003FC:  CLRF   x49
....................     
....................     // Configiracion de modulo CCPX para PWM
....................     CCP4CON = 0b00001100;
003FE:  MOVLW  0C
00400:  MOVWF  x57
....................     CCP3CON = 0b00001100;
00402:  MOVWF  x5D
....................     CCP2CON = 0b00001100;
00404:  MOVWF  F66
....................     CCP1CON = 0b00001100;
00406:  MOVWF  FBD
.................... 
....................     for(int i = 0; i < 2 ; i++)
00408:  CLRF   5B
0040A:  MOVF   5B,W
0040C:  SUBLW  01
0040E:  BNC   046C
....................         for(int j = 0; j < 2; j++)
00410:  CLRF   5C
00412:  MOVF   5C,W
00414:  SUBLW  01
00416:  BNC   0468
....................             *(tires[i][j].DutyCicle) = 0;
00418:  MOVLB  0
0041A:  CLRF   x60
0041C:  MOVFF  5B,5F
00420:  CLRF   x62
00422:  MOVLW  0C
00424:  MOVWF  x61
00426:  RCALL  03D4
00428:  MOVFF  02,5E
0042C:  MOVFF  01,5D
00430:  CLRF   x60
00432:  MOVFF  5C,5F
00436:  CLRF   x62
00438:  MOVLW  06
0043A:  MOVWF  x61
0043C:  RCALL  03D4
0043E:  MOVF   01,W
00440:  ADDWF  5D,F
00442:  MOVF   02,W
00444:  ADDWFC 5E,F
00446:  MOVF   59,W
00448:  ADDWF  5D,W
0044A:  MOVWF  FE9
0044C:  MOVF   5A,W
0044E:  ADDWFC 5E,W
00450:  MOVWF  FEA
00452:  MOVFF  FEC,03
00456:  MOVF   FED,F
00458:  MOVFF  FEF,FE9
0045C:  MOVFF  03,FEA
00460:  CLRF   FEF
00462:  INCF   5C,F
00464:  MOVLB  F
00466:  BRA    0412
00468:  INCF   5B,F
0046A:  BRA    040A
0046C:  MOVLB  0
0046E:  GOTO   10E2 (RETURN)
.................... }
.................... 
.................... void motor_movement(struct motor_t *motor, float speed)   // Modo de movimiento normal
.................... {
....................     short direction;
....................     
....................     if(speed >= 0)           // Movimiento hacia adelante
*
00AFA:  CLRF   x77
00AFC:  CLRF   x76
00AFE:  CLRF   x75
00B00:  CLRF   x74
00B02:  MOVFF  70,7B
00B06:  MOVFF  6F,7A
00B0A:  MOVFF  6E,79
00B0E:  MOVFF  6D,78
00B12:  RCALL  0A4A
00B14:  BC    0B18
00B16:  BNZ   0B1C
....................         direction = FORWARD;
00B18:  BSF    x71.0
00B1A:  BRA    0B40
....................     else if(speed < 0)      // Movimiento hacia atras
00B1C:  MOVFF  70,77
00B20:  MOVFF  6F,76
00B24:  MOVFF  6E,75
00B28:  MOVFF  6D,74
00B2C:  CLRF   x7B
00B2E:  CLRF   x7A
00B30:  CLRF   x79
00B32:  CLRF   x78
00B34:  RCALL  0A4A
00B36:  BNC   0B40
....................     {
....................         direction = BACK;
00B38:  BCF    x71.0
....................         speed = -speed;     // Para calculo de DutyCicle
00B3A:  MOVF   x6E,W
00B3C:  XORLW  80
00B3E:  MOVWF  x6E
....................     }
....................     
....................     // Establecemos direccion de giro
....................     output_bit(motor->IN1_pin, direction);
00B40:  MOVLW  02
00B42:  ADDWF  x6B,W
00B44:  MOVWF  FE9
00B46:  MOVLW  00
00B48:  ADDWFC x6C,W
00B4A:  MOVWF  FEA
00B4C:  MOVFF  FEC,75
00B50:  MOVF   FED,F
00B52:  MOVFF  FEF,74
00B56:  MOVLW  00
00B58:  BTFSC  x71.0
00B5A:  MOVLW  01
00B5C:  MOVFF  74,76
00B60:  MOVWF  x77
00B62:  MOVLW  0F
00B64:  MOVWF  x79
00B66:  MOVLW  89
00B68:  MOVWF  x78
00B6A:  RCALL  049C
00B6C:  MOVFF  74,76
00B70:  CLRF   x77
00B72:  MOVLW  0F
00B74:  MOVWF  x79
00B76:  MOVLW  92
00B78:  MOVWF  x78
00B7A:  RCALL  049C
....................     output_bit(motor->IN2_pin, !direction);
00B7C:  MOVLW  04
00B7E:  ADDWF  x6B,W
00B80:  MOVWF  FE9
00B82:  MOVLW  00
00B84:  ADDWFC x6C,W
00B86:  MOVWF  FEA
00B88:  MOVFF  FEC,75
00B8C:  MOVF   FED,F
00B8E:  MOVFF  FEF,74
00B92:  MOVLW  00
00B94:  BTFSS  x71.0
00B96:  MOVLW  01
00B98:  MOVFF  74,76
00B9C:  MOVWF  x77
00B9E:  MOVLW  0F
00BA0:  MOVWF  x79
00BA2:  MOVLW  89
00BA4:  MOVWF  x78
00BA6:  RCALL  049C
00BA8:  MOVFF  74,76
00BAC:  CLRF   x77
00BAE:  MOVLW  0F
00BB0:  MOVWF  x79
00BB2:  MOVLW  92
00BB4:  MOVWF  x78
00BB6:  RCALL  049C
.................... 
....................     // Establecemos DC para velocidad
....................     long aux = max_dutycicle * speed / 100;      // Ver si eliminar
00BB8:  CLRF   x77
00BBA:  CLRF   x76
00BBC:  MOVLW  20
00BBE:  MOVWF  x75
00BC0:  MOVLW  87
00BC2:  MOVWF  x74
00BC4:  MOVFF  70,7B
00BC8:  MOVFF  6F,7A
00BCC:  MOVFF  6E,79
00BD0:  MOVFF  6D,78
00BD4:  RCALL  0594
00BD6:  MOVFF  03,77
00BDA:  MOVFF  02,76
00BDE:  MOVFF  01,75
00BE2:  MOVFF  00,74
00BE6:  MOVFF  03,7B
00BEA:  MOVFF  02,7A
00BEE:  MOVFF  01,79
00BF2:  MOVFF  00,78
00BF6:  CLRF   x7F
00BF8:  CLRF   x7E
00BFA:  MOVLW  48
00BFC:  MOVWF  x7D
00BFE:  MOVLW  85
00C00:  MOVWF  x7C
00C02:  RCALL  0686
00C04:  MOVFF  03,77
00C08:  MOVFF  02,76
00C0C:  MOVFF  01,75
00C10:  MOVFF  00,74
00C14:  BRA    0AC0
00C16:  MOVFF  02,73
00C1A:  MOVFF  01,72
....................     *(motor->DutyCicle) = aux >> 2;     // Revisar
00C1E:  MOVFF  6B,FE9
00C22:  MOVFF  6C,FEA
00C26:  MOVFF  FEC,03
00C2A:  MOVF   FED,F
00C2C:  MOVFF  FEF,FE9
00C30:  MOVFF  03,FEA
00C34:  RRCF   x73,W
00C36:  MOVWF  03
00C38:  RRCF   x72,W
00C3A:  MOVWF  02
00C3C:  RRCF   03,F
00C3E:  RRCF   02,F
00C40:  MOVLW  3F
00C42:  ANDWF  03,F
00C44:  MOVFF  02,FEF
00C48:  RETURN 0
.................... }
.................... 
.................... void motor_shortbrake(struct motor_t *motor)    // Modo de freno de corto (Solo para emergencias)
.................... {
....................     output_high(motor->IN1_pin);
*
004DA:  MOVLW  02
004DC:  ADDWF  x6B,W
004DE:  MOVWF  FE9
004E0:  MOVLW  00
004E2:  ADDWFC x6C,W
004E4:  MOVWF  FEA
004E6:  MOVFF  FEC,6E
004EA:  MOVF   FED,F
004EC:  MOVFF  FEF,6D
004F0:  MOVFF  6D,76
004F4:  MOVLW  01
004F6:  MOVWF  x77
004F8:  MOVLW  0F
004FA:  MOVWF  x79
004FC:  MOVLW  89
004FE:  MOVWF  x78
00500:  RCALL  049C
00502:  MOVFF  6D,76
00506:  CLRF   x77
00508:  MOVLW  0F
0050A:  MOVWF  x79
0050C:  MOVLW  92
0050E:  MOVWF  x78
00510:  RCALL  049C
....................     output_high(motor->IN2_pin);
00512:  MOVLW  04
00514:  ADDWF  x6B,W
00516:  MOVWF  FE9
00518:  MOVLW  00
0051A:  ADDWFC x6C,W
0051C:  MOVWF  FEA
0051E:  MOVFF  FEC,6E
00522:  MOVF   FED,F
00524:  MOVFF  FEF,6D
00528:  MOVFF  6D,76
0052C:  MOVLW  01
0052E:  MOVWF  x77
00530:  MOVLW  0F
00532:  MOVWF  x79
00534:  MOVLW  89
00536:  MOVWF  x78
00538:  RCALL  049C
0053A:  MOVFF  6D,76
0053E:  CLRF   x77
00540:  MOVLW  0F
00542:  MOVWF  x79
00544:  MOVLW  92
00546:  MOVWF  x78
00548:  RCALL  049C
0054A:  RETURN 0
.................... }
.................... 
.................... void drive_tires(struct controller_t *xbox_controller, struct motor_t tires[2][2])
.................... {    
....................     // Si estan presionados los 2 al maximo, aplicamos freno de corto y salimos de funcion
....................     if((xbox_controller->Triggers[0] == 255) && (xbox_controller->Triggers[1] == 255))
*
00C4A:  MOVLW  04
00C4C:  ADDWF  5B,W
00C4E:  MOVWF  FE9
00C50:  MOVLW  00
00C52:  ADDWFC 5C,W
00C54:  MOVWF  FEA
00C56:  INCFSZ FEF,W
00C58:  BRA    0CCC
00C5A:  MOVLW  05
00C5C:  ADDWF  5B,W
00C5E:  MOVWF  FE9
00C60:  MOVLW  00
00C62:  ADDWFC 5C,W
00C64:  MOVWF  FEA
00C66:  INCFSZ FEF,W
00C68:  BRA    0CCC
....................     {
....................         // Activamos modo short brake
....................         motor_shortbrake(&tires[0][0]), motor_shortbrake(&tires[0][1]);
00C6A:  MOVFF  5D,01
00C6E:  MOVFF  5E,03
00C72:  MOVFF  5E,6C
00C76:  MOVFF  5D,6B
00C7A:  RCALL  04DA
00C7C:  MOVLW  06
00C7E:  ADDWF  5D,W
00C80:  MOVWF  01
00C82:  MOVLW  00
00C84:  ADDWFC 5E,W
00C86:  MOVWF  03
00C88:  MOVFF  01,69
00C8C:  MOVWF  x6A
00C8E:  MOVWF  x6C
00C90:  MOVFF  01,6B
00C94:  RCALL  04DA
....................         motor_shortbrake(&tires[1][0]), motor_shortbrake(&tires[1][1]);
00C96:  MOVLW  0C
00C98:  ADDWF  5D,W
00C9A:  MOVWF  01
00C9C:  MOVLW  00
00C9E:  ADDWFC 5E,W
00CA0:  MOVWF  03
00CA2:  MOVFF  01,69
00CA6:  MOVWF  x6A
00CA8:  MOVWF  x6C
00CAA:  MOVFF  01,6B
00CAE:  RCALL  04DA
00CB0:  MOVLW  12
00CB2:  ADDWF  5D,W
00CB4:  MOVWF  01
00CB6:  MOVLW  00
00CB8:  ADDWFC 5E,W
00CBA:  MOVWF  03
00CBC:  MOVFF  01,69
00CC0:  MOVWF  x6A
00CC2:  MOVWF  x6C
00CC4:  MOVFF  01,6B
00CC8:  RCALL  04DA
....................         
....................         return;
00CCA:  BRA    103C
....................     }
.................... 
....................     /*  Notas para comprender
....................     * Llanta contraria al giro, avanza con normalidad a la velocidad indicada (speed)
....................     * Llanta de apoyo, gira a menor velocidad en funcion de que tan desviado hacia la direccion esta el joystick 
....................          (-speed < turning_speed < speed)
....................     */
.................... 
....................     // Si no se aplico freno de corto, calculamos velocidad y direccion de movimiento
....................     
....................     float speed[2];
....................     signed long trigger_diff = (signed long) xbox_controller->Triggers[1] - xbox_controller->Triggers[0];
00CCC:  MOVLW  05
00CCE:  ADDWF  5B,W
00CD0:  MOVWF  FE9
00CD2:  MOVLW  00
00CD4:  ADDWFC 5C,W
00CD6:  MOVWF  FEA
00CD8:  MOVF   FEF,W
00CDA:  CLRF   x6A
00CDC:  MOVWF  x69
00CDE:  MOVLW  04
00CE0:  ADDWF  5B,W
00CE2:  MOVWF  FE9
00CE4:  MOVLW  00
00CE6:  ADDWFC 5C,W
00CE8:  MOVWF  FEA
00CEA:  MOVF   FEF,W
00CEC:  SUBWF  x69,W
00CEE:  MOVWF  x67
00CF0:  MOVLW  00
00CF2:  SUBWFB x6A,W
00CF4:  MOVWF  x68
.................... 
....................     if(xbox_controller->Joystick[0] >= 0)        // El movimiento es a la derecha o al centro
00CF6:  MOVFF  5B,FE9
00CFA:  MOVFF  5C,FEA
00CFE:  MOVFF  FEC,6A
00D02:  MOVF   FED,F
00D04:  MOVFF  FEF,69
00D08:  BTFSC  x6A.7
00D0A:  BRA    0E52
....................     {
....................         // Llanta izquierda avanza normal
....................         speed[0] = trigger_diff * 100.0 / max_trigger_value;
00D0C:  MOVFF  68,6E
00D10:  MOVFF  67,6D
00D14:  RCALL  054C
00D16:  MOVFF  03,77
00D1A:  MOVFF  02,76
00D1E:  MOVFF  01,75
00D22:  MOVFF  00,74
00D26:  CLRF   x7B
00D28:  CLRF   x7A
00D2A:  MOVLW  48
00D2C:  MOVWF  x79
00D2E:  MOVLW  85
00D30:  MOVWF  x78
00D32:  RCALL  0594
00D34:  MOVFF  03,6C
00D38:  MOVFF  02,6B
00D3C:  MOVFF  01,6A
00D40:  MOVFF  00,69
00D44:  MOVFF  03,7B
00D48:  MOVFF  02,7A
00D4C:  MOVFF  01,79
00D50:  MOVFF  00,78
00D54:  CLRF   x7F
00D56:  CLRF   x7E
00D58:  MOVLW  7F
00D5A:  MOVWF  x7D
00D5C:  MOVLW  86
00D5E:  MOVWF  x7C
00D60:  RCALL  0686
00D62:  MOVFF  03,62
00D66:  MOVFF  02,61
00D6A:  MOVFF  01,60
00D6E:  MOVFF  00,5F
....................         // Flotante de -100 a 100 que indica la velocidad y direccion de movimiento (+ adelante, - atras)
.................... 
....................         // Llanta derecha avanza como punto de apoyo para curva, por lo que calculamos velocidad de giro, en funcion de que tan cercano esta al valor maximo o minimo del eje X
....................         speed[1] = speed[0] - (2 * speed[0] * xbox_controller->Joystick[0] / 32767.0);
00D72:  CLRF   x77
00D74:  CLRF   x76
00D76:  CLRF   x75
00D78:  MOVLW  80
00D7A:  MOVWF  x74
00D7C:  MOVFF  62,7B
00D80:  MOVFF  61,7A
00D84:  MOVFF  60,79
00D88:  MOVFF  5F,78
00D8C:  RCALL  0594
00D8E:  MOVFF  03,6C
00D92:  MOVFF  02,6B
00D96:  MOVFF  01,6A
00D9A:  MOVFF  00,69
00D9E:  MOVFF  5B,FE9
00DA2:  MOVFF  5C,FEA
00DA6:  MOVFF  FEC,03
00DAA:  MOVF   FED,F
00DAC:  MOVFF  FEF,6D
00DB0:  MOVFF  03,6E
00DB4:  CALL   054C
00DB8:  MOVFF  6C,77
00DBC:  MOVFF  6B,76
00DC0:  MOVFF  6A,75
00DC4:  MOVFF  69,74
00DC8:  MOVFF  03,7B
00DCC:  MOVFF  02,7A
00DD0:  MOVFF  01,79
00DD4:  MOVFF  00,78
00DD8:  CALL   0594
00DDC:  MOVFF  03,6C
00DE0:  MOVFF  02,6B
00DE4:  MOVFF  01,6A
00DE8:  MOVFF  00,69
00DEC:  MOVFF  03,7B
00DF0:  MOVFF  02,7A
00DF4:  MOVFF  01,79
00DF8:  MOVFF  00,78
00DFC:  CLRF   x7F
00DFE:  MOVLW  FE
00E00:  MOVWF  x7E
00E02:  MOVLW  7F
00E04:  MOVWF  x7D
00E06:  MOVLW  8D
00E08:  MOVWF  x7C
00E0A:  RCALL  0686
00E0C:  MOVFF  FEA,6A
00E10:  MOVFF  FE9,69
00E14:  BSF    FD8.1
00E16:  MOVFF  62,6E
00E1A:  MOVFF  61,6D
00E1E:  MOVFF  60,6C
00E22:  MOVFF  5F,6B
00E26:  MOVFF  03,72
00E2A:  MOVFF  02,71
00E2E:  MOVFF  01,70
00E32:  MOVFF  00,6F
00E36:  RCALL  07E0
00E38:  MOVFF  6A,FEA
00E3C:  MOVFF  69,FE9
00E40:  MOVFF  03,66
00E44:  MOVFF  02,65
00E48:  MOVFF  01,64
00E4C:  MOVFF  00,63
....................         // Velocidad - (2 veces Velocidad * (Valor Joystick X / Valor maximo Joystick X))
....................     }
00E50:  BRA    0F9C
....................     else                                        // El movimiento es a la izquierda
....................     {
....................         // Llanta derecha avanza normal
....................         speed[1] = trigger_diff * 100.0 / max_trigger_value;
00E52:  MOVFF  68,6E
00E56:  MOVFF  67,6D
00E5A:  CALL   054C
00E5E:  MOVFF  03,77
00E62:  MOVFF  02,76
00E66:  MOVFF  01,75
00E6A:  MOVFF  00,74
00E6E:  CLRF   x7B
00E70:  CLRF   x7A
00E72:  MOVLW  48
00E74:  MOVWF  x79
00E76:  MOVLW  85
00E78:  MOVWF  x78
00E7A:  CALL   0594
00E7E:  MOVFF  03,6C
00E82:  MOVFF  02,6B
00E86:  MOVFF  01,6A
00E8A:  MOVFF  00,69
00E8E:  MOVFF  03,7B
00E92:  MOVFF  02,7A
00E96:  MOVFF  01,79
00E9A:  MOVFF  00,78
00E9E:  CLRF   x7F
00EA0:  CLRF   x7E
00EA2:  MOVLW  7F
00EA4:  MOVWF  x7D
00EA6:  MOVLW  86
00EA8:  MOVWF  x7C
00EAA:  CALL   0686
00EAE:  MOVFF  03,66
00EB2:  MOVFF  02,65
00EB6:  MOVFF  01,64
00EBA:  MOVFF  00,63
....................         // Flotante de -100 a 100 que indica la velocidad y direccion de movimiento (+ adelante, - atras)
.................... 
....................         // Llanta izquierda avanza como punto de apoyo para curva, por lo que Calculamos velocidad de giro, en funcion de que tan cercano esta al valor maximo o minimo del eje X
....................         speed[0] = speed[1] - (2 * speed[1] * xbox_controller->Joystick[0] / 32768.0);
00EBE:  CLRF   x77
00EC0:  CLRF   x76
00EC2:  CLRF   x75
00EC4:  MOVLW  80
00EC6:  MOVWF  x74
00EC8:  MOVFF  66,7B
00ECC:  MOVFF  65,7A
00ED0:  MOVFF  64,79
00ED4:  MOVFF  63,78
00ED8:  CALL   0594
00EDC:  MOVFF  03,6C
00EE0:  MOVFF  02,6B
00EE4:  MOVFF  01,6A
00EE8:  MOVFF  00,69
00EEC:  MOVFF  5B,FE9
00EF0:  MOVFF  5C,FEA
00EF4:  MOVFF  FEC,03
00EF8:  MOVF   FED,F
00EFA:  MOVFF  FEF,6D
00EFE:  MOVFF  03,6E
00F02:  CALL   054C
00F06:  MOVFF  6C,77
00F0A:  MOVFF  6B,76
00F0E:  MOVFF  6A,75
00F12:  MOVFF  69,74
00F16:  MOVFF  03,7B
00F1A:  MOVFF  02,7A
00F1E:  MOVFF  01,79
00F22:  MOVFF  00,78
00F26:  CALL   0594
00F2A:  MOVFF  03,6C
00F2E:  MOVFF  02,6B
00F32:  MOVFF  01,6A
00F36:  MOVFF  00,69
00F3A:  MOVFF  03,7B
00F3E:  MOVFF  02,7A
00F42:  MOVFF  01,79
00F46:  MOVFF  00,78
00F4A:  CLRF   x7F
00F4C:  CLRF   x7E
00F4E:  CLRF   x7D
00F50:  MOVLW  8E
00F52:  MOVWF  x7C
00F54:  CALL   0686
00F58:  MOVFF  FEA,6A
00F5C:  MOVFF  FE9,69
00F60:  BSF    FD8.1
00F62:  MOVFF  66,6E
00F66:  MOVFF  65,6D
00F6A:  MOVFF  64,6C
00F6E:  MOVFF  63,6B
00F72:  MOVFF  03,72
00F76:  MOVFF  02,71
00F7A:  MOVFF  01,70
00F7E:  MOVFF  00,6F
00F82:  RCALL  07E0
00F84:  MOVFF  6A,FEA
00F88:  MOVFF  69,FE9
00F8C:  MOVFF  03,62
00F90:  MOVFF  02,61
00F94:  MOVFF  01,60
00F98:  MOVFF  00,5F
....................         // Velocidad - (2 veces Velocidad * (Valor Joystick X / Valor maximo Joystick X))
....................     }
.................... 
....................     // Enviamos movimiento a las llantas //
....................     motor_movement(&tires[0][0], speed[0]);      // Llanta delantera izquierda
00F9C:  MOVFF  5D,01
00FA0:  MOVFF  5E,03
00FA4:  MOVFF  5E,6C
00FA8:  MOVFF  5D,6B
00FAC:  MOVFF  62,70
00FB0:  MOVFF  61,6F
00FB4:  MOVFF  60,6E
00FB8:  MOVFF  5F,6D
00FBC:  RCALL  0AFA
....................     motor_movement(&tires[1][0], speed[0]);      // Llanta trasera izquierda
00FBE:  MOVLW  0C
00FC0:  ADDWF  5D,W
00FC2:  MOVWF  01
00FC4:  MOVLW  00
00FC6:  ADDWFC 5E,W
00FC8:  MOVWF  03
00FCA:  MOVFF  01,69
00FCE:  MOVWF  x6A
00FD0:  MOVWF  x6C
00FD2:  MOVFF  01,6B
00FD6:  MOVFF  62,70
00FDA:  MOVFF  61,6F
00FDE:  MOVFF  60,6E
00FE2:  MOVFF  5F,6D
00FE6:  RCALL  0AFA
....................     
....................     motor_movement(&tires[0][1], speed[1]);      // Llanta delantera derecha
00FE8:  MOVLW  06
00FEA:  ADDWF  5D,W
00FEC:  MOVWF  01
00FEE:  MOVLW  00
00FF0:  ADDWFC 5E,W
00FF2:  MOVWF  03
00FF4:  MOVFF  01,69
00FF8:  MOVWF  x6A
00FFA:  MOVWF  x6C
00FFC:  MOVFF  01,6B
01000:  MOVFF  66,70
01004:  MOVFF  65,6F
01008:  MOVFF  64,6E
0100C:  MOVFF  63,6D
01010:  RCALL  0AFA
....................     motor_movement(&tires[1][1], speed[1]);      // Llanta trasera derecha
01012:  MOVLW  12
01014:  ADDWF  5D,W
01016:  MOVWF  01
01018:  MOVLW  00
0101A:  ADDWFC 5E,W
0101C:  MOVWF  03
0101E:  MOVFF  01,69
01022:  MOVWF  x6A
01024:  MOVWF  x6C
01026:  MOVFF  01,6B
0102A:  MOVFF  66,70
0102E:  MOVFF  65,6F
01032:  MOVFF  64,6E
01036:  MOVFF  63,6D
0103A:  RCALL  0AFA
0103C:  RETURN 0
.................... }
.................... 
.................... /*
.................... Los gatillos establecen la velocidad maxima de giro, y la posicion del joystick establece como se repartira esta velocidad en las llantas, para poder hacer diferentes maniobras, por ejemlo:
.................... 
.................... * Cuanto mas pegado al maximo o minimo del eje Y, mayor sera la diferencia de velocidad entre las llantas de la izquierda con las de la derecha
.................... * Cuanto mas pegado al maximo o minimo del eje X, mayor sera la diferencia de velocidad entre las llantas de arriba y abajo
.................... 
.................... Por lo tanto: 
.................... * La llanta mas lejana a la direccion de movimiento en X tendra mas velocidad que la mas pegada
.................... * La llanta mas lejana a la direccion de movimiento en Y tendra mas velocidad que la mas pegada
.................... */ 
.................... 
.................... 
.................... // --------------------- Direccion de registros --------------------- //
.................... #BYTE       TRISA               = 0xF92
.................... #BYTE       TRISB               = 0xF93
.................... #BYTE       TRISC               = 0xF94
.................... #BIT        status_LED          = 0xF89.0   // LATA
.................... 
.................... #BYTE       INTCON              = 0xFF2
.................... #BIT        INT1IE              = 0xFF0.3   // INTCON3
.................... #BIT        INTEDG1             = 0xFF1.5   // INTCON2
.................... #BIT        RC1IE               = 0xF9D.5   // PIE1
.................... #BIT        IPEN                = 0xFD0.7   // RCON
.................... #BIT        RC1IP               = 0xF9F.5   // IPR1
.................... 
.................... // ----------------------- Variable Globales ------------------------ //
.................... struct motor_t  tires[2][2]   = 
.................... {
....................     {   // Llantas delanteras
....................         { 0xFBE, PIN_B3, PIN_B4 },  // Izquierda
....................         { 0xF67, PIN_B6, PIN_B7 }   // Derecha
....................     },
....................     {   // Llantas traseras
....................         { 0xF5E, PIN_A4, PIN_A5 },  // Izquierda
....................         { 0xF58, PIN_A6, PIN_A7 }   // Derecha
....................     }
.................... };
.................... 
.................... const struct    controller_t resting_state = { {0, 0}, {0, 0} };
.................... struct          controller_t xbox_controller;
.................... 
.................... struct          bth_conection_t PC = { FALSE, FALSE };
.................... 
.................... char            XJoystick[8], YJoystick[8], LeftTrigger[5], RightTrigger[5];
.................... 
.................... // -------------------------- Interrupciones ------------------------ //
.................... #INT_RDA
.................... void control_instructions()
*
002E4:  BTFSS  F9E.5
002E6:  BRA    02E4
002E8:  MOVFF  FAE,86
.................... {
....................     int data = getch();
....................     
....................     if(data == '*')     // Recibimos caracter de inicio de datos
002EC:  MOVF   x86,W
002EE:  SUBLW  2A
002F0:  BNZ   038C
....................     {           
....................         // Obtenemos cadenas de caracteres con los valores a recibir
....................         gets(XJoystick);
002F2:  CLRF   FEA
002F4:  MOVLW  3E
002F6:  MOVWF  FE9
002F8:  CLRF   FED
002FA:  BTFSS  F9E.5
002FC:  BRA    02FA
002FE:  MOVFF  FAE,FEC
00302:  MOVLW  0D
00304:  SUBWF  FEF,W
00306:  BNZ   02FA
00308:  CLRF   FEC
....................         gets(YJoystick);
0030A:  CLRF   FEA
0030C:  MOVLW  46
0030E:  MOVWF  FE9
00310:  CLRF   FED
00312:  BTFSS  F9E.5
00314:  BRA    0312
00316:  MOVFF  FAE,FEC
0031A:  MOVLW  0D
0031C:  SUBWF  FEF,W
0031E:  BNZ   0312
00320:  CLRF   FEC
.................... 
....................         gets(LeftTrigger);
00322:  CLRF   FEA
00324:  MOVLW  4E
00326:  MOVWF  FE9
00328:  CLRF   FED
0032A:  BTFSS  F9E.5
0032C:  BRA    032A
0032E:  MOVFF  FAE,FEC
00332:  MOVLW  0D
00334:  SUBWF  FEF,W
00336:  BNZ   032A
00338:  CLRF   FEC
....................         gets(RightTrigger);
0033A:  CLRF   FEA
0033C:  MOVLW  53
0033E:  MOVWF  FE9
00340:  CLRF   FED
00342:  BTFSS  F9E.5
00344:  BRA    0342
00346:  MOVFF  FAE,FEC
0034A:  MOVLW  0D
0034C:  SUBWF  FEF,W
0034E:  BNZ   0342
00350:  CLRF   FEC
.................... 
....................         // Realizamos la conversion y actualizamos los valores del control
....................         xbox_controller.Joystick[0] =  atol(XJoystick);
00352:  CLRF   x88
00354:  MOVLW  3E
00356:  MOVWF  x87
00358:  RCALL  0112
0035A:  MOVFF  02,38
0035E:  MOVFF  01,37
....................         xbox_controller.Joystick[1] =  atol(YJoystick);
00362:  CLRF   x88
00364:  MOVLW  46
00366:  MOVWF  x87
00368:  RCALL  0112
0036A:  MOVFF  02,3A
0036E:  MOVFF  01,39
....................         
....................         xbox_controller.Triggers[0] =  atol(LeftTrigger);
00372:  CLRF   x88
00374:  MOVLW  4E
00376:  MOVWF  x87
00378:  RCALL  0112
0037A:  MOVFF  01,3B
....................         xbox_controller.Triggers[1] =  atol(RightTrigger);
0037E:  CLRF   x88
00380:  MOVLW  53
00382:  MOVWF  x87
00384:  RCALL  0112
00386:  MOVFF  01,3C
.................... 
....................         // Actualizamos variables de conexion
....................         PC.updated_data = TRUE;
0038A:  BSF    3D.0
....................     }
.................... }
.................... 
.................... /* Inforamcion de variables
.................... * updated_data: Booleano para sealar que hubo una actualizacion de informacion y no ha sido aplicada.
....................     * updated_data = FALSE   : No hay nueva informacion
....................     * updated_data = TRUE    : Hay informacion pendiente de aplicar
.................... * isConnected: Booleno para saber el estatus de la conexion de bluetooth
.................... */
.................... 
0038C:  BCF    F9E.5
0038E:  GOTO   006C
.................... #INT_EXT1
.................... void bluetooth_connection()
.................... {
....................     // Cuando entre por primera vez sera en flanco de subida
....................     INTEDG1         ^= 1;       // Cambiamos el flanco de deteccion
00392:  MOVLW  00
00394:  BTFSC  FF1.5
00396:  MOVLW  01
00398:  XORLW  01
0039A:  BCF    FF1.5
0039C:  BTFSC  FE8.0
0039E:  BSF    FF1.5
....................     PC.IsConnected  ^= 1;       // Cambiamos el estatus de conexion
003A0:  MOVLW  00
003A2:  BTFSC  3D.1
003A4:  MOVLW  01
003A6:  XORLW  01
003A8:  BCF    3D.1
003AA:  BTFSC  FE8.0
003AC:  BSF    3D.1
.................... 
....................     status_LED = PC.IsConnected;    // Actualzamos LED indicador
003AE:  BCF    F89.0
003B0:  BTFSC  3D.1
003B2:  BSF    F89.0
003B4:  BCF    FF0.0
003B6:  GOTO   006C
.................... }
.................... 
.................... // ---------------------------- Funciones --------------------------- //
.................... void log_init()
.................... {
....................     // Configuracion de pines GPIO
....................     TRISA       = 0b00000000;
003BA:  CLRF   F92
....................     TRISB       = 0b00000010;
003BC:  MOVLW  02
003BE:  MOVWF  F93
....................     TRISC       = 0b11000000;
003C0:  MOVLW  C0
003C2:  MOVWF  F94
.................... 
....................     // Configuracion de Interrupciones
....................     IPEN = RC1IE = RC1IP =  TRUE;        // Establecemos la interrupcion de recepcion serial como prioridad
003C4:  BSF    F9F.5
003C6:  BSF    F9D.5
003C8:  BSF    FD0.7
....................     INT1IE = INTEDG1 = TRUE;            // Activamos INT_EXT1 en flanco de subida 
003CA:  BSF    FF1.5
003CC:  BSF    FF0.3
....................     INTCON = 0b11000000;
003CE:  MOVWF  FF2
003D0:  GOTO   10D8 (RETURN)
.................... }
.................... 
.................... // ------------------------ Codigo Principal ----------------------- //
.................... void main()
*
0103E:  CLRF   FF8
01040:  BCF    FD0.7
01042:  BSF    07.7
01044:  MOVLW  70
01046:  MOVWF  FD3
01048:  BCF    F9B.6
0104A:  BCF    F9B.7
0104C:  BSF    FB8.3
0104E:  MOVLW  A0
01050:  MOVWF  FAF
01052:  MOVLW  01
01054:  MOVWF  FB0
01056:  MOVLW  A6
01058:  MOVWF  FAC
0105A:  MOVLW  90
0105C:  MOVWF  FAB
0105E:  MOVLB  F
01060:  CLRF   x38
01062:  CLRF   x39
01064:  CLRF   x3A
01066:  CLRF   F77
01068:  CLRF   F78
0106A:  CLRF   F79
0106C:  BRA    1094
0106E:  DATA 02,00
01070:  DATA 19,00
01072:  DATA 00,18
01074:  DATA 00,1F
01076:  DATA BE,0F
01078:  DATA 0B,7C
0107A:  DATA 0C,7C
0107C:  DATA 67,0F
0107E:  DATA 0E,7C
01080:  DATA 0F,7C
01082:  DATA 5E,0F
01084:  DATA 04,7C
01086:  DATA 05,7C
01088:  DATA 58,0F
0108A:  DATA 06,7C
0108C:  DATA 07,7C
0108E:  DATA 01,00
01090:  DATA 3D,00
01092:  DATA 00,00
01094:  MOVLW  00
01096:  MOVWF  FF8
01098:  MOVLW  10
0109A:  MOVWF  FF7
0109C:  MOVLW  6E
0109E:  MOVWF  FF6
010A0:  TBLRD*+
010A2:  MOVF   FF5,W
010A4:  MOVWF  00
010A6:  XORLW  00
010A8:  BZ    10D0
010AA:  TBLRD*+
010AC:  MOVF   FF5,W
010AE:  MOVWF  01
010B0:  BTFSC  FE8.7
010B2:  BRA    10BE
010B4:  ANDLW  3F
010B6:  MOVWF  FEA
010B8:  TBLRD*+
010BA:  MOVFF  FF5,FE9
010BE:  BTFSC  01.6
010C0:  TBLRD*+
010C2:  BTFSS  01.6
010C4:  TBLRD*+
010C6:  MOVFF  FF5,FEE
010CA:  DCFSNZ 00,F
010CC:  BRA    10A0
010CE:  BRA    10C2
010D0:  CLRF   FF8
.................... {
....................     log_init();
010D2:  MOVLB  0
010D4:  GOTO   03BA
....................     motors_init(tires);
010D8:  CLRF   5A
010DA:  MOVLW  1F
010DC:  MOVWF  59
010DE:  GOTO   03F2
.................... 
....................     Connection_animation:
....................     // Esperamos conexion bluetooth con una animacion del LED indicador
....................     for(int time = 0; !PC.IsConnected; time++, delay_ms(1))
010E2:  CLRF   58
010E4:  BTFSC  3D.1
010E6:  BRA    1110
....................     {
....................         if(time == 200)
010E8:  MOVF   58,W
010EA:  SUBLW  C8
010EC:  BNZ   10FE
....................         {
....................             status_LED ^= 1;
010EE:  MOVLW  00
010F0:  BTFSC  F89.0
010F2:  MOVLW  01
010F4:  XORLW  01
010F6:  BCF    F89.0
010F8:  BTFSC  FE8.0
010FA:  BSF    F89.0
....................             time = 0;
010FC:  CLRF   58
....................         }
010FE:  MOVF   58,W
01100:  INCF   58,F
01102:  MOVLW  01
01104:  MOVWF  59
01106:  MOVLB  0
01108:  GOTO   0472
0110C:  MOVLB  0
0110E:  BRA    10E4
....................     }
.................... 
....................     while (TRUE)
....................     {   
....................         //*/
....................         if(!PC.IsConnected)                 // Si no hay conexion ponemos modo reposo (Detenido)
01110:  BTFSC  3D.1
01112:  BRA    1132
....................         {
....................             // Ver si ponerlo en freno de corto (Pero antes detectar que ya hubo una primera conexion)
....................             drive_tires(&resting_state, tires);
01114:  MOVLW  00
01116:  MOVWF  03
01118:  MOVLW  BA
0111A:  MOVWF  59
0111C:  MOVFF  03,5A
01120:  MOVFF  03,5C
01124:  MOVWF  5B
01126:  CLRF   5E
01128:  MOVLW  1F
0112A:  MOVWF  5D
0112C:  MOVLB  0
0112E:  RCALL  0C4A
....................             goto Connection_animation;
01130:  BRA    10E2
....................         }
.................... 
....................         // Si hay conexion
....................         if(PC.updated_data)                // Si se actualizo la posicion
01132:  BTFSS  3D.0
01134:  BRA    1148
....................         {
....................             // Enviamos instrucciones a motores
....................             drive_tires(&xbox_controller, tires);
01136:  CLRF   5C
01138:  MOVLW  37
0113A:  MOVWF  5B
0113C:  CLRF   5E
0113E:  MOVLW  1F
01140:  MOVWF  5D
01142:  MOVLB  0
01144:  RCALL  0C4A
....................             PC.updated_data = FALSE;
01146:  BCF    3D.0
....................         }
01148:  BRA    1110
....................         //*/
.................... 
....................         /*/ Revision de  almacenamiento de variables
....................         printf("Joystick X = %ld | Y = %ld\r\n", xbox_controller.Joystick[0], xbox_controller.Joystick[1]);
....................         printf("Triggers 1 =  %u | 2 = %u\r\n", xbox_controller.Triggers[0],  xbox_controller.Triggers[1]);
....................         delay_ms(100);
....................         //*/
....................     }
.................... }
.................... 
0114A:  SLEEP 
.................... /*
.................... El codigo esta compuesto de las siguientes partes
.................... 
....................     * Interrupcion de recepcion de datos en puerto serial: Recibe los datos actualizados del control de XBOX desde el programa de computadora en C#
.................... 
....................     * Interrupcion de timer 0: Desbore de timer de 100 ms que envia el caracter para solicitar una actualizacion de control y confirmar la conexion bluetooth
.................... 
....................     * Funcion principal: Inicializa los registros, y mueve las ruedas cuando hay nueva informacion
.................... */

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY FCMEN IESO
   Word  2: 3C1E   PUT BROWNOUT BORV19 NOWDT WDT32768
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2B5 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
