CCS PCH C Compiler, Version 5.112, 29001               16-abr.-24 12:21

               Filename:   C:\Users\diego\Desktop\Terreneitor\Firmware\Microcontoller-Code\main.lst

               ROM used:   4486 bytes (7%)
                           Largest free fragment is 61046
               RAM used:   64 (2%) at main() level
                           149 (4%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   106E
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF0.3
00056:  GOTO   0060
0005A:  BTFSC  FF0.0
0005C:  GOTO   038C
00060:  BTFSS  F9D.5
00062:  GOTO   006C
00066:  BTFSC  F9E.5
00068:  GOTO   02DE
0006C:  MOVFF  0E,00
00070:  MOVFF  0F,01
00074:  MOVFF  10,02
00078:  MOVFF  11,03
0007C:  MOVFF  0C,FE9
00080:  MOVFF  07,FEA
00084:  BSF    07.7
00086:  MOVFF  08,FE1
0008A:  MOVFF  09,FE2
0008E:  MOVFF  0A,FD9
00092:  MOVFF  0B,FDA
00096:  MOVFF  12,FF3
0009A:  MOVFF  13,FF4
0009E:  MOVFF  14,FFA
000A2:  MOVFF  15,FF5
000A6:  MOVFF  16,FF6
000AA:  MOVFF  17,FF7
000AE:  MOVF   04,W
000B0:  MOVFF  06,FE0
000B4:  MOVFF  05,FD8
000B8:  RETFIE 0
.................... // --------------- Preprocesadores de microcontrolador -------------- //
.................... #include    <18F26K22.h>                                                // Libreria del Microcontrolador
.................... //////////// Standard Header file for the PIC18F26K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F26K22
000BA:  MOVF   x90,W
000BC:  XORWF  x92,W
000BE:  ANDLW  80
000C0:  MOVWF  x94
000C2:  BTFSS  x90.7
000C4:  BRA    00D0
000C6:  COMF   x8F,F
000C8:  COMF   x90,F
000CA:  INCF   x8F,F
000CC:  BTFSC  FD8.2
000CE:  INCF   x90,F
000D0:  BTFSS  x92.7
000D2:  BRA    00DE
000D4:  COMF   x91,F
000D6:  COMF   x92,F
000D8:  INCF   x91,F
000DA:  BTFSC  FD8.2
000DC:  INCF   x92,F
000DE:  MOVF   x8F,W
000E0:  MULWF  x91
000E2:  MOVFF  FF3,01
000E6:  MOVFF  FF4,00
000EA:  MULWF  x92
000EC:  MOVF   FF3,W
000EE:  ADDWF  00,F
000F0:  MOVF   x90,W
000F2:  MULWF  x91
000F4:  MOVF   FF3,W
000F6:  ADDWFC 00,W
000F8:  MOVWF  02
000FA:  BTFSS  x94.7
000FC:  BRA    0108
000FE:  COMF   01,F
00100:  COMF   02,F
00102:  INCF   01,F
00104:  BTFSC  FD8.2
00106:  INCF   02,F
00108:  GOTO   01E2 (RETURN)
*
003D2:  MOVF   45,W
003D4:  MULWF  47
003D6:  MOVFF  FF3,01
003DA:  MOVFF  FF4,00
003DE:  MULWF  48
003E0:  MOVF   FF3,W
003E2:  ADDWF  00,F
003E4:  MOVF   46,W
003E6:  MULWF  47
003E8:  MOVF   FF3,W
003EA:  ADDWFC 00,W
003EC:  MOVWF  02
003EE:  RETURN 0
*
0049A:  MOVF   5A,W
0049C:  ANDLW  07
0049E:  MOVWF  00
004A0:  RRCF   5A,W
004A2:  MOVWF  01
004A4:  RRCF   01,F
004A6:  RRCF   01,F
004A8:  MOVLW  1F
004AA:  ANDWF  01,F
004AC:  MOVF   01,W
004AE:  ADDWF  5C,W
004B0:  MOVWF  FE9
004B2:  MOVLW  00
004B4:  ADDWFC 5D,W
004B6:  MOVWF  FEA
004B8:  CLRF   01
004BA:  INCF   01,F
004BC:  INCF   00,F
004BE:  BRA    04C2
004C0:  RLCF   01,F
004C2:  DECFSZ 00,F
004C4:  BRA    04C0
004C6:  MOVF   5B,F
004C8:  BZ    04D0
004CA:  MOVF   01,W
004CC:  IORWF  FEF,F
004CE:  BRA    04D6
004D0:  COMF   01,F
004D2:  MOVF   01,W
004D4:  ANDWF  FEF,F
004D6:  RETURN 0
*
0054A:  MOVLW  8E
0054C:  MOVWF  00
0054E:  MOVFF  52,01
00552:  MOVFF  51,02
00556:  CLRF   03
00558:  BTFSS  52.7
0055A:  BRA    0566
0055C:  COMF   01,F
0055E:  COMF   02,F
00560:  INCF   02,F
00562:  BNZ   0566
00564:  INCF   01,F
00566:  MOVF   01,F
00568:  BNZ   057C
0056A:  MOVFF  02,01
0056E:  CLRF   02
00570:  MOVLW  08
00572:  SUBWF  00,F
00574:  MOVF   01,F
00576:  BNZ   057C
00578:  CLRF   00
0057A:  BRA    0590
0057C:  BCF    FD8.0
0057E:  BTFSC  01.7
00580:  BRA    058A
00582:  RLCF   02,F
00584:  RLCF   01,F
00586:  DECF   00,F
00588:  BRA    057C
0058A:  BTFSC  52.7
0058C:  BRA    0590
0058E:  BCF    01.7
00590:  RETURN 0
00592:  MOVF   58,W
00594:  BTFSC  FD8.2
00596:  BRA    067A
00598:  MOVWF  00
0059A:  MOVF   5C,W
0059C:  BTFSC  FD8.2
0059E:  BRA    067A
005A0:  ADDWF  00,F
005A2:  BNC   05AC
005A4:  MOVLW  81
005A6:  ADDWF  00,F
005A8:  BC    067A
005AA:  BRA    05B4
005AC:  MOVLW  7F
005AE:  SUBWF  00,F
005B0:  BNC   067A
005B2:  BZ    067A
005B4:  MOVFF  59,60
005B8:  MOVF   5D,W
005BA:  XORWF  x60,F
005BC:  BSF    59.7
005BE:  BSF    5D.7
005C0:  MOVF   5B,W
005C2:  MULWF  5F
005C4:  MOVFF  FF4,62
005C8:  MOVF   5A,W
005CA:  MULWF  5E
005CC:  MOVFF  FF4,03
005D0:  MOVFF  FF3,61
005D4:  MULWF  5F
005D6:  MOVF   FF3,W
005D8:  ADDWF  x62,F
005DA:  MOVF   FF4,W
005DC:  ADDWFC x61,F
005DE:  MOVLW  00
005E0:  ADDWFC 03,F
005E2:  MOVF   5B,W
005E4:  MULWF  5E
005E6:  MOVF   FF3,W
005E8:  ADDWF  x62,F
005EA:  MOVF   FF4,W
005EC:  ADDWFC x61,F
005EE:  MOVLW  00
005F0:  CLRF   02
005F2:  ADDWFC 03,F
005F4:  ADDWFC 02,F
005F6:  MOVF   59,W
005F8:  MULWF  5F
005FA:  MOVF   FF3,W
005FC:  ADDWF  x61,F
005FE:  MOVF   FF4,W
00600:  ADDWFC 03,F
00602:  MOVLW  00
00604:  ADDWFC 02,F
00606:  MOVF   59,W
00608:  MULWF  5E
0060A:  MOVF   FF3,W
0060C:  ADDWF  03,F
0060E:  MOVF   FF4,W
00610:  ADDWFC 02,F
00612:  MOVLW  00
00614:  CLRF   01
00616:  ADDWFC 01,F
00618:  MOVF   5B,W
0061A:  MULWF  5D
0061C:  MOVF   FF3,W
0061E:  ADDWF  x61,F
00620:  MOVF   FF4,W
00622:  ADDWFC 03,F
00624:  MOVLW  00
00626:  ADDWFC 02,F
00628:  ADDWFC 01,F
0062A:  MOVF   5A,W
0062C:  MULWF  5D
0062E:  MOVF   FF3,W
00630:  ADDWF  03,F
00632:  MOVF   FF4,W
00634:  ADDWFC 02,F
00636:  MOVLW  00
00638:  ADDWFC 01,F
0063A:  MOVF   59,W
0063C:  MULWF  5D
0063E:  MOVF   FF3,W
00640:  ADDWF  02,F
00642:  MOVF   FF4,W
00644:  ADDWFC 01,F
00646:  INCF   00,F
00648:  BTFSC  01.7
0064A:  BRA    0656
0064C:  RLCF   x61,F
0064E:  RLCF   03,F
00650:  RLCF   02,F
00652:  RLCF   01,F
00654:  DECF   00,F
00656:  MOVLW  00
00658:  BTFSS  x61.7
0065A:  BRA    0670
0065C:  INCF   03,F
0065E:  ADDWFC 02,F
00660:  ADDWFC 01,F
00662:  MOVF   01,W
00664:  BNZ   0670
00666:  MOVF   02,W
00668:  BNZ   0670
0066A:  MOVF   03,W
0066C:  BNZ   0670
0066E:  INCF   00,F
00670:  BTFSC  x60.7
00672:  BSF    01.7
00674:  BTFSS  x60.7
00676:  BCF    01.7
00678:  BRA    0682
0067A:  CLRF   00
0067C:  CLRF   01
0067E:  CLRF   02
00680:  CLRF   03
00682:  RETURN 0
00684:  MOVF   5C,W
00686:  BTFSC  FD8.2
00688:  BRA    07D4
0068A:  MOVWF  x68
0068C:  MOVF   x60,W
0068E:  BTFSC  FD8.2
00690:  BRA    07D4
00692:  SUBWF  x68,F
00694:  BNC   06A0
00696:  MOVLW  7F
00698:  ADDWF  x68,F
0069A:  BTFSC  FD8.0
0069C:  BRA    07D4
0069E:  BRA    06AC
006A0:  MOVLW  81
006A2:  SUBWF  x68,F
006A4:  BTFSS  FD8.0
006A6:  BRA    07D4
006A8:  BTFSC  FD8.2
006AA:  BRA    07D4
006AC:  MOVFF  68,00
006B0:  CLRF   01
006B2:  CLRF   02
006B4:  CLRF   03
006B6:  CLRF   x67
006B8:  MOVFF  5D,66
006BC:  BSF    x66.7
006BE:  MOVFF  5E,65
006C2:  MOVFF  5F,64
006C6:  MOVLW  19
006C8:  MOVWF  x68
006CA:  MOVF   x63,W
006CC:  SUBWF  x64,F
006CE:  BC    06EA
006D0:  MOVLW  01
006D2:  SUBWF  x65,F
006D4:  BC    06EA
006D6:  SUBWF  x66,F
006D8:  BC    06EA
006DA:  SUBWF  x67,F
006DC:  BC    06EA
006DE:  INCF   x67,F
006E0:  INCF   x66,F
006E2:  INCF   x65,F
006E4:  MOVF   x63,W
006E6:  ADDWF  x64,F
006E8:  BRA    073A
006EA:  MOVF   x62,W
006EC:  SUBWF  x65,F
006EE:  BC    0714
006F0:  MOVLW  01
006F2:  SUBWF  x66,F
006F4:  BC    0714
006F6:  SUBWF  x67,F
006F8:  BC    0714
006FA:  INCF   x67,F
006FC:  INCF   x66,F
006FE:  MOVF   x62,W
00700:  ADDWF  x65,F
00702:  MOVF   x63,W
00704:  ADDWF  x64,F
00706:  BNC   073A
00708:  INCF   x65,F
0070A:  BNZ   073A
0070C:  INCF   x66,F
0070E:  BNZ   073A
00710:  INCF   x67,F
00712:  BRA    073A
00714:  MOVF   x61,W
00716:  IORLW  80
00718:  SUBWF  x66,F
0071A:  BC    0738
0071C:  MOVLW  01
0071E:  SUBWF  x67,F
00720:  BC    0738
00722:  INCF   x67,F
00724:  MOVF   x61,W
00726:  IORLW  80
00728:  ADDWF  x66,F
0072A:  MOVF   x62,W
0072C:  ADDWF  x65,F
0072E:  BNC   0702
00730:  INCF   x66,F
00732:  BNZ   0702
00734:  INCF   x67,F
00736:  BRA    0702
00738:  BSF    03.0
0073A:  DECFSZ x68,F
0073C:  BRA    0740
0073E:  BRA    0756
00740:  BCF    FD8.0
00742:  RLCF   x64,F
00744:  RLCF   x65,F
00746:  RLCF   x66,F
00748:  RLCF   x67,F
0074A:  BCF    FD8.0
0074C:  RLCF   03,F
0074E:  RLCF   02,F
00750:  RLCF   01,F
00752:  RLCF   x69,F
00754:  BRA    06CA
00756:  BTFSS  x69.0
00758:  BRA    0766
0075A:  BCF    FD8.0
0075C:  RRCF   01,F
0075E:  RRCF   02,F
00760:  RRCF   03,F
00762:  RRCF   x69,F
00764:  BRA    076A
00766:  DECF   00,F
00768:  BZ    07D4
0076A:  BTFSC  x69.7
0076C:  BRA    07AA
0076E:  BCF    FD8.0
00770:  RLCF   x64,F
00772:  RLCF   x65,F
00774:  RLCF   x66,F
00776:  RLCF   x67,F
00778:  MOVF   x63,W
0077A:  SUBWF  x64,F
0077C:  BC    078C
0077E:  MOVLW  01
00780:  SUBWF  x65,F
00782:  BC    078C
00784:  SUBWF  x66,F
00786:  BC    078C
00788:  SUBWF  x67,F
0078A:  BNC   07C0
0078C:  MOVF   x62,W
0078E:  SUBWF  x65,F
00790:  BC    079C
00792:  MOVLW  01
00794:  SUBWF  x66,F
00796:  BC    079C
00798:  SUBWF  x67,F
0079A:  BNC   07C0
0079C:  MOVF   x61,W
0079E:  IORLW  80
007A0:  SUBWF  x66,F
007A2:  BC    07AA
007A4:  MOVLW  01
007A6:  SUBWF  x67,F
007A8:  BNC   07C0
007AA:  INCF   03,F
007AC:  BNZ   07C0
007AE:  INCF   02,F
007B0:  BNZ   07C0
007B2:  INCF   01,F
007B4:  BNZ   07C0
007B6:  INCF   00,F
007B8:  BZ    07D4
007BA:  RRCF   01,F
007BC:  RRCF   02,F
007BE:  RRCF   03,F
007C0:  MOVFF  5D,68
007C4:  MOVF   x61,W
007C6:  XORWF  x68,F
007C8:  BTFSS  x68.7
007CA:  BRA    07D0
007CC:  BSF    01.7
007CE:  BRA    07DC
007D0:  BCF    01.7
007D2:  BRA    07DC
007D4:  CLRF   00
007D6:  CLRF   01
007D8:  CLRF   02
007DA:  CLRF   03
007DC:  RETURN 0
007DE:  MOVLW  80
007E0:  BTFSC  FD8.1
007E2:  XORWF  x61,F
007E4:  CLRF   x66
007E6:  CLRF   x67
007E8:  MOVFF  5D,65
007EC:  MOVF   x61,W
007EE:  XORWF  x65,F
007F0:  MOVF   5C,W
007F2:  BTFSC  FD8.2
007F4:  BRA    09AE
007F6:  MOVWF  x64
007F8:  MOVWF  00
007FA:  MOVF   x60,W
007FC:  BTFSC  FD8.2
007FE:  BRA    09C0
00800:  SUBWF  x64,F
00802:  BTFSC  FD8.2
00804:  BRA    0908
00806:  BNC   0882
00808:  MOVFF  61,6A
0080C:  BSF    x6A.7
0080E:  MOVFF  62,69
00812:  MOVFF  63,68
00816:  CLRF   x67
00818:  BCF    FD8.0
0081A:  RRCF   x6A,F
0081C:  RRCF   x69,F
0081E:  RRCF   x68,F
00820:  RRCF   x67,F
00822:  DECFSZ x64,F
00824:  BRA    0816
00826:  BTFSS  x65.7
00828:  BRA    0830
0082A:  BSF    x66.0
0082C:  BRA    09E8
0082E:  BCF    x66.0
00830:  BCF    x64.0
00832:  BSF    x66.4
00834:  CLRF   FEA
00836:  MOVLW  5F
00838:  MOVWF  FE9
0083A:  BRA    0A0E
0083C:  BCF    x66.4
0083E:  BTFSC  x65.7
00840:  BRA    0856
00842:  BTFSS  x64.0
00844:  BRA    086C
00846:  RRCF   x6A,F
00848:  RRCF   x69,F
0084A:  RRCF   x68,F
0084C:  RRCF   x67,F
0084E:  INCF   00,F
00850:  BTFSC  FD8.2
00852:  BRA    09DE
00854:  BRA    086C
00856:  BTFSC  x6A.7
00858:  BRA    0872
0085A:  BCF    FD8.0
0085C:  RLCF   x67,F
0085E:  RLCF   x68,F
00860:  RLCF   x69,F
00862:  RLCF   x6A,F
00864:  DECF   00,F
00866:  BTFSC  FD8.2
00868:  BRA    09DE
0086A:  BRA    0856
0086C:  BSF    x66.6
0086E:  BRA    0946
00870:  BCF    x66.6
00872:  MOVFF  5D,65
00876:  BTFSS  5D.7
00878:  BRA    087E
0087A:  BSF    x6A.7
0087C:  BRA    09D0
0087E:  BCF    x6A.7
00880:  BRA    09D0
00882:  MOVFF  60,64
00886:  MOVFF  60,00
0088A:  MOVF   5C,W
0088C:  SUBWF  x64,F
0088E:  MOVFF  5D,6A
00892:  BSF    x6A.7
00894:  MOVFF  5E,69
00898:  MOVFF  5F,68
0089C:  CLRF   x67
0089E:  BCF    FD8.0
008A0:  RRCF   x6A,F
008A2:  RRCF   x69,F
008A4:  RRCF   x68,F
008A6:  RRCF   x67,F
008A8:  DECFSZ x64,F
008AA:  BRA    089C
008AC:  BTFSS  x65.7
008AE:  BRA    08B6
008B0:  BSF    x66.1
008B2:  BRA    09E8
008B4:  BCF    x66.1
008B6:  BCF    x64.0
008B8:  BSF    x66.5
008BA:  CLRF   FEA
008BC:  MOVLW  63
008BE:  MOVWF  FE9
008C0:  BRA    0A0E
008C2:  BCF    x66.5
008C4:  BTFSC  x65.7
008C6:  BRA    08DC
008C8:  BTFSS  x64.0
008CA:  BRA    08F2
008CC:  RRCF   x6A,F
008CE:  RRCF   x69,F
008D0:  RRCF   x68,F
008D2:  RRCF   x67,F
008D4:  INCF   00,F
008D6:  BTFSC  FD8.2
008D8:  BRA    09DE
008DA:  BRA    08F2
008DC:  BTFSC  x6A.7
008DE:  BRA    08F8
008E0:  BCF    FD8.0
008E2:  RLCF   x67,F
008E4:  RLCF   x68,F
008E6:  RLCF   x69,F
008E8:  RLCF   x6A,F
008EA:  DECF   00,F
008EC:  BTFSC  FD8.2
008EE:  BRA    09DE
008F0:  BRA    08DC
008F2:  BSF    x66.7
008F4:  BRA    0946
008F6:  BCF    x66.7
008F8:  MOVFF  61,65
008FC:  BTFSS  x61.7
008FE:  BRA    0904
00900:  BSF    x6A.7
00902:  BRA    09D0
00904:  BCF    x6A.7
00906:  BRA    09D0
00908:  MOVFF  61,6A
0090C:  BSF    x6A.7
0090E:  MOVFF  62,69
00912:  MOVFF  63,68
00916:  BTFSS  x65.7
00918:  BRA    0922
0091A:  BCF    x6A.7
0091C:  BSF    x66.2
0091E:  BRA    09E8
00920:  BCF    x66.2
00922:  CLRF   x67
00924:  BCF    x64.0
00926:  CLRF   FEA
00928:  MOVLW  5F
0092A:  MOVWF  FE9
0092C:  BRA    0A0E
0092E:  BTFSC  x65.7
00930:  BRA    096A
00932:  MOVFF  5D,65
00936:  BTFSS  x64.0
00938:  BRA    0946
0093A:  RRCF   x6A,F
0093C:  RRCF   x69,F
0093E:  RRCF   x68,F
00940:  RRCF   x67,F
00942:  INCF   00,F
00944:  BZ    09DE
00946:  BTFSS  x67.7
00948:  BRA    0960
0094A:  INCF   x68,F
0094C:  BNZ   0960
0094E:  INCF   x69,F
00950:  BNZ   0960
00952:  INCF   x6A,F
00954:  BNZ   0960
00956:  RRCF   x6A,F
00958:  RRCF   x69,F
0095A:  RRCF   x68,F
0095C:  INCF   00,F
0095E:  BZ    09DE
00960:  BTFSC  x66.6
00962:  BRA    0870
00964:  BTFSC  x66.7
00966:  BRA    08F6
00968:  BRA    09A2
0096A:  MOVLW  80
0096C:  XORWF  x6A,F
0096E:  BTFSS  x6A.7
00970:  BRA    097A
00972:  BRA    09E8
00974:  MOVFF  61,65
00978:  BRA    098E
0097A:  MOVFF  5D,65
0097E:  MOVF   x6A,F
00980:  BNZ   098E
00982:  MOVF   x69,F
00984:  BNZ   098E
00986:  MOVF   x68,F
00988:  BNZ   098E
0098A:  CLRF   00
0098C:  BRA    09D0
0098E:  BTFSC  x6A.7
00990:  BRA    09A2
00992:  BCF    FD8.0
00994:  RLCF   x67,F
00996:  RLCF   x68,F
00998:  RLCF   x69,F
0099A:  RLCF   x6A,F
0099C:  DECFSZ 00,F
0099E:  BRA    098E
009A0:  BRA    09DE
009A2:  BTFSS  x65.7
009A4:  BRA    09AA
009A6:  BSF    x6A.7
009A8:  BRA    09D0
009AA:  BCF    x6A.7
009AC:  BRA    09D0
009AE:  MOVFF  60,00
009B2:  MOVFF  61,6A
009B6:  MOVFF  62,69
009BA:  MOVFF  63,68
009BE:  BRA    09D0
009C0:  MOVFF  5C,00
009C4:  MOVFF  5D,6A
009C8:  MOVFF  5E,69
009CC:  MOVFF  5F,68
009D0:  MOVFF  6A,01
009D4:  MOVFF  69,02
009D8:  MOVFF  68,03
009DC:  BRA    0A46
009DE:  CLRF   00
009E0:  CLRF   01
009E2:  CLRF   02
009E4:  CLRF   03
009E6:  BRA    0A46
009E8:  CLRF   x67
009EA:  COMF   x68,F
009EC:  COMF   x69,F
009EE:  COMF   x6A,F
009F0:  COMF   x67,F
009F2:  INCF   x67,F
009F4:  BNZ   0A00
009F6:  INCF   x68,F
009F8:  BNZ   0A00
009FA:  INCF   x69,F
009FC:  BNZ   0A00
009FE:  INCF   x6A,F
00A00:  BTFSC  x66.0
00A02:  BRA    082E
00A04:  BTFSC  x66.1
00A06:  BRA    08B4
00A08:  BTFSC  x66.2
00A0A:  BRA    0920
00A0C:  BRA    0974
00A0E:  MOVF   FEF,W
00A10:  ADDWF  x68,F
00A12:  BNC   0A1E
00A14:  INCF   x69,F
00A16:  BNZ   0A1E
00A18:  INCF   x6A,F
00A1A:  BTFSC  FD8.2
00A1C:  BSF    x64.0
00A1E:  MOVF   FED,F
00A20:  MOVF   FEF,W
00A22:  ADDWF  x69,F
00A24:  BNC   0A2C
00A26:  INCF   x6A,F
00A28:  BTFSC  FD8.2
00A2A:  BSF    x64.0
00A2C:  MOVF   FED,F
00A2E:  MOVF   FEF,W
00A30:  BTFSC  FEF.7
00A32:  BRA    0A36
00A34:  XORLW  80
00A36:  ADDWF  x6A,F
00A38:  BTFSC  FD8.0
00A3A:  BSF    x64.0
00A3C:  BTFSC  x66.4
00A3E:  BRA    083C
00A40:  BTFSC  x66.5
00A42:  BRA    08C2
00A44:  BRA    092E
00A46:  RETURN 0
00A48:  MOVFF  59,60
00A4C:  MOVF   5D,W
00A4E:  XORWF  x60,F
00A50:  BTFSS  x60.7
00A52:  BRA    0A5E
00A54:  BCF    FD8.2
00A56:  BCF    FD8.0
00A58:  BTFSC  59.7
00A5A:  BSF    FD8.0
00A5C:  BRA    0ABC
00A5E:  MOVFF  59,60
00A62:  MOVFF  5C,61
00A66:  MOVF   58,W
00A68:  SUBWF  x61,F
00A6A:  BZ    0A78
00A6C:  BTFSS  x60.7
00A6E:  BRA    0ABC
00A70:  MOVF   FD8,W
00A72:  XORLW  01
00A74:  MOVWF  FD8
00A76:  BRA    0ABC
00A78:  MOVFF  5D,61
00A7C:  MOVF   59,W
00A7E:  SUBWF  x61,F
00A80:  BZ    0A8E
00A82:  BTFSS  x60.7
00A84:  BRA    0ABC
00A86:  MOVF   FD8,W
00A88:  XORLW  01
00A8A:  MOVWF  FD8
00A8C:  BRA    0ABC
00A8E:  MOVFF  5E,61
00A92:  MOVF   5A,W
00A94:  SUBWF  x61,F
00A96:  BZ    0AA4
00A98:  BTFSS  x60.7
00A9A:  BRA    0ABC
00A9C:  MOVF   FD8,W
00A9E:  XORLW  01
00AA0:  MOVWF  FD8
00AA2:  BRA    0ABC
00AA4:  MOVFF  5F,61
00AA8:  MOVF   5B,W
00AAA:  SUBWF  x61,F
00AAC:  BZ    0ABA
00AAE:  BTFSS  x60.7
00AB0:  BRA    0ABC
00AB2:  MOVF   FD8,W
00AB4:  XORLW  01
00AB6:  MOVWF  FD8
00AB8:  BRA    0ABC
00ABA:  BCF    FD8.0
00ABC:  GOTO   0B14 (RETURN)
00AC0:  MOVLW  8E
00AC2:  MOVWF  00
00AC4:  MOVF   58,W
00AC6:  SUBWF  00,F
00AC8:  MOVFF  59,02
00ACC:  MOVFF  5A,01
00AD0:  BSF    02.7
00AD2:  MOVF   00,F
00AD4:  BZ    0AE8
00AD6:  BCF    FD8.0
00AD8:  MOVF   02,F
00ADA:  BNZ   0AE0
00ADC:  MOVF   01,F
00ADE:  BZ    0AE8
00AE0:  RRCF   02,F
00AE2:  RRCF   01,F
00AE4:  DECFSZ 00,F
00AE6:  BRA    0AD6
00AE8:  BTFSS  59.7
00AEA:  BRA    0AF6
00AEC:  COMF   01,F
00AEE:  COMF   02,F
00AF0:  INCF   01,F
00AF2:  BTFSC  FD8.2
00AF4:  INCF   02,F
00AF6:  GOTO   0C3E (RETURN)
.................... 
.................... #list
.................... 
.................... #fuses      INTRC, NOWDT, NOPROTECT, NOLVP, CCP2C1, CCP3B5              // Fusibles (Multiplexado de P2B en C0)
.................... #use        delay(internal = 16MHz)                                     // Configuracion de frecuencia y delay
*
00470:  CLRF   FEA
00472:  MOVLW  3F
00474:  MOVWF  FE9
00476:  MOVF   FEF,W
00478:  BZ    0496
0047A:  MOVLW  05
0047C:  MOVWF  01
0047E:  CLRF   00
00480:  DECFSZ 00,F
00482:  BRA    0480
00484:  DECFSZ 01,F
00486:  BRA    047E
00488:  MOVLW  2E
0048A:  MOVWF  00
0048C:  DECFSZ 00,F
0048E:  BRA    048C
00490:  BRA    0492
00492:  DECFSZ FEF,F
00494:  BRA    047A
00496:  GOTO   113C (RETURN)
.................... #use        rs232(rcv = pin_c7, xmit = pin_c6, baud = 9600, bits = 8, parity = n) 
.................... 
.................... #include    <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
0010C:  CLRF   x8D
....................    sign = 0;
0010E:  CLRF   x8B
....................    base = 10;
00110:  MOVLW  0A
00112:  MOVWF  x8C
....................    result = 0;
00114:  CLRF   x8A
00116:  CLRF   x89
.................... 
....................    if (!s)
00118:  MOVF   x87,W
0011A:  IORWF  x88,W
0011C:  BNZ   0126
....................       return 0;
0011E:  MOVLW  00
00120:  MOVWF  01
00122:  MOVWF  02
00124:  BRA    02DC
....................    c = s[index++];
00126:  MOVF   x8D,W
00128:  INCF   x8D,F
0012A:  ADDWF  x87,W
0012C:  MOVWF  FE9
0012E:  MOVLW  00
00130:  ADDWFC x88,W
00132:  MOVWF  FEA
00134:  MOVFF  FEF,8E
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
00138:  MOVF   x8E,W
0013A:  SUBLW  2D
0013C:  BNZ   0156
....................    {
....................       sign = 1;         // Set the sign to negative
0013E:  MOVLW  01
00140:  MOVWF  x8B
....................       c = s[index++];
00142:  MOVF   x8D,W
00144:  INCF   x8D,F
00146:  ADDWF  x87,W
00148:  MOVWF  FE9
0014A:  MOVLW  00
0014C:  ADDWFC x88,W
0014E:  MOVWF  FEA
00150:  MOVFF  FEF,8E
....................    }
00154:  BRA    016E
....................    else if (c == '+')
00156:  MOVF   x8E,W
00158:  SUBLW  2B
0015A:  BNZ   016E
....................    {
....................       c = s[index++];
0015C:  MOVF   x8D,W
0015E:  INCF   x8D,F
00160:  ADDWF  x87,W
00162:  MOVWF  FE9
00164:  MOVLW  00
00166:  ADDWFC x88,W
00168:  MOVWF  FEA
0016A:  MOVFF  FEF,8E
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
0016E:  MOVF   x8E,W
00170:  SUBLW  2F
00172:  BTFSC  FD8.0
00174:  BRA    02C0
00176:  MOVF   x8E,W
00178:  SUBLW  39
0017A:  BTFSS  FD8.0
0017C:  BRA    02C0
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
0017E:  MOVF   x8E,W
00180:  SUBLW  30
00182:  BNZ   01C0
00184:  MOVF   x8D,W
00186:  ADDWF  x87,W
00188:  MOVWF  FE9
0018A:  MOVLW  00
0018C:  ADDWFC x88,W
0018E:  MOVWF  FEA
00190:  MOVF   FEF,W
00192:  SUBLW  78
00194:  BZ    01A8
00196:  MOVF   x8D,W
00198:  ADDWF  x87,W
0019A:  MOVWF  FE9
0019C:  MOVLW  00
0019E:  ADDWFC x88,W
001A0:  MOVWF  FEA
001A2:  MOVF   FEF,W
001A4:  SUBLW  58
001A6:  BNZ   01C0
....................       {
....................          base = 16;
001A8:  MOVLW  10
001AA:  MOVWF  x8C
....................          index++;
001AC:  INCF   x8D,F
....................          c = s[index++];
001AE:  MOVF   x8D,W
001B0:  INCF   x8D,F
001B2:  ADDWF  x87,W
001B4:  MOVWF  FE9
001B6:  MOVLW  00
001B8:  ADDWFC x88,W
001BA:  MOVWF  FEA
001BC:  MOVFF  FEF,8E
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
001C0:  MOVF   x8C,W
001C2:  SUBLW  0A
001C4:  BNZ   0206
....................       {
....................          while (c >= '0' && c <= '9')
001C6:  MOVF   x8E,W
001C8:  SUBLW  2F
001CA:  BC    0204
001CC:  MOVF   x8E,W
001CE:  SUBLW  39
001D0:  BNC   0204
....................          {
....................             result = 10*result + (c - '0');
001D2:  CLRF   x90
001D4:  MOVLW  0A
001D6:  MOVWF  x8F
001D8:  MOVFF  8A,92
001DC:  MOVFF  89,91
001E0:  BRA    00BA
001E2:  MOVLW  30
001E4:  SUBWF  x8E,W
001E6:  ADDWF  01,W
001E8:  MOVWF  x89
001EA:  MOVLW  00
001EC:  ADDWFC 02,W
001EE:  MOVWF  x8A
....................             c = s[index++];
001F0:  MOVF   x8D,W
001F2:  INCF   x8D,F
001F4:  ADDWF  x87,W
001F6:  MOVWF  FE9
001F8:  MOVLW  00
001FA:  ADDWFC x88,W
001FC:  MOVWF  FEA
001FE:  MOVFF  FEF,8E
00202:  BRA    01C6
....................          }
....................       }
00204:  BRA    02C0
....................       else if (base == 16)    // The number is a hexa number
00206:  MOVF   x8C,W
00208:  SUBLW  10
0020A:  BNZ   02C0
....................       {
....................          c = toupper(c);
0020C:  MOVF   x8E,W
0020E:  SUBLW  60
00210:  BC    021E
00212:  MOVF   x8E,W
00214:  SUBLW  7A
00216:  BNC   021E
00218:  MOVF   x8E,W
0021A:  ANDLW  DF
0021C:  BRA    0220
0021E:  MOVF   x8E,W
00220:  MOVWF  x8E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
00222:  MOVF   x8E,W
00224:  SUBLW  2F
00226:  BC    022E
00228:  MOVF   x8E,W
0022A:  SUBLW  39
0022C:  BC    023A
0022E:  MOVF   x8E,W
00230:  SUBLW  40
00232:  BC    02C0
00234:  MOVF   x8E,W
00236:  SUBLW  46
00238:  BNC   02C0
....................          {
....................             if (c >= '0' && c <= '9')
0023A:  MOVF   x8E,W
0023C:  SUBLW  2F
0023E:  BC    026E
00240:  MOVF   x8E,W
00242:  SUBLW  39
00244:  BNC   026E
....................                result = (result << 4) + (c - '0');
00246:  RLCF   x89,W
00248:  MOVWF  x8F
0024A:  RLCF   x8A,W
0024C:  MOVWF  x90
0024E:  RLCF   x8F,F
00250:  RLCF   x90,F
00252:  RLCF   x8F,F
00254:  RLCF   x90,F
00256:  RLCF   x8F,F
00258:  RLCF   x90,F
0025A:  MOVLW  F0
0025C:  ANDWF  x8F,F
0025E:  MOVLW  30
00260:  SUBWF  x8E,W
00262:  ADDWF  x8F,W
00264:  MOVWF  x89
00266:  MOVLW  00
00268:  ADDWFC x90,W
0026A:  MOVWF  x8A
0026C:  BRA    0296
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
0026E:  RLCF   x89,W
00270:  MOVWF  x8F
00272:  RLCF   x8A,W
00274:  MOVWF  x90
00276:  RLCF   x8F,F
00278:  RLCF   x90,F
0027A:  RLCF   x8F,F
0027C:  RLCF   x90,F
0027E:  RLCF   x8F,F
00280:  RLCF   x90,F
00282:  MOVLW  F0
00284:  ANDWF  x8F,F
00286:  MOVLW  41
00288:  SUBWF  x8E,W
0028A:  ADDLW  0A
0028C:  ADDWF  x8F,W
0028E:  MOVWF  x89
00290:  MOVLW  00
00292:  ADDWFC x90,W
00294:  MOVWF  x8A
.................... 
....................             c = s[index++];c = toupper(c);
00296:  MOVF   x8D,W
00298:  INCF   x8D,F
0029A:  ADDWF  x87,W
0029C:  MOVWF  FE9
0029E:  MOVLW  00
002A0:  ADDWFC x88,W
002A2:  MOVWF  FEA
002A4:  MOVFF  FEF,8E
002A8:  MOVF   x8E,W
002AA:  SUBLW  60
002AC:  BC    02BA
002AE:  MOVF   x8E,W
002B0:  SUBLW  7A
002B2:  BNC   02BA
002B4:  MOVF   x8E,W
002B6:  ANDLW  DF
002B8:  BRA    02BC
002BA:  MOVF   x8E,W
002BC:  MOVWF  x8E
002BE:  BRA    0222
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
002C0:  MOVF   x8C,W
002C2:  SUBLW  0A
002C4:  BNZ   02D4
002C6:  DECFSZ x8B,W
002C8:  BRA    02D4
....................       result = -result;
002CA:  COMF   x89,F
002CC:  COMF   x8A,F
002CE:  INCF   x89,F
002D0:  BTFSC  FD8.2
002D2:  INCF   x8A,F
.................... 
....................    return(result);
002D4:  MOVFF  89,01
002D8:  MOVFF  8A,02
002DC:  RETURN 0
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include    "motor_control.c"
.................... #define     FORWARD     1
.................... #define     BACK        0
.................... 
.................... #define     max_dutycicle       320
.................... #define     min_dutycicle       max_dutycicle / 15
.................... 
.................... #define     max_trigger_value   255
.................... #define     max_joystick_value  32767
.................... 
.................... // -------------------- Direcciones de registros -------------------- //
.................... #BYTE       CCPTMRS0        = 0xF49
.................... #BYTE       CCPTMRS1        = 0xF48
.................... 
.................... #BYTE       CCP1CON         = 0xFBD
.................... #BYTE       CCP2CON         = 0xF66
.................... #BYTE       CCP3CON         = 0xF5D
.................... #BYTE       CCP4CON         = 0xF57
.................... 
.................... #BYTE       T2CON           = 0xFBA
.................... #BYTE       PR2             = 0xFBB
.................... 
.................... // -------------------------- Estructuras --------------------------- //
.................... struct bth_conection_t
.................... {
....................     short updated_data;
....................     short IsConnected;
.................... };
.................... 
.................... struct motor_t
.................... {
....................     int     *DutyCicle;
....................     long    IN1_pin;
....................     long    IN2_pin;
.................... };
.................... 
.................... struct controller_t
.................... {
....................     signed long     Joystick[2];    // Entero de -32768 a 32767 (0 eje x, 1 eje y)
....................     int             Triggers[2];    // Entero de 0 a 255 (0 izquierdo, 1 derecho)
.................... };
.................... 
.................... // ---------------------------- Funciones --------------------------- //
.................... void motors_init(struct motor_t tires[2][2])
.................... {
....................     // Configuracion de Timers
....................     T2CON       = 0b00000100;
*
003F0:  MOVLW  04
003F2:  MOVWF  FBA
....................     PR2         = 79;
003F4:  MOVLW  4F
003F6:  MOVWF  FBB
....................     
....................     // Configuracion de CCPXCON para PWM
....................     CCPTMRS0 = CCPTMRS0 = 0b00000000;       // Configuramos CCPX con timer 2
003F8:  MOVLB  F
003FA:  CLRF   x49
....................     
....................     // Configiracion de modulo CCPX para PWM
....................     CCP4CON = 0b00001100, CCP3CON = 0b00001100, CCP2CON = 0b00001100, CCP1CON = 0b00001100;
003FC:  MOVLW  0C
003FE:  MOVWF  x57
00400:  MOVWF  x5D
00402:  MOVWF  F66
00404:  MOVWF  FBD
.................... 
....................     for(int i = 0; i < 2 ; i++)
00406:  CLRF   41
00408:  MOVF   41,W
0040A:  SUBLW  01
0040C:  BNC   046A
....................         for(int j = 0; j < 2; j++)
0040E:  CLRF   42
00410:  MOVF   42,W
00412:  SUBLW  01
00414:  BNC   0466
....................             *(tires[i][j].DutyCicle) = 0;
00416:  CLRF   46
00418:  MOVFF  41,45
0041C:  CLRF   48
0041E:  MOVLW  0C
00420:  MOVWF  47
00422:  MOVLB  0
00424:  RCALL  03D2
00426:  MOVFF  02,44
0042A:  MOVFF  01,43
0042E:  CLRF   46
00430:  MOVFF  42,45
00434:  CLRF   48
00436:  MOVLW  06
00438:  MOVWF  47
0043A:  RCALL  03D2
0043C:  MOVF   01,W
0043E:  ADDWF  43,F
00440:  MOVF   02,W
00442:  ADDWFC 44,F
00444:  MOVF   3F,W
00446:  ADDWF  43,W
00448:  MOVWF  FE9
0044A:  MOVF   40,W
0044C:  ADDWFC 44,W
0044E:  MOVWF  FEA
00450:  MOVFF  FEC,03
00454:  MOVF   FED,F
00456:  MOVFF  FEF,FE9
0045A:  MOVFF  03,FEA
0045E:  CLRF   FEF
00460:  INCF   42,F
00462:  MOVLB  F
00464:  BRA    0410
00466:  INCF   41,F
00468:  BRA    0408
0046A:  MOVLB  0
0046C:  GOTO   1112 (RETURN)
.................... }
.................... 
.................... void motor_movement(struct motor_t *motor, float speed)   // Modo de movimiento normal
*
00AFA:  CLRF   5B
00AFC:  CLRF   5A
00AFE:  CLRF   59
00B00:  CLRF   58
00B02:  MOVFF  54,5F
00B06:  MOVFF  53,5E
00B0A:  MOVFF  52,5D
00B0E:  MOVFF  51,5C
00B12:  BRA    0A48
00B14:  BC    0B18
00B16:  BNZ   0B1C
00B18:  MOVLW  01
00B1A:  BRA    0B1E
00B1C:  MOVLW  00
00B1E:  BCF    55.0
00B20:  BTFSC  FE8.0
00B22:  BSF    55.0
.................... {
....................     short direction = (speed >= 0) ? FORWARD : BACK;
....................     
....................     // Establecemos direccion de giro
....................     output_bit(motor->IN1_pin, direction);
00B24:  MOVLW  02
00B26:  ADDWF  4F,W
00B28:  MOVWF  FE9
00B2A:  MOVLW  00
00B2C:  ADDWFC 50,W
00B2E:  MOVWF  FEA
00B30:  MOVFF  FEC,59
00B34:  MOVF   FED,F
00B36:  MOVFF  FEF,58
00B3A:  MOVLW  00
00B3C:  BTFSC  55.0
00B3E:  MOVLW  01
00B40:  MOVFF  58,5A
00B44:  MOVWF  5B
00B46:  MOVLW  0F
00B48:  MOVWF  5D
00B4A:  MOVLW  89
00B4C:  MOVWF  5C
00B4E:  RCALL  049A
00B50:  MOVFF  58,5A
00B54:  CLRF   5B
00B56:  MOVLW  0F
00B58:  MOVWF  5D
00B5A:  MOVLW  92
00B5C:  MOVWF  5C
00B5E:  RCALL  049A
....................     output_bit(motor->IN2_pin, !direction);
00B60:  MOVLW  04
00B62:  ADDWF  4F,W
00B64:  MOVWF  FE9
00B66:  MOVLW  00
00B68:  ADDWFC 50,W
00B6A:  MOVWF  FEA
00B6C:  MOVFF  FEC,59
00B70:  MOVF   FED,F
00B72:  MOVFF  FEF,58
00B76:  MOVLW  00
00B78:  BTFSS  55.0
00B7A:  MOVLW  01
00B7C:  MOVFF  58,5A
00B80:  MOVWF  5B
00B82:  MOVLW  0F
00B84:  MOVWF  5D
00B86:  MOVLW  89
00B88:  MOVWF  5C
00B8A:  RCALL  049A
00B8C:  MOVFF  58,5A
00B90:  CLRF   5B
00B92:  MOVLW  0F
00B94:  MOVWF  5D
00B96:  MOVLW  92
00B98:  MOVWF  5C
00B9A:  RCALL  049A
....................     
....................     // Establecemos DC para velocidad
....................     long aux = ((max_dutycicle - min_dutycicle) * abs(speed) / 100) + min_dutycicle;
00B9C:  MOVFF  51,00
00BA0:  MOVFF  52,01
00BA4:  MOVFF  53,02
00BA8:  MOVFF  54,03
00BAC:  BCF    01.7
00BAE:  CLRF   5B
00BB0:  MOVLW  80
00BB2:  MOVWF  5A
00BB4:  MOVLW  15
00BB6:  MOVWF  59
00BB8:  MOVLW  87
00BBA:  MOVWF  58
00BBC:  MOVFF  54,5F
00BC0:  MOVFF  53,5E
00BC4:  MOVFF  01,5D
00BC8:  MOVFF  51,5C
00BCC:  RCALL  0592
00BCE:  MOVFF  03,5B
00BD2:  MOVFF  02,5A
00BD6:  MOVFF  01,59
00BDA:  MOVFF  00,58
00BDE:  MOVFF  03,5F
00BE2:  MOVFF  02,5E
00BE6:  MOVFF  01,5D
00BEA:  MOVFF  00,5C
00BEE:  CLRF   x63
00BF0:  CLRF   x62
00BF2:  MOVLW  48
00BF4:  MOVWF  x61
00BF6:  MOVLW  85
00BF8:  MOVWF  x60
00BFA:  RCALL  0684
00BFC:  MOVFF  03,5B
00C00:  MOVFF  02,5A
00C04:  MOVFF  01,59
00C08:  MOVFF  00,58
00C0C:  BCF    FD8.1
00C0E:  MOVFF  03,5F
00C12:  MOVFF  02,5E
00C16:  MOVFF  01,5D
00C1A:  MOVFF  00,5C
00C1E:  CLRF   x63
00C20:  CLRF   x62
00C22:  MOVLW  28
00C24:  MOVWF  x61
00C26:  MOVLW  83
00C28:  MOVWF  x60
00C2A:  RCALL  07DE
00C2C:  MOVFF  03,5B
00C30:  MOVFF  02,5A
00C34:  MOVFF  01,59
00C38:  MOVFF  00,58
00C3C:  BRA    0AC0
00C3E:  MOVFF  02,57
00C42:  MOVFF  01,56
....................     *(motor->DutyCicle) = aux >> 2;
00C46:  MOVFF  4F,FE9
00C4A:  MOVFF  50,FEA
00C4E:  MOVFF  FEC,03
00C52:  MOVF   FED,F
00C54:  MOVFF  FEF,FE9
00C58:  MOVFF  03,FEA
00C5C:  RRCF   57,W
00C5E:  MOVWF  03
00C60:  RRCF   56,W
00C62:  MOVWF  02
00C64:  RRCF   03,F
00C66:  RRCF   02,F
00C68:  MOVLW  3F
00C6A:  ANDWF  03,F
00C6C:  MOVFF  02,FEF
00C70:  RETURN 0
.................... }
.................... 
.................... void motor_movement(struct motor_t *motor)    // Modo de freno de corto (Solo para emergencias)
.................... {
....................     output_high(motor->IN1_pin);
*
004D8:  MOVLW  02
004DA:  ADDWF  4F,W
004DC:  MOVWF  FE9
004DE:  MOVLW  00
004E0:  ADDWFC 50,W
004E2:  MOVWF  FEA
004E4:  MOVFF  FEC,52
004E8:  MOVF   FED,F
004EA:  MOVFF  FEF,51
004EE:  MOVFF  51,5A
004F2:  MOVLW  01
004F4:  MOVWF  5B
004F6:  MOVLW  0F
004F8:  MOVWF  5D
004FA:  MOVLW  89
004FC:  MOVWF  5C
004FE:  RCALL  049A
00500:  MOVFF  51,5A
00504:  CLRF   5B
00506:  MOVLW  0F
00508:  MOVWF  5D
0050A:  MOVLW  92
0050C:  MOVWF  5C
0050E:  RCALL  049A
....................     output_high(motor->IN2_pin);
00510:  MOVLW  04
00512:  ADDWF  4F,W
00514:  MOVWF  FE9
00516:  MOVLW  00
00518:  ADDWFC 50,W
0051A:  MOVWF  FEA
0051C:  MOVFF  FEC,52
00520:  MOVF   FED,F
00522:  MOVFF  FEF,51
00526:  MOVFF  51,5A
0052A:  MOVLW  01
0052C:  MOVWF  5B
0052E:  MOVLW  0F
00530:  MOVWF  5D
00532:  MOVLW  89
00534:  MOVWF  5C
00536:  RCALL  049A
00538:  MOVFF  51,5A
0053C:  CLRF   5B
0053E:  MOVLW  0F
00540:  MOVWF  5D
00542:  MOVLW  92
00544:  MOVWF  5C
00546:  RCALL  049A
00548:  RETURN 0
.................... }
.................... 
.................... void drive_tires(struct controller_t *xbox_controller, struct motor_t tires[2][2])
.................... {    
....................     // Si estan presionados los 2 al maximo, aplicamos freno de corto y salimos de funcion
....................     if((xbox_controller->Triggers[0] == 255) && (xbox_controller->Triggers[1] == 255))
*
00C72:  MOVLW  04
00C74:  ADDWF  3F,W
00C76:  MOVWF  FE9
00C78:  MOVLW  00
00C7A:  ADDWFC 40,W
00C7C:  MOVWF  FEA
00C7E:  INCFSZ FEF,W
00C80:  BRA    0CF6
00C82:  MOVLW  05
00C84:  ADDWF  3F,W
00C86:  MOVWF  FE9
00C88:  MOVLW  00
00C8A:  ADDWFC 40,W
00C8C:  MOVWF  FEA
00C8E:  INCFSZ FEF,W
00C90:  BRA    0CF6
....................     {
....................         // Activamos modo short brake
....................         motor_movement(&tires[0][0]), motor_movement(&tires[0][1]);
00C92:  MOVFF  41,01
00C96:  MOVFF  42,03
00C9A:  MOVFF  42,50
00C9E:  MOVFF  41,4F
00CA2:  RCALL  04D8
00CA4:  MOVLW  06
00CA6:  ADDWF  41,W
00CA8:  MOVWF  01
00CAA:  MOVLW  00
00CAC:  ADDWFC 42,W
00CAE:  MOVWF  03
00CB0:  MOVFF  01,4D
00CB4:  MOVWF  4E
00CB6:  MOVWF  50
00CB8:  MOVFF  01,4F
00CBC:  RCALL  04D8
....................         motor_movement(&tires[1][0]), motor_movement(&tires[1][1]);
00CBE:  MOVLW  0C
00CC0:  ADDWF  41,W
00CC2:  MOVWF  01
00CC4:  MOVLW  00
00CC6:  ADDWFC 42,W
00CC8:  MOVWF  03
00CCA:  MOVFF  01,4D
00CCE:  MOVWF  4E
00CD0:  MOVWF  50
00CD2:  MOVFF  01,4F
00CD6:  RCALL  04D8
00CD8:  MOVLW  12
00CDA:  ADDWF  41,W
00CDC:  MOVWF  01
00CDE:  MOVLW  00
00CE0:  ADDWFC 42,W
00CE2:  MOVWF  03
00CE4:  MOVFF  01,4D
00CE8:  MOVWF  4E
00CEA:  MOVWF  50
00CEC:  MOVFF  01,4F
00CF0:  CALL   04D8
....................         return;
00CF4:  BRA    106A
....................     }
.................... 
....................     /*  Notas para comprender
....................     * Llanta contraria al giro, avanza con normalidad a la velocidad indicada (speed)
....................     * Llanta de apoyo, gira a menor velocidad en funcion de que tan desviado hacia la direccion esta el joystick 
....................          (-speed < turning_speed < speed)
....................     */
.................... 
....................     // Si no se aplico freno de corto, calculamos velocidad y direccion de movimiento
....................     
....................     float speed[2];
....................     signed long trigger_diff = (signed long) xbox_controller->Triggers[1] - xbox_controller->Triggers[0];
00CF6:  MOVLW  05
00CF8:  ADDWF  3F,W
00CFA:  MOVWF  FE9
00CFC:  MOVLW  00
00CFE:  ADDWFC 40,W
00D00:  MOVWF  FEA
00D02:  MOVF   FEF,W
00D04:  CLRF   4E
00D06:  MOVWF  4D
00D08:  MOVLW  04
00D0A:  ADDWF  3F,W
00D0C:  MOVWF  FE9
00D0E:  MOVLW  00
00D10:  ADDWFC 40,W
00D12:  MOVWF  FEA
00D14:  MOVF   FEF,W
00D16:  SUBWF  4D,W
00D18:  MOVWF  4B
00D1A:  MOVLW  00
00D1C:  SUBWFB 4E,W
00D1E:  MOVWF  4C
.................... 
....................     if(xbox_controller->Joystick[0] >= 0)        // El movimiento es a la derecha o al centro
00D20:  MOVFF  3F,FE9
00D24:  MOVFF  40,FEA
00D28:  MOVFF  FEC,4E
00D2C:  MOVF   FED,F
00D2E:  MOVFF  FEF,4D
00D32:  BTFSC  4E.7
00D34:  BRA    0E7E
....................     {
....................         speed[0] = trigger_diff * 100.0 / max_trigger_value;
00D36:  MOVFF  4C,52
00D3A:  MOVFF  4B,51
00D3E:  RCALL  054A
00D40:  MOVFF  03,5B
00D44:  MOVFF  02,5A
00D48:  MOVFF  01,59
00D4C:  MOVFF  00,58
00D50:  CLRF   5F
00D52:  CLRF   5E
00D54:  MOVLW  48
00D56:  MOVWF  5D
00D58:  MOVLW  85
00D5A:  MOVWF  5C
00D5C:  RCALL  0592
00D5E:  MOVFF  03,50
00D62:  MOVFF  02,4F
00D66:  MOVFF  01,4E
00D6A:  MOVFF  00,4D
00D6E:  MOVFF  03,5F
00D72:  MOVFF  02,5E
00D76:  MOVFF  01,5D
00D7A:  MOVFF  00,5C
00D7E:  CLRF   x63
00D80:  CLRF   x62
00D82:  MOVLW  7F
00D84:  MOVWF  x61
00D86:  MOVLW  86
00D88:  MOVWF  x60
00D8A:  RCALL  0684
00D8C:  MOVFF  03,46
00D90:  MOVFF  02,45
00D94:  MOVFF  01,44
00D98:  MOVFF  00,43
....................         // Flotante de -100 a 100 que indica la velocidad y direccion de movimiento (+ adelante, - atras)
....................         speed[1] = speed[0] - (2 * speed[0] * xbox_controller->Joystick[0] / 32767.0);
00D9C:  CLRF   5B
00D9E:  CLRF   5A
00DA0:  CLRF   59
00DA2:  MOVLW  80
00DA4:  MOVWF  58
00DA6:  MOVFF  46,5F
00DAA:  MOVFF  45,5E
00DAE:  MOVFF  44,5D
00DB2:  MOVFF  43,5C
00DB6:  CALL   0592
00DBA:  MOVFF  03,50
00DBE:  MOVFF  02,4F
00DC2:  MOVFF  01,4E
00DC6:  MOVFF  00,4D
00DCA:  MOVFF  3F,FE9
00DCE:  MOVFF  40,FEA
00DD2:  MOVFF  FEC,03
00DD6:  MOVF   FED,F
00DD8:  MOVFF  FEF,51
00DDC:  MOVFF  03,52
00DE0:  CALL   054A
00DE4:  MOVFF  50,5B
00DE8:  MOVFF  4F,5A
00DEC:  MOVFF  4E,59
00DF0:  MOVFF  4D,58
00DF4:  MOVFF  03,5F
00DF8:  MOVFF  02,5E
00DFC:  MOVFF  01,5D
00E00:  MOVFF  00,5C
00E04:  CALL   0592
00E08:  MOVFF  03,50
00E0C:  MOVFF  02,4F
00E10:  MOVFF  01,4E
00E14:  MOVFF  00,4D
00E18:  MOVFF  03,5F
00E1C:  MOVFF  02,5E
00E20:  MOVFF  01,5D
00E24:  MOVFF  00,5C
00E28:  CLRF   x63
00E2A:  MOVLW  FE
00E2C:  MOVWF  x62
00E2E:  MOVLW  7F
00E30:  MOVWF  x61
00E32:  MOVLW  8D
00E34:  MOVWF  x60
00E36:  RCALL  0684
00E38:  MOVFF  FEA,4E
00E3C:  MOVFF  FE9,4D
00E40:  BSF    FD8.1
00E42:  MOVFF  46,5F
00E46:  MOVFF  45,5E
00E4A:  MOVFF  44,5D
00E4E:  MOVFF  43,5C
00E52:  MOVFF  03,63
00E56:  MOVFF  02,62
00E5A:  MOVFF  01,61
00E5E:  MOVFF  00,60
00E62:  RCALL  07DE
00E64:  MOVFF  4E,FEA
00E68:  MOVFF  4D,FE9
00E6C:  MOVFF  03,4A
00E70:  MOVFF  02,49
00E74:  MOVFF  01,48
00E78:  MOVFF  00,47
....................         // Velocidad - (2 veces Velocidad * (Valor Joystick X / Valor maximo Joystick X))
....................     }
00E7C:  BRA    0FCA
....................     else                                        // El movimiento es a la izquierda
....................     {
....................         speed[1] = trigger_diff * 100.0 / max_trigger_value;
00E7E:  MOVFF  4C,52
00E82:  MOVFF  4B,51
00E86:  CALL   054A
00E8A:  MOVFF  03,5B
00E8E:  MOVFF  02,5A
00E92:  MOVFF  01,59
00E96:  MOVFF  00,58
00E9A:  CLRF   5F
00E9C:  CLRF   5E
00E9E:  MOVLW  48
00EA0:  MOVWF  5D
00EA2:  MOVLW  85
00EA4:  MOVWF  5C
00EA6:  CALL   0592
00EAA:  MOVFF  03,50
00EAE:  MOVFF  02,4F
00EB2:  MOVFF  01,4E
00EB6:  MOVFF  00,4D
00EBA:  MOVFF  03,5F
00EBE:  MOVFF  02,5E
00EC2:  MOVFF  01,5D
00EC6:  MOVFF  00,5C
00ECA:  CLRF   x63
00ECC:  CLRF   x62
00ECE:  MOVLW  7F
00ED0:  MOVWF  x61
00ED2:  MOVLW  86
00ED4:  MOVWF  x60
00ED6:  CALL   0684
00EDA:  MOVFF  03,4A
00EDE:  MOVFF  02,49
00EE2:  MOVFF  01,48
00EE6:  MOVFF  00,47
....................         // Flotante de -100 a 100 que indica la velocidad y direccion de movimiento (+ adelante, - atras)
....................         speed[0] = speed[1] - (2 * speed[1] * xbox_controller->Joystick[0] / -32768.0);
00EEA:  CLRF   5B
00EEC:  CLRF   5A
00EEE:  CLRF   59
00EF0:  MOVLW  80
00EF2:  MOVWF  58
00EF4:  MOVFF  4A,5F
00EF8:  MOVFF  49,5E
00EFC:  MOVFF  48,5D
00F00:  MOVFF  47,5C
00F04:  CALL   0592
00F08:  MOVFF  03,50
00F0C:  MOVFF  02,4F
00F10:  MOVFF  01,4E
00F14:  MOVFF  00,4D
00F18:  MOVFF  3F,FE9
00F1C:  MOVFF  40,FEA
00F20:  MOVFF  FEC,03
00F24:  MOVF   FED,F
00F26:  MOVFF  FEF,51
00F2A:  MOVFF  03,52
00F2E:  CALL   054A
00F32:  MOVFF  50,5B
00F36:  MOVFF  4F,5A
00F3A:  MOVFF  4E,59
00F3E:  MOVFF  4D,58
00F42:  MOVFF  03,5F
00F46:  MOVFF  02,5E
00F4A:  MOVFF  01,5D
00F4E:  MOVFF  00,5C
00F52:  CALL   0592
00F56:  MOVFF  03,50
00F5A:  MOVFF  02,4F
00F5E:  MOVFF  01,4E
00F62:  MOVFF  00,4D
00F66:  MOVFF  03,5F
00F6A:  MOVFF  02,5E
00F6E:  MOVFF  01,5D
00F72:  MOVFF  00,5C
00F76:  CLRF   x63
00F78:  CLRF   x62
00F7A:  MOVLW  80
00F7C:  MOVWF  x61
00F7E:  MOVLW  8E
00F80:  MOVWF  x60
00F82:  CALL   0684
00F86:  MOVFF  FEA,4E
00F8A:  MOVFF  FE9,4D
00F8E:  BSF    FD8.1
00F90:  MOVFF  4A,5F
00F94:  MOVFF  49,5E
00F98:  MOVFF  48,5D
00F9C:  MOVFF  47,5C
00FA0:  MOVFF  03,63
00FA4:  MOVFF  02,62
00FA8:  MOVFF  01,61
00FAC:  MOVFF  00,60
00FB0:  RCALL  07DE
00FB2:  MOVFF  4E,FEA
00FB6:  MOVFF  4D,FE9
00FBA:  MOVFF  03,46
00FBE:  MOVFF  02,45
00FC2:  MOVFF  01,44
00FC6:  MOVFF  00,43
....................         // Velocidad - (2 veces Velocidad * (Valor Joystick X / Valor maximo Joystick X))
....................     }
.................... 
....................     // Enviamos movimiento a las llantas //
....................     motor_movement(&tires[0][0], speed[0]);      // Llanta delantera izquierda
00FCA:  MOVFF  41,01
00FCE:  MOVFF  42,03
00FD2:  MOVFF  42,50
00FD6:  MOVFF  41,4F
00FDA:  MOVFF  46,54
00FDE:  MOVFF  45,53
00FE2:  MOVFF  44,52
00FE6:  MOVFF  43,51
00FEA:  RCALL  0AFA
....................     motor_movement(&tires[1][0], speed[0]);      // Llanta trasera izquierda
00FEC:  MOVLW  0C
00FEE:  ADDWF  41,W
00FF0:  MOVWF  01
00FF2:  MOVLW  00
00FF4:  ADDWFC 42,W
00FF6:  MOVWF  03
00FF8:  MOVFF  01,4D
00FFC:  MOVWF  4E
00FFE:  MOVWF  50
01000:  MOVFF  01,4F
01004:  MOVFF  46,54
01008:  MOVFF  45,53
0100C:  MOVFF  44,52
01010:  MOVFF  43,51
01014:  RCALL  0AFA
....................     
....................     motor_movement(&tires[0][1], speed[1]);      // Llanta delantera derecha
01016:  MOVLW  06
01018:  ADDWF  41,W
0101A:  MOVWF  01
0101C:  MOVLW  00
0101E:  ADDWFC 42,W
01020:  MOVWF  03
01022:  MOVFF  01,4D
01026:  MOVWF  4E
01028:  MOVWF  50
0102A:  MOVFF  01,4F
0102E:  MOVFF  4A,54
01032:  MOVFF  49,53
01036:  MOVFF  48,52
0103A:  MOVFF  47,51
0103E:  RCALL  0AFA
....................     motor_movement(&tires[1][1], speed[1]);      // Llanta trasera derecha
01040:  MOVLW  12
01042:  ADDWF  41,W
01044:  MOVWF  01
01046:  MOVLW  00
01048:  ADDWFC 42,W
0104A:  MOVWF  03
0104C:  MOVFF  01,4D
01050:  MOVWF  4E
01052:  MOVWF  50
01054:  MOVFF  01,4F
01058:  MOVFF  4A,54
0105C:  MOVFF  49,53
01060:  MOVFF  48,52
01064:  MOVFF  47,51
01068:  RCALL  0AFA
0106A:  GOTO   1184 (RETURN)
.................... }
.................... 
.................... /*
.................... Los gatillos establecen la velocidad maxima de giro, y la posicion del joystick establece como se repartira esta velocidad en las llantas, para poder hacer diferentes maniobras, por ejemlo:
.................... 
.................... * Cuanto mas pegado al maximo o minimo del eje Y, mayor sera la diferencia de velocidad entre las llantas de la izquierda con las de la derecha
.................... * Cuanto mas pegado al maximo o minimo del eje X, mayor sera la diferencia de velocidad entre las llantas de arriba y abajo
.................... 
.................... Por lo tanto: 
.................... * La llanta mas lejana a la direccion de movimiento en X tendra mas velocidad que la mas pegada
.................... * La llanta mas lejana a la direccion de movimiento en Y tendra mas velocidad que la mas pegada
.................... */ 
.................... 
.................... 
.................... // --------------------- Direccion de registros --------------------- //
.................... #BYTE       TRISA               = 0xF92
.................... #BYTE       TRISB               = 0xF93
.................... #BYTE       TRISC               = 0xF94
.................... #BIT        bluetooth_state     = 0xF81.1   // PORTB
.................... #BIT        status_LED          = 0xF89.0   // LATA
.................... 
.................... #BYTE       INTCON              = 0xFF2
.................... #BIT        INT1IE              = 0xFF0.3   // INTCON3
.................... #BIT        INTEDG1             = 0xFF1.5   // INTCON2
.................... #BIT        RC1IE               = 0xF9D.5   // PIE1
.................... #BIT        IPEN                = 0xFD0.7   // RCON
.................... #BIT        RC1IP               = 0xF9F.5   // IPR1
.................... 
.................... // ----------------------- Variable Globales ------------------------ //
.................... struct motor_t  tires[2][2]   = 
.................... {
....................     {   // Llantas delanteras
....................         { 0xFBE, PIN_B3, PIN_B4 },  // Izquierda
....................         { 0xF67, PIN_B6, PIN_B7 }   // Derecha
....................     },
....................     {   // Llantas traseras
....................         { 0xF5E, PIN_A4, PIN_A5 },  // Izquierda
....................         { 0xF58, PIN_A6, PIN_A7 }   // Derecha
....................     }
.................... };
.................... 
.................... const struct    controller_t resting_state = { {0, 0}, {0, 0} };
.................... struct          controller_t xbox_controller;
.................... 
.................... struct          bth_conection_t PC = { FALSE, FALSE };
.................... 
.................... 
.................... // -------------------------- Interrupciones ------------------------ //
.................... #INT_RDA
.................... void control_instructions()
*
002DE:  BTFSS  F9E.5
002E0:  BRA    02DE
002E2:  MOVFF  FAE,6C
.................... {
....................     int data = getch();
....................     
....................     if(data == '*')     // Recibimos caracter de inicio de datos
002E6:  MOVF   x6C,W
002E8:  SUBLW  2A
002EA:  BNZ   0386
....................     {           
....................         char XJoystick[8], YJoystick[8], LeftTrigger[5], RightTrigger[5];
....................         
....................         // Obtenemos cadenas de caracteres con los valores a recibir
....................         gets(XJoystick);
002EC:  CLRF   FEA
002EE:  MOVLW  6D
002F0:  MOVWF  FE9
002F2:  CLRF   FED
002F4:  BTFSS  F9E.5
002F6:  BRA    02F4
002F8:  MOVFF  FAE,FEC
002FC:  MOVLW  0D
002FE:  SUBWF  FEF,W
00300:  BNZ   02F4
00302:  CLRF   FEC
....................         gets(YJoystick);
00304:  CLRF   FEA
00306:  MOVLW  75
00308:  MOVWF  FE9
0030A:  CLRF   FED
0030C:  BTFSS  F9E.5
0030E:  BRA    030C
00310:  MOVFF  FAE,FEC
00314:  MOVLW  0D
00316:  SUBWF  FEF,W
00318:  BNZ   030C
0031A:  CLRF   FEC
.................... 
....................         gets(LeftTrigger);
0031C:  CLRF   FEA
0031E:  MOVLW  7D
00320:  MOVWF  FE9
00322:  CLRF   FED
00324:  BTFSS  F9E.5
00326:  BRA    0324
00328:  MOVFF  FAE,FEC
0032C:  MOVLW  0D
0032E:  SUBWF  FEF,W
00330:  BNZ   0324
00332:  CLRF   FEC
....................         gets(RightTrigger);
00334:  CLRF   FEA
00336:  MOVLW  82
00338:  MOVWF  FE9
0033A:  CLRF   FED
0033C:  BTFSS  F9E.5
0033E:  BRA    033C
00340:  MOVFF  FAE,FEC
00344:  MOVLW  0D
00346:  SUBWF  FEF,W
00348:  BNZ   033C
0034A:  CLRF   FEC
.................... 
....................         // Realizamos la conversion y actualizamos los valores del control
....................         xbox_controller.Joystick[0] =  atol(XJoystick);
0034C:  CLRF   x88
0034E:  MOVLW  6D
00350:  MOVWF  x87
00352:  RCALL  010C
00354:  MOVFF  02,38
00358:  MOVFF  01,37
....................         xbox_controller.Joystick[1] =  atol(YJoystick);
0035C:  CLRF   x88
0035E:  MOVLW  75
00360:  MOVWF  x87
00362:  RCALL  010C
00364:  MOVFF  02,3A
00368:  MOVFF  01,39
....................         
....................         xbox_controller.Triggers[0] =  atol(LeftTrigger);
0036C:  CLRF   x88
0036E:  MOVLW  7D
00370:  MOVWF  x87
00372:  RCALL  010C
00374:  MOVFF  01,3B
....................         xbox_controller.Triggers[1] =  atol(RightTrigger);
00378:  CLRF   x88
0037A:  MOVLW  82
0037C:  MOVWF  x87
0037E:  RCALL  010C
00380:  MOVFF  01,3C
.................... 
....................         // Actualizamos variables de conexion
....................         PC.updated_data = TRUE;
00384:  BSF    3D.0
....................     }
.................... }
.................... 
.................... /* Inforamcion de variables
.................... * updated_data: Booleano para sealar que hubo una actualizacion de informacion y no ha sido aplicada.
....................     * updated_data = FALSE   : No hay nueva informacion
....................     * updated_data = TRUE    : Hay informacion pendiente de aplicar
.................... * isConnected: Booleno para saber el estatus de la conexion de bluetooth
.................... */
.................... 
00386:  BCF    F9E.5
00388:  GOTO   006C
.................... #INT_EXT1
.................... void bluetooth_connection()
.................... {
....................     INTEDG1 ^= TRUE;                            // Cambiamos el flanco de deteccion
0038C:  MOVLW  00
0038E:  BTFSC  FF1.5
00390:  MOVLW  01
00392:  XORLW  01
00394:  BCF    FF1.5
00396:  BTFSC  FE8.0
00398:  BSF    FF1.5
....................     PC.IsConnected = status_LED = !INTEDG1;     // Cambiamos el estatus de conexion
0039A:  BCF    3D.1
0039C:  BCF    F89.0
0039E:  BTFSS  FF1.5
003A0:  BSF    F89.0
003A2:  BTFSS  F89.0
003A4:  BRA    03A8
003A6:  BSF    3D.1
003A8:  BCF    FF0.0
003AA:  GOTO   006C
.................... }
.................... 
.................... // ---------------------------- Funciones --------------------------- //
.................... void log_init()
.................... {
....................     // Configuracion de pines GPIO
....................     TRISA       = 0b00000000;
003AE:  CLRF   F92
....................     TRISB       = 0b00000010;
003B0:  MOVLW  02
003B2:  MOVWF  F93
....................     TRISC       = 0b11000000;
003B4:  MOVLW  C0
003B6:  MOVWF  F94
.................... 
....................     INTCON = 0b11000000;
003B8:  MOVWF  FF2
.................... 
....................     // Configuracion de Interrupciones
....................     IPEN = RC1IE = RC1IP =  TRUE;       // Establecemos la interrupcion de recepcion serial como prioridad
003BA:  BSF    F9F.5
003BC:  BSF    F9D.5
003BE:  BSF    FD0.7
....................     
....................     INT1IE  = TRUE;                 // Activamos INT_EXT1 
003C0:  BSF    FF0.3
....................     INTEDG1 = !bluetooth_state;     // TRUE: flanco de subida, cuando el pin state esta en bajo. FALSE: flanco de bajada, cuando el pin state esta en alto
003C2:  BCF    FF1.5
003C4:  BTFSS  F81.1
003C6:  BSF    FF1.5
....................     PC.IsConnected = bluetooth_state;
003C8:  BCF    3D.1
003CA:  BTFSC  F81.1
003CC:  BSF    3D.1
003CE:  GOTO   1108 (RETURN)
.................... }
.................... 
.................... // ------------------------ Codigo Principal ----------------------- //
.................... void main()
*
0106E:  CLRF   FF8
01070:  BCF    FD0.7
01072:  BSF    07.7
01074:  MOVLW  70
01076:  MOVWF  FD3
01078:  BCF    F9B.6
0107A:  BCF    F9B.7
0107C:  BSF    FB8.3
0107E:  MOVLW  A0
01080:  MOVWF  FAF
01082:  MOVLW  01
01084:  MOVWF  FB0
01086:  MOVLW  A6
01088:  MOVWF  FAC
0108A:  MOVLW  90
0108C:  MOVWF  FAB
0108E:  MOVLB  F
01090:  CLRF   x38
01092:  CLRF   x39
01094:  CLRF   x3A
01096:  CLRF   F77
01098:  CLRF   F78
0109A:  CLRF   F79
0109C:  BRA    10C4
0109E:  DATA 02,00
010A0:  DATA 19,00
010A2:  DATA 00,18
010A4:  DATA 00,1F
010A6:  DATA BE,0F
010A8:  DATA 0B,7C
010AA:  DATA 0C,7C
010AC:  DATA 67,0F
010AE:  DATA 0E,7C
010B0:  DATA 0F,7C
010B2:  DATA 5E,0F
010B4:  DATA 04,7C
010B6:  DATA 05,7C
010B8:  DATA 58,0F
010BA:  DATA 06,7C
010BC:  DATA 07,7C
010BE:  DATA 01,00
010C0:  DATA 3D,00
010C2:  DATA 00,00
010C4:  MOVLW  00
010C6:  MOVWF  FF8
010C8:  MOVLW  10
010CA:  MOVWF  FF7
010CC:  MOVLW  9E
010CE:  MOVWF  FF6
010D0:  TBLRD*+
010D2:  MOVF   FF5,W
010D4:  MOVWF  00
010D6:  XORLW  00
010D8:  BZ    1100
010DA:  TBLRD*+
010DC:  MOVF   FF5,W
010DE:  MOVWF  01
010E0:  BTFSC  FE8.7
010E2:  BRA    10EE
010E4:  ANDLW  3F
010E6:  MOVWF  FEA
010E8:  TBLRD*+
010EA:  MOVFF  FF5,FE9
010EE:  BTFSC  01.6
010F0:  TBLRD*+
010F2:  BTFSS  01.6
010F4:  TBLRD*+
010F6:  MOVFF  FF5,FEE
010FA:  DCFSNZ 00,F
010FC:  BRA    10D0
010FE:  BRA    10F2
01100:  CLRF   FF8
.................... {
....................     log_init();
01102:  MOVLB  0
01104:  GOTO   03AE
....................     motors_init(tires);
01108:  CLRF   40
0110A:  MOVLW  1F
0110C:  MOVWF  3F
0110E:  GOTO   03F0
.................... 
....................     Connection_animation:    
....................     // Esperamos conexion bluetooth con una animacion del LED indicador
....................     for(int time = 0; !PC.IsConnected; time++, delay_ms(1))
01112:  CLRF   3E
01114:  BTFSC  3D.1
01116:  BRA    1140
....................     {
....................         if(time == 200)
01118:  MOVF   3E,W
0111A:  SUBLW  C8
0111C:  BNZ   112E
....................         {
....................             status_LED ^= TRUE;
0111E:  MOVLW  00
01120:  BTFSC  F89.0
01122:  MOVLW  01
01124:  XORLW  01
01126:  BCF    F89.0
01128:  BTFSC  FE8.0
0112A:  BSF    F89.0
....................             time = 0;
0112C:  CLRF   3E
....................         }
0112E:  MOVF   3E,W
01130:  INCF   3E,F
01132:  MOVLW  01
01134:  MOVWF  3F
01136:  MOVLB  0
01138:  GOTO   0470
0113C:  MOVLB  0
0113E:  BRA    1114
....................     }
.................... 
....................     while (TRUE)
....................     {   
....................         //*/
....................         if(!PC.IsConnected)                 // Si no hay conexion ponemos modo reposo (Detenido)
01140:  BTFSC  3D.1
01142:  BRA    1170
....................         {
....................             // Aplicamos freno de corto cuando no hay conexion
....................             motor_movement(&tires[0][0]), motor_movement(&tires[0][1]);
01144:  CLRF   50
01146:  MOVLW  1F
01148:  MOVWF  4F
0114A:  MOVLB  0
0114C:  CALL   04D8
01150:  CLRF   50
01152:  MOVLW  25
01154:  MOVWF  4F
01156:  CALL   04D8
....................             motor_movement(&tires[1][0]), motor_movement(&tires[1][1]);
0115A:  CLRF   50
0115C:  MOVLW  2B
0115E:  MOVWF  4F
01160:  CALL   04D8
01164:  CLRF   50
01166:  MOVLW  31
01168:  MOVWF  4F
0116A:  CALL   04D8
....................             
....................             goto Connection_animation;
0116E:  BRA    1112
....................         }
.................... 
....................         // Si hay conexion
....................         if(PC.updated_data)                // Si se actualizo la posicion
01170:  BTFSS  3D.0
01172:  BRA    1186
....................         {
....................             // Enviamos instrucciones a motores
....................             drive_tires(&xbox_controller, tires);
01174:  CLRF   40
01176:  MOVLW  37
01178:  MOVWF  3F
0117A:  CLRF   42
0117C:  MOVLW  1F
0117E:  MOVWF  41
01180:  MOVLB  0
01182:  BRA    0C72
....................             PC.updated_data = FALSE;
01184:  BCF    3D.0
....................         }
01186:  BRA    1140
....................         //*/
.................... 
....................         /*/ Revision de  almacenamiento de variables
....................         printf("Joystick X = %ld | Y = %ld\r\n", xbox_controller.Joystick[0], xbox_controller.Joystick[1]);
....................         printf("Triggers 1 =  %u | 2 = %u\r\n", xbox_controller.Triggers[0],  xbox_controller.Triggers[1]);
....................         delay_ms(100);
....................         //*/
....................     }
.................... }
.................... 
01188:  SLEEP 
.................... /*
.................... El codigo esta compuesto de las siguientes partes
.................... 
....................     * Interrupcion de recepcion de datos en puerto serial: Recibe los datos actualizados del control de XBOX desde el programa de computadora en C#
.................... 
....................     * Interrupcion externa 1: Para detectar pin de state de modulo Bluetooth
.................... 
....................     * Funcion principal: Inicializa los registros, y mueve las ruedas cuando hay nueva informacion
.................... */

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY FCMEN IESO
   Word  2: 3C1E   PUT BROWNOUT BORV19 NOWDT WDT32768
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2B5 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
