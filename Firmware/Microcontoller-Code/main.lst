CCS PCH C Compiler, Version 5.112, 29001               25-abr.-24 00:51

               Filename:   C:\Users\diego\Desktop\Mordu\Firmware\Microcontoller-Code\main.lst

               ROM used:   4382 bytes (7%)
                           Largest free fragment is 61150
               RAM used:   64 (2%) at main() level
                           149 (4%) worst case
               Stack used: 0 locations
               Stack size: 31

*
00000:  GOTO   1036
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.5
00056:  GOTO   0060
0005A:  BTFSC  F9E.5
0005C:  GOTO   02D2
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVFF  15,FF5
0009A:  MOVFF  16,FF6
0009E:  MOVFF  17,FF7
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
.................... // --------------- Preprocesadores de microcontrolador -------------- //
.................... #include    <18F26K22.h>                                                // Libreria del Microcontrolador
.................... //////////// Standard Header file for the PIC18F26K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F26K22
000AE:  MOVF   x90,W
000B0:  XORWF  x92,W
000B2:  ANDLW  80
000B4:  MOVWF  x94
000B6:  BTFSS  x90.7
000B8:  BRA    00C4
000BA:  COMF   x8F,F
000BC:  COMF   x90,F
000BE:  INCF   x8F,F
000C0:  BTFSC  FD8.2
000C2:  INCF   x90,F
000C4:  BTFSS  x92.7
000C6:  BRA    00D2
000C8:  COMF   x91,F
000CA:  COMF   x92,F
000CC:  INCF   x91,F
000CE:  BTFSC  FD8.2
000D0:  INCF   x92,F
000D2:  MOVF   x8F,W
000D4:  MULWF  x91
000D6:  MOVFF  FF3,01
000DA:  MOVFF  FF4,00
000DE:  MULWF  x92
000E0:  MOVF   FF3,W
000E2:  ADDWF  00,F
000E4:  MOVF   x90,W
000E6:  MULWF  x91
000E8:  MOVF   FF3,W
000EA:  ADDWFC 00,W
000EC:  MOVWF  02
000EE:  BTFSS  x94.7
000F0:  BRA    00FC
000F2:  COMF   01,F
000F4:  COMF   02,F
000F6:  INCF   01,F
000F8:  BTFSC  FD8.2
000FA:  INCF   02,F
000FC:  GOTO   01D6 (RETURN)
*
0039A:  MOVF   45,W
0039C:  MULWF  47
0039E:  MOVFF  FF3,01
003A2:  MOVFF  FF4,00
003A6:  MULWF  48
003A8:  MOVF   FF3,W
003AA:  ADDWF  00,F
003AC:  MOVF   46,W
003AE:  MULWF  47
003B0:  MOVF   FF3,W
003B2:  ADDWFC 00,W
003B4:  MOVWF  02
003B6:  RETURN 0
*
00462:  MOVF   5A,W
00464:  ANDLW  07
00466:  MOVWF  00
00468:  RRCF   5A,W
0046A:  MOVWF  01
0046C:  RRCF   01,F
0046E:  RRCF   01,F
00470:  MOVLW  1F
00472:  ANDWF  01,F
00474:  MOVF   01,W
00476:  ADDWF  5C,W
00478:  MOVWF  FE9
0047A:  MOVLW  00
0047C:  ADDWFC 5D,W
0047E:  MOVWF  FEA
00480:  CLRF   01
00482:  INCF   01,F
00484:  INCF   00,F
00486:  BRA    048A
00488:  RLCF   01,F
0048A:  DECFSZ 00,F
0048C:  BRA    0488
0048E:  MOVF   5B,F
00490:  BZ    0498
00492:  MOVF   01,W
00494:  IORWF  FEF,F
00496:  BRA    049E
00498:  COMF   01,F
0049A:  MOVF   01,W
0049C:  ANDWF  FEF,F
0049E:  RETURN 0
*
00512:  MOVLW  8E
00514:  MOVWF  00
00516:  MOVFF  52,01
0051A:  MOVFF  51,02
0051E:  CLRF   03
00520:  BTFSS  52.7
00522:  BRA    052E
00524:  COMF   01,F
00526:  COMF   02,F
00528:  INCF   02,F
0052A:  BNZ   052E
0052C:  INCF   01,F
0052E:  MOVF   01,F
00530:  BNZ   0544
00532:  MOVFF  02,01
00536:  CLRF   02
00538:  MOVLW  08
0053A:  SUBWF  00,F
0053C:  MOVF   01,F
0053E:  BNZ   0544
00540:  CLRF   00
00542:  BRA    0558
00544:  BCF    FD8.0
00546:  BTFSC  01.7
00548:  BRA    0552
0054A:  RLCF   02,F
0054C:  RLCF   01,F
0054E:  DECF   00,F
00550:  BRA    0544
00552:  BTFSC  52.7
00554:  BRA    0558
00556:  BCF    01.7
00558:  RETURN 0
0055A:  MOVF   58,W
0055C:  BTFSC  FD8.2
0055E:  BRA    0642
00560:  MOVWF  00
00562:  MOVF   5C,W
00564:  BTFSC  FD8.2
00566:  BRA    0642
00568:  ADDWF  00,F
0056A:  BNC   0574
0056C:  MOVLW  81
0056E:  ADDWF  00,F
00570:  BC    0642
00572:  BRA    057C
00574:  MOVLW  7F
00576:  SUBWF  00,F
00578:  BNC   0642
0057A:  BZ    0642
0057C:  MOVFF  59,60
00580:  MOVF   5D,W
00582:  XORWF  x60,F
00584:  BSF    59.7
00586:  BSF    5D.7
00588:  MOVF   5B,W
0058A:  MULWF  5F
0058C:  MOVFF  FF4,62
00590:  MOVF   5A,W
00592:  MULWF  5E
00594:  MOVFF  FF4,03
00598:  MOVFF  FF3,61
0059C:  MULWF  5F
0059E:  MOVF   FF3,W
005A0:  ADDWF  x62,F
005A2:  MOVF   FF4,W
005A4:  ADDWFC x61,F
005A6:  MOVLW  00
005A8:  ADDWFC 03,F
005AA:  MOVF   5B,W
005AC:  MULWF  5E
005AE:  MOVF   FF3,W
005B0:  ADDWF  x62,F
005B2:  MOVF   FF4,W
005B4:  ADDWFC x61,F
005B6:  MOVLW  00
005B8:  CLRF   02
005BA:  ADDWFC 03,F
005BC:  ADDWFC 02,F
005BE:  MOVF   59,W
005C0:  MULWF  5F
005C2:  MOVF   FF3,W
005C4:  ADDWF  x61,F
005C6:  MOVF   FF4,W
005C8:  ADDWFC 03,F
005CA:  MOVLW  00
005CC:  ADDWFC 02,F
005CE:  MOVF   59,W
005D0:  MULWF  5E
005D2:  MOVF   FF3,W
005D4:  ADDWF  03,F
005D6:  MOVF   FF4,W
005D8:  ADDWFC 02,F
005DA:  MOVLW  00
005DC:  CLRF   01
005DE:  ADDWFC 01,F
005E0:  MOVF   5B,W
005E2:  MULWF  5D
005E4:  MOVF   FF3,W
005E6:  ADDWF  x61,F
005E8:  MOVF   FF4,W
005EA:  ADDWFC 03,F
005EC:  MOVLW  00
005EE:  ADDWFC 02,F
005F0:  ADDWFC 01,F
005F2:  MOVF   5A,W
005F4:  MULWF  5D
005F6:  MOVF   FF3,W
005F8:  ADDWF  03,F
005FA:  MOVF   FF4,W
005FC:  ADDWFC 02,F
005FE:  MOVLW  00
00600:  ADDWFC 01,F
00602:  MOVF   59,W
00604:  MULWF  5D
00606:  MOVF   FF3,W
00608:  ADDWF  02,F
0060A:  MOVF   FF4,W
0060C:  ADDWFC 01,F
0060E:  INCF   00,F
00610:  BTFSC  01.7
00612:  BRA    061E
00614:  RLCF   x61,F
00616:  RLCF   03,F
00618:  RLCF   02,F
0061A:  RLCF   01,F
0061C:  DECF   00,F
0061E:  MOVLW  00
00620:  BTFSS  x61.7
00622:  BRA    0638
00624:  INCF   03,F
00626:  ADDWFC 02,F
00628:  ADDWFC 01,F
0062A:  MOVF   01,W
0062C:  BNZ   0638
0062E:  MOVF   02,W
00630:  BNZ   0638
00632:  MOVF   03,W
00634:  BNZ   0638
00636:  INCF   00,F
00638:  BTFSC  x60.7
0063A:  BSF    01.7
0063C:  BTFSS  x60.7
0063E:  BCF    01.7
00640:  BRA    064A
00642:  CLRF   00
00644:  CLRF   01
00646:  CLRF   02
00648:  CLRF   03
0064A:  RETURN 0
0064C:  MOVF   5C,W
0064E:  BTFSC  FD8.2
00650:  BRA    079C
00652:  MOVWF  x68
00654:  MOVF   x60,W
00656:  BTFSC  FD8.2
00658:  BRA    079C
0065A:  SUBWF  x68,F
0065C:  BNC   0668
0065E:  MOVLW  7F
00660:  ADDWF  x68,F
00662:  BTFSC  FD8.0
00664:  BRA    079C
00666:  BRA    0674
00668:  MOVLW  81
0066A:  SUBWF  x68,F
0066C:  BTFSS  FD8.0
0066E:  BRA    079C
00670:  BTFSC  FD8.2
00672:  BRA    079C
00674:  MOVFF  68,00
00678:  CLRF   01
0067A:  CLRF   02
0067C:  CLRF   03
0067E:  CLRF   x67
00680:  MOVFF  5D,66
00684:  BSF    x66.7
00686:  MOVFF  5E,65
0068A:  MOVFF  5F,64
0068E:  MOVLW  19
00690:  MOVWF  x68
00692:  MOVF   x63,W
00694:  SUBWF  x64,F
00696:  BC    06B2
00698:  MOVLW  01
0069A:  SUBWF  x65,F
0069C:  BC    06B2
0069E:  SUBWF  x66,F
006A0:  BC    06B2
006A2:  SUBWF  x67,F
006A4:  BC    06B2
006A6:  INCF   x67,F
006A8:  INCF   x66,F
006AA:  INCF   x65,F
006AC:  MOVF   x63,W
006AE:  ADDWF  x64,F
006B0:  BRA    0702
006B2:  MOVF   x62,W
006B4:  SUBWF  x65,F
006B6:  BC    06DC
006B8:  MOVLW  01
006BA:  SUBWF  x66,F
006BC:  BC    06DC
006BE:  SUBWF  x67,F
006C0:  BC    06DC
006C2:  INCF   x67,F
006C4:  INCF   x66,F
006C6:  MOVF   x62,W
006C8:  ADDWF  x65,F
006CA:  MOVF   x63,W
006CC:  ADDWF  x64,F
006CE:  BNC   0702
006D0:  INCF   x65,F
006D2:  BNZ   0702
006D4:  INCF   x66,F
006D6:  BNZ   0702
006D8:  INCF   x67,F
006DA:  BRA    0702
006DC:  MOVF   x61,W
006DE:  IORLW  80
006E0:  SUBWF  x66,F
006E2:  BC    0700
006E4:  MOVLW  01
006E6:  SUBWF  x67,F
006E8:  BC    0700
006EA:  INCF   x67,F
006EC:  MOVF   x61,W
006EE:  IORLW  80
006F0:  ADDWF  x66,F
006F2:  MOVF   x62,W
006F4:  ADDWF  x65,F
006F6:  BNC   06CA
006F8:  INCF   x66,F
006FA:  BNZ   06CA
006FC:  INCF   x67,F
006FE:  BRA    06CA
00700:  BSF    03.0
00702:  DECFSZ x68,F
00704:  BRA    0708
00706:  BRA    071E
00708:  BCF    FD8.0
0070A:  RLCF   x64,F
0070C:  RLCF   x65,F
0070E:  RLCF   x66,F
00710:  RLCF   x67,F
00712:  BCF    FD8.0
00714:  RLCF   03,F
00716:  RLCF   02,F
00718:  RLCF   01,F
0071A:  RLCF   x69,F
0071C:  BRA    0692
0071E:  BTFSS  x69.0
00720:  BRA    072E
00722:  BCF    FD8.0
00724:  RRCF   01,F
00726:  RRCF   02,F
00728:  RRCF   03,F
0072A:  RRCF   x69,F
0072C:  BRA    0732
0072E:  DECF   00,F
00730:  BZ    079C
00732:  BTFSC  x69.7
00734:  BRA    0772
00736:  BCF    FD8.0
00738:  RLCF   x64,F
0073A:  RLCF   x65,F
0073C:  RLCF   x66,F
0073E:  RLCF   x67,F
00740:  MOVF   x63,W
00742:  SUBWF  x64,F
00744:  BC    0754
00746:  MOVLW  01
00748:  SUBWF  x65,F
0074A:  BC    0754
0074C:  SUBWF  x66,F
0074E:  BC    0754
00750:  SUBWF  x67,F
00752:  BNC   0788
00754:  MOVF   x62,W
00756:  SUBWF  x65,F
00758:  BC    0764
0075A:  MOVLW  01
0075C:  SUBWF  x66,F
0075E:  BC    0764
00760:  SUBWF  x67,F
00762:  BNC   0788
00764:  MOVF   x61,W
00766:  IORLW  80
00768:  SUBWF  x66,F
0076A:  BC    0772
0076C:  MOVLW  01
0076E:  SUBWF  x67,F
00770:  BNC   0788
00772:  INCF   03,F
00774:  BNZ   0788
00776:  INCF   02,F
00778:  BNZ   0788
0077A:  INCF   01,F
0077C:  BNZ   0788
0077E:  INCF   00,F
00780:  BZ    079C
00782:  RRCF   01,F
00784:  RRCF   02,F
00786:  RRCF   03,F
00788:  MOVFF  5D,68
0078C:  MOVF   x61,W
0078E:  XORWF  x68,F
00790:  BTFSS  x68.7
00792:  BRA    0798
00794:  BSF    01.7
00796:  BRA    07A4
00798:  BCF    01.7
0079A:  BRA    07A4
0079C:  CLRF   00
0079E:  CLRF   01
007A0:  CLRF   02
007A2:  CLRF   03
007A4:  RETURN 0
007A6:  MOVLW  80
007A8:  BTFSC  FD8.1
007AA:  XORWF  x61,F
007AC:  CLRF   x66
007AE:  CLRF   x67
007B0:  MOVFF  5D,65
007B4:  MOVF   x61,W
007B6:  XORWF  x65,F
007B8:  MOVF   5C,W
007BA:  BTFSC  FD8.2
007BC:  BRA    0976
007BE:  MOVWF  x64
007C0:  MOVWF  00
007C2:  MOVF   x60,W
007C4:  BTFSC  FD8.2
007C6:  BRA    0988
007C8:  SUBWF  x64,F
007CA:  BTFSC  FD8.2
007CC:  BRA    08D0
007CE:  BNC   084A
007D0:  MOVFF  61,6A
007D4:  BSF    x6A.7
007D6:  MOVFF  62,69
007DA:  MOVFF  63,68
007DE:  CLRF   x67
007E0:  BCF    FD8.0
007E2:  RRCF   x6A,F
007E4:  RRCF   x69,F
007E6:  RRCF   x68,F
007E8:  RRCF   x67,F
007EA:  DECFSZ x64,F
007EC:  BRA    07DE
007EE:  BTFSS  x65.7
007F0:  BRA    07F8
007F2:  BSF    x66.0
007F4:  BRA    09B0
007F6:  BCF    x66.0
007F8:  BCF    x64.0
007FA:  BSF    x66.4
007FC:  CLRF   FEA
007FE:  MOVLW  5F
00800:  MOVWF  FE9
00802:  BRA    09D6
00804:  BCF    x66.4
00806:  BTFSC  x65.7
00808:  BRA    081E
0080A:  BTFSS  x64.0
0080C:  BRA    0834
0080E:  RRCF   x6A,F
00810:  RRCF   x69,F
00812:  RRCF   x68,F
00814:  RRCF   x67,F
00816:  INCF   00,F
00818:  BTFSC  FD8.2
0081A:  BRA    09A6
0081C:  BRA    0834
0081E:  BTFSC  x6A.7
00820:  BRA    083A
00822:  BCF    FD8.0
00824:  RLCF   x67,F
00826:  RLCF   x68,F
00828:  RLCF   x69,F
0082A:  RLCF   x6A,F
0082C:  DECF   00,F
0082E:  BTFSC  FD8.2
00830:  BRA    09A6
00832:  BRA    081E
00834:  BSF    x66.6
00836:  BRA    090E
00838:  BCF    x66.6
0083A:  MOVFF  5D,65
0083E:  BTFSS  5D.7
00840:  BRA    0846
00842:  BSF    x6A.7
00844:  BRA    0998
00846:  BCF    x6A.7
00848:  BRA    0998
0084A:  MOVFF  60,64
0084E:  MOVFF  60,00
00852:  MOVF   5C,W
00854:  SUBWF  x64,F
00856:  MOVFF  5D,6A
0085A:  BSF    x6A.7
0085C:  MOVFF  5E,69
00860:  MOVFF  5F,68
00864:  CLRF   x67
00866:  BCF    FD8.0
00868:  RRCF   x6A,F
0086A:  RRCF   x69,F
0086C:  RRCF   x68,F
0086E:  RRCF   x67,F
00870:  DECFSZ x64,F
00872:  BRA    0864
00874:  BTFSS  x65.7
00876:  BRA    087E
00878:  BSF    x66.1
0087A:  BRA    09B0
0087C:  BCF    x66.1
0087E:  BCF    x64.0
00880:  BSF    x66.5
00882:  CLRF   FEA
00884:  MOVLW  63
00886:  MOVWF  FE9
00888:  BRA    09D6
0088A:  BCF    x66.5
0088C:  BTFSC  x65.7
0088E:  BRA    08A4
00890:  BTFSS  x64.0
00892:  BRA    08BA
00894:  RRCF   x6A,F
00896:  RRCF   x69,F
00898:  RRCF   x68,F
0089A:  RRCF   x67,F
0089C:  INCF   00,F
0089E:  BTFSC  FD8.2
008A0:  BRA    09A6
008A2:  BRA    08BA
008A4:  BTFSC  x6A.7
008A6:  BRA    08C0
008A8:  BCF    FD8.0
008AA:  RLCF   x67,F
008AC:  RLCF   x68,F
008AE:  RLCF   x69,F
008B0:  RLCF   x6A,F
008B2:  DECF   00,F
008B4:  BTFSC  FD8.2
008B6:  BRA    09A6
008B8:  BRA    08A4
008BA:  BSF    x66.7
008BC:  BRA    090E
008BE:  BCF    x66.7
008C0:  MOVFF  61,65
008C4:  BTFSS  x61.7
008C6:  BRA    08CC
008C8:  BSF    x6A.7
008CA:  BRA    0998
008CC:  BCF    x6A.7
008CE:  BRA    0998
008D0:  MOVFF  61,6A
008D4:  BSF    x6A.7
008D6:  MOVFF  62,69
008DA:  MOVFF  63,68
008DE:  BTFSS  x65.7
008E0:  BRA    08EA
008E2:  BCF    x6A.7
008E4:  BSF    x66.2
008E6:  BRA    09B0
008E8:  BCF    x66.2
008EA:  CLRF   x67
008EC:  BCF    x64.0
008EE:  CLRF   FEA
008F0:  MOVLW  5F
008F2:  MOVWF  FE9
008F4:  BRA    09D6
008F6:  BTFSC  x65.7
008F8:  BRA    0932
008FA:  MOVFF  5D,65
008FE:  BTFSS  x64.0
00900:  BRA    090E
00902:  RRCF   x6A,F
00904:  RRCF   x69,F
00906:  RRCF   x68,F
00908:  RRCF   x67,F
0090A:  INCF   00,F
0090C:  BZ    09A6
0090E:  BTFSS  x67.7
00910:  BRA    0928
00912:  INCF   x68,F
00914:  BNZ   0928
00916:  INCF   x69,F
00918:  BNZ   0928
0091A:  INCF   x6A,F
0091C:  BNZ   0928
0091E:  RRCF   x6A,F
00920:  RRCF   x69,F
00922:  RRCF   x68,F
00924:  INCF   00,F
00926:  BZ    09A6
00928:  BTFSC  x66.6
0092A:  BRA    0838
0092C:  BTFSC  x66.7
0092E:  BRA    08BE
00930:  BRA    096A
00932:  MOVLW  80
00934:  XORWF  x6A,F
00936:  BTFSS  x6A.7
00938:  BRA    0942
0093A:  BRA    09B0
0093C:  MOVFF  61,65
00940:  BRA    0956
00942:  MOVFF  5D,65
00946:  MOVF   x6A,F
00948:  BNZ   0956
0094A:  MOVF   x69,F
0094C:  BNZ   0956
0094E:  MOVF   x68,F
00950:  BNZ   0956
00952:  CLRF   00
00954:  BRA    0998
00956:  BTFSC  x6A.7
00958:  BRA    096A
0095A:  BCF    FD8.0
0095C:  RLCF   x67,F
0095E:  RLCF   x68,F
00960:  RLCF   x69,F
00962:  RLCF   x6A,F
00964:  DECFSZ 00,F
00966:  BRA    0956
00968:  BRA    09A6
0096A:  BTFSS  x65.7
0096C:  BRA    0972
0096E:  BSF    x6A.7
00970:  BRA    0998
00972:  BCF    x6A.7
00974:  BRA    0998
00976:  MOVFF  60,00
0097A:  MOVFF  61,6A
0097E:  MOVFF  62,69
00982:  MOVFF  63,68
00986:  BRA    0998
00988:  MOVFF  5C,00
0098C:  MOVFF  5D,6A
00990:  MOVFF  5E,69
00994:  MOVFF  5F,68
00998:  MOVFF  6A,01
0099C:  MOVFF  69,02
009A0:  MOVFF  68,03
009A4:  BRA    0A0E
009A6:  CLRF   00
009A8:  CLRF   01
009AA:  CLRF   02
009AC:  CLRF   03
009AE:  BRA    0A0E
009B0:  CLRF   x67
009B2:  COMF   x68,F
009B4:  COMF   x69,F
009B6:  COMF   x6A,F
009B8:  COMF   x67,F
009BA:  INCF   x67,F
009BC:  BNZ   09C8
009BE:  INCF   x68,F
009C0:  BNZ   09C8
009C2:  INCF   x69,F
009C4:  BNZ   09C8
009C6:  INCF   x6A,F
009C8:  BTFSC  x66.0
009CA:  BRA    07F6
009CC:  BTFSC  x66.1
009CE:  BRA    087C
009D0:  BTFSC  x66.2
009D2:  BRA    08E8
009D4:  BRA    093C
009D6:  MOVF   FEF,W
009D8:  ADDWF  x68,F
009DA:  BNC   09E6
009DC:  INCF   x69,F
009DE:  BNZ   09E6
009E0:  INCF   x6A,F
009E2:  BTFSC  FD8.2
009E4:  BSF    x64.0
009E6:  MOVF   FED,F
009E8:  MOVF   FEF,W
009EA:  ADDWF  x69,F
009EC:  BNC   09F4
009EE:  INCF   x6A,F
009F0:  BTFSC  FD8.2
009F2:  BSF    x64.0
009F4:  MOVF   FED,F
009F6:  MOVF   FEF,W
009F8:  BTFSC  FEF.7
009FA:  BRA    09FE
009FC:  XORLW  80
009FE:  ADDWF  x6A,F
00A00:  BTFSC  FD8.0
00A02:  BSF    x64.0
00A04:  BTFSC  x66.4
00A06:  BRA    0804
00A08:  BTFSC  x66.5
00A0A:  BRA    088A
00A0C:  BRA    08F6
00A0E:  RETURN 0
00A10:  MOVFF  59,60
00A14:  MOVF   5D,W
00A16:  XORWF  x60,F
00A18:  BTFSS  x60.7
00A1A:  BRA    0A26
00A1C:  BCF    FD8.2
00A1E:  BCF    FD8.0
00A20:  BTFSC  59.7
00A22:  BSF    FD8.0
00A24:  BRA    0A84
00A26:  MOVFF  59,60
00A2A:  MOVFF  5C,61
00A2E:  MOVF   58,W
00A30:  SUBWF  x61,F
00A32:  BZ    0A40
00A34:  BTFSS  x60.7
00A36:  BRA    0A84
00A38:  MOVF   FD8,W
00A3A:  XORLW  01
00A3C:  MOVWF  FD8
00A3E:  BRA    0A84
00A40:  MOVFF  5D,61
00A44:  MOVF   59,W
00A46:  SUBWF  x61,F
00A48:  BZ    0A56
00A4A:  BTFSS  x60.7
00A4C:  BRA    0A84
00A4E:  MOVF   FD8,W
00A50:  XORLW  01
00A52:  MOVWF  FD8
00A54:  BRA    0A84
00A56:  MOVFF  5E,61
00A5A:  MOVF   5A,W
00A5C:  SUBWF  x61,F
00A5E:  BZ    0A6C
00A60:  BTFSS  x60.7
00A62:  BRA    0A84
00A64:  MOVF   FD8,W
00A66:  XORLW  01
00A68:  MOVWF  FD8
00A6A:  BRA    0A84
00A6C:  MOVFF  5F,61
00A70:  MOVF   5B,W
00A72:  SUBWF  x61,F
00A74:  BZ    0A82
00A76:  BTFSS  x60.7
00A78:  BRA    0A84
00A7A:  MOVF   FD8,W
00A7C:  XORLW  01
00A7E:  MOVWF  FD8
00A80:  BRA    0A84
00A82:  BCF    FD8.0
00A84:  GOTO   0ADC (RETURN)
00A88:  MOVLW  8E
00A8A:  MOVWF  00
00A8C:  MOVF   58,W
00A8E:  SUBWF  00,F
00A90:  MOVFF  59,02
00A94:  MOVFF  5A,01
00A98:  BSF    02.7
00A9A:  MOVF   00,F
00A9C:  BZ    0AB0
00A9E:  BCF    FD8.0
00AA0:  MOVF   02,F
00AA2:  BNZ   0AA8
00AA4:  MOVF   01,F
00AA6:  BZ    0AB0
00AA8:  RRCF   02,F
00AAA:  RRCF   01,F
00AAC:  DECFSZ 00,F
00AAE:  BRA    0A9E
00AB0:  BTFSS  59.7
00AB2:  BRA    0ABE
00AB4:  COMF   01,F
00AB6:  COMF   02,F
00AB8:  INCF   01,F
00ABA:  BTFSC  FD8.2
00ABC:  INCF   02,F
00ABE:  GOTO   0C06 (RETURN)
.................... 
.................... #list
.................... 
.................... #fuses      INTRC, NOWDT, NOPROTECT, NOLVP, NOMCLR, CCP2C1, CCP3B5      // Fusibles (Multiplexado de P2B en C0)
.................... #use        delay(internal = 16MHz)                                     // Configuracion de frecuencia y delay
*
00438:  CLRF   FEA
0043A:  MOVLW  3F
0043C:  MOVWF  FE9
0043E:  MOVF   FEF,W
00440:  BZ    045E
00442:  MOVLW  05
00444:  MOVWF  01
00446:  CLRF   00
00448:  DECFSZ 00,F
0044A:  BRA    0448
0044C:  DECFSZ 01,F
0044E:  BRA    0446
00450:  MOVLW  2E
00452:  MOVWF  00
00454:  DECFSZ 00,F
00456:  BRA    0454
00458:  BRA    045A
0045A:  DECFSZ FEF,F
0045C:  BRA    0442
0045E:  GOTO   1104 (RETURN)
.................... #use        rs232(rcv = pin_c7, xmit = pin_c6, baud = 9600, bits = 8, parity = n) 
.................... 
.................... #include    <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
00100:  CLRF   x8D
....................    sign = 0;
00102:  CLRF   x8B
....................    base = 10;
00104:  MOVLW  0A
00106:  MOVWF  x8C
....................    result = 0;
00108:  CLRF   x8A
0010A:  CLRF   x89
.................... 
....................    if (!s)
0010C:  MOVF   x87,W
0010E:  IORWF  x88,W
00110:  BNZ   011A
....................       return 0;
00112:  MOVLW  00
00114:  MOVWF  01
00116:  MOVWF  02
00118:  BRA    02D0
....................    c = s[index++];
0011A:  MOVF   x8D,W
0011C:  INCF   x8D,F
0011E:  ADDWF  x87,W
00120:  MOVWF  FE9
00122:  MOVLW  00
00124:  ADDWFC x88,W
00126:  MOVWF  FEA
00128:  MOVFF  FEF,8E
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
0012C:  MOVF   x8E,W
0012E:  SUBLW  2D
00130:  BNZ   014A
....................    {
....................       sign = 1;         // Set the sign to negative
00132:  MOVLW  01
00134:  MOVWF  x8B
....................       c = s[index++];
00136:  MOVF   x8D,W
00138:  INCF   x8D,F
0013A:  ADDWF  x87,W
0013C:  MOVWF  FE9
0013E:  MOVLW  00
00140:  ADDWFC x88,W
00142:  MOVWF  FEA
00144:  MOVFF  FEF,8E
....................    }
00148:  BRA    0162
....................    else if (c == '+')
0014A:  MOVF   x8E,W
0014C:  SUBLW  2B
0014E:  BNZ   0162
....................    {
....................       c = s[index++];
00150:  MOVF   x8D,W
00152:  INCF   x8D,F
00154:  ADDWF  x87,W
00156:  MOVWF  FE9
00158:  MOVLW  00
0015A:  ADDWFC x88,W
0015C:  MOVWF  FEA
0015E:  MOVFF  FEF,8E
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
00162:  MOVF   x8E,W
00164:  SUBLW  2F
00166:  BTFSC  FD8.0
00168:  BRA    02B4
0016A:  MOVF   x8E,W
0016C:  SUBLW  39
0016E:  BTFSS  FD8.0
00170:  BRA    02B4
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
00172:  MOVF   x8E,W
00174:  SUBLW  30
00176:  BNZ   01B4
00178:  MOVF   x8D,W
0017A:  ADDWF  x87,W
0017C:  MOVWF  FE9
0017E:  MOVLW  00
00180:  ADDWFC x88,W
00182:  MOVWF  FEA
00184:  MOVF   FEF,W
00186:  SUBLW  78
00188:  BZ    019C
0018A:  MOVF   x8D,W
0018C:  ADDWF  x87,W
0018E:  MOVWF  FE9
00190:  MOVLW  00
00192:  ADDWFC x88,W
00194:  MOVWF  FEA
00196:  MOVF   FEF,W
00198:  SUBLW  58
0019A:  BNZ   01B4
....................       {
....................          base = 16;
0019C:  MOVLW  10
0019E:  MOVWF  x8C
....................          index++;
001A0:  INCF   x8D,F
....................          c = s[index++];
001A2:  MOVF   x8D,W
001A4:  INCF   x8D,F
001A6:  ADDWF  x87,W
001A8:  MOVWF  FE9
001AA:  MOVLW  00
001AC:  ADDWFC x88,W
001AE:  MOVWF  FEA
001B0:  MOVFF  FEF,8E
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
001B4:  MOVF   x8C,W
001B6:  SUBLW  0A
001B8:  BNZ   01FA
....................       {
....................          while (c >= '0' && c <= '9')
001BA:  MOVF   x8E,W
001BC:  SUBLW  2F
001BE:  BC    01F8
001C0:  MOVF   x8E,W
001C2:  SUBLW  39
001C4:  BNC   01F8
....................          {
....................             result = 10*result + (c - '0');
001C6:  CLRF   x90
001C8:  MOVLW  0A
001CA:  MOVWF  x8F
001CC:  MOVFF  8A,92
001D0:  MOVFF  89,91
001D4:  BRA    00AE
001D6:  MOVLW  30
001D8:  SUBWF  x8E,W
001DA:  ADDWF  01,W
001DC:  MOVWF  x89
001DE:  MOVLW  00
001E0:  ADDWFC 02,W
001E2:  MOVWF  x8A
....................             c = s[index++];
001E4:  MOVF   x8D,W
001E6:  INCF   x8D,F
001E8:  ADDWF  x87,W
001EA:  MOVWF  FE9
001EC:  MOVLW  00
001EE:  ADDWFC x88,W
001F0:  MOVWF  FEA
001F2:  MOVFF  FEF,8E
001F6:  BRA    01BA
....................          }
....................       }
001F8:  BRA    02B4
....................       else if (base == 16)    // The number is a hexa number
001FA:  MOVF   x8C,W
001FC:  SUBLW  10
001FE:  BNZ   02B4
....................       {
....................          c = toupper(c);
00200:  MOVF   x8E,W
00202:  SUBLW  60
00204:  BC    0212
00206:  MOVF   x8E,W
00208:  SUBLW  7A
0020A:  BNC   0212
0020C:  MOVF   x8E,W
0020E:  ANDLW  DF
00210:  BRA    0214
00212:  MOVF   x8E,W
00214:  MOVWF  x8E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
00216:  MOVF   x8E,W
00218:  SUBLW  2F
0021A:  BC    0222
0021C:  MOVF   x8E,W
0021E:  SUBLW  39
00220:  BC    022E
00222:  MOVF   x8E,W
00224:  SUBLW  40
00226:  BC    02B4
00228:  MOVF   x8E,W
0022A:  SUBLW  46
0022C:  BNC   02B4
....................          {
....................             if (c >= '0' && c <= '9')
0022E:  MOVF   x8E,W
00230:  SUBLW  2F
00232:  BC    0262
00234:  MOVF   x8E,W
00236:  SUBLW  39
00238:  BNC   0262
....................                result = (result << 4) + (c - '0');
0023A:  RLCF   x89,W
0023C:  MOVWF  x8F
0023E:  RLCF   x8A,W
00240:  MOVWF  x90
00242:  RLCF   x8F,F
00244:  RLCF   x90,F
00246:  RLCF   x8F,F
00248:  RLCF   x90,F
0024A:  RLCF   x8F,F
0024C:  RLCF   x90,F
0024E:  MOVLW  F0
00250:  ANDWF  x8F,F
00252:  MOVLW  30
00254:  SUBWF  x8E,W
00256:  ADDWF  x8F,W
00258:  MOVWF  x89
0025A:  MOVLW  00
0025C:  ADDWFC x90,W
0025E:  MOVWF  x8A
00260:  BRA    028A
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
00262:  RLCF   x89,W
00264:  MOVWF  x8F
00266:  RLCF   x8A,W
00268:  MOVWF  x90
0026A:  RLCF   x8F,F
0026C:  RLCF   x90,F
0026E:  RLCF   x8F,F
00270:  RLCF   x90,F
00272:  RLCF   x8F,F
00274:  RLCF   x90,F
00276:  MOVLW  F0
00278:  ANDWF  x8F,F
0027A:  MOVLW  41
0027C:  SUBWF  x8E,W
0027E:  ADDLW  0A
00280:  ADDWF  x8F,W
00282:  MOVWF  x89
00284:  MOVLW  00
00286:  ADDWFC x90,W
00288:  MOVWF  x8A
.................... 
....................             c = s[index++];c = toupper(c);
0028A:  MOVF   x8D,W
0028C:  INCF   x8D,F
0028E:  ADDWF  x87,W
00290:  MOVWF  FE9
00292:  MOVLW  00
00294:  ADDWFC x88,W
00296:  MOVWF  FEA
00298:  MOVFF  FEF,8E
0029C:  MOVF   x8E,W
0029E:  SUBLW  60
002A0:  BC    02AE
002A2:  MOVF   x8E,W
002A4:  SUBLW  7A
002A6:  BNC   02AE
002A8:  MOVF   x8E,W
002AA:  ANDLW  DF
002AC:  BRA    02B0
002AE:  MOVF   x8E,W
002B0:  MOVWF  x8E
002B2:  BRA    0216
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
002B4:  MOVF   x8C,W
002B6:  SUBLW  0A
002B8:  BNZ   02C8
002BA:  DECFSZ x8B,W
002BC:  BRA    02C8
....................       result = -result;
002BE:  COMF   x89,F
002C0:  COMF   x8A,F
002C2:  INCF   x89,F
002C4:  BTFSC  FD8.2
002C6:  INCF   x8A,F
.................... 
....................    return(result);
002C8:  MOVFF  89,01
002CC:  MOVFF  8A,02
002D0:  RETURN 0
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include    "motor_control.c"
.................... #define     FORWARD     1
.................... #define     BACK        0
.................... 
.................... #define     max_dutycicle       320
.................... #define     min_dutycicle       max_dutycicle / 15
.................... 
.................... #define     max_trigger_value   255
.................... #define     max_joystick_value  32767.0
.................... 
.................... // -------------------- Direcciones de registros -------------------- //
.................... #BYTE       CCPTMRS0        = 0xF49
.................... #BYTE       CCPTMRS1        = 0xF48
.................... 
.................... #BYTE       CCP1CON         = 0xFBD
.................... #BYTE       CCP2CON         = 0xF66
.................... #BYTE       CCP3CON         = 0xF5D
.................... #BYTE       CCP4CON         = 0xF57
.................... 
.................... #BYTE       T2CON           = 0xFBA
.................... #BYTE       PR2             = 0xFBB
.................... 
.................... // -------------------------- Estructuras --------------------------- //
.................... struct bth_conection_t
.................... {
....................     short updated_data;
....................     short IsConnected;
.................... };
.................... 
.................... struct motor_t
.................... {
....................     int     *DutyCicle;
....................     long    IN1_pin;
....................     long    IN2_pin;
.................... };
.................... 
.................... struct controller_t
.................... {
....................     signed long     Joystick[2];    // Entero de -32768 a 32767 (0 eje x, 1 eje y)
....................     int             Triggers[2];    // Entero de 0 a 255 (0 izquierdo, 1 derecho)
.................... };
.................... 
.................... // ---------------------------- Funciones --------------------------- //
.................... void motors_init(struct motor_t tires[2][2])
.................... {
....................     // Configuracion de Timers
....................     T2CON       = 0b00000100;
*
003B8:  MOVLW  04
003BA:  MOVWF  FBA
....................     PR2         = 79;
003BC:  MOVLW  4F
003BE:  MOVWF  FBB
....................     
....................     // Configuracion de CCPXCON para PWM
....................     CCPTMRS0 = CCPTMRS0 = 0b00000000;       // Configuramos CCPX con timer 2
003C0:  MOVLB  F
003C2:  CLRF   x49
....................     
....................     // Configiracion de modulo CCPX para PWM
....................     CCP4CON = 0b00001100, CCP3CON = 0b00001100, CCP2CON = 0b00001100, CCP1CON = 0b00001100;
003C4:  MOVLW  0C
003C6:  MOVWF  x57
003C8:  MOVWF  x5D
003CA:  MOVWF  F66
003CC:  MOVWF  FBD
.................... 
....................     for(int i = 0; i < 2 ; i++)
003CE:  CLRF   41
003D0:  MOVF   41,W
003D2:  SUBLW  01
003D4:  BNC   0432
....................         for(int j = 0; j < 2; j++)
003D6:  CLRF   42
003D8:  MOVF   42,W
003DA:  SUBLW  01
003DC:  BNC   042E
....................             *(tires[i][j].DutyCicle) = 0;
003DE:  CLRF   46
003E0:  MOVFF  41,45
003E4:  CLRF   48
003E6:  MOVLW  0C
003E8:  MOVWF  47
003EA:  MOVLB  0
003EC:  RCALL  039A
003EE:  MOVFF  02,44
003F2:  MOVFF  01,43
003F6:  CLRF   46
003F8:  MOVFF  42,45
003FC:  CLRF   48
003FE:  MOVLW  06
00400:  MOVWF  47
00402:  RCALL  039A
00404:  MOVF   01,W
00406:  ADDWF  43,F
00408:  MOVF   02,W
0040A:  ADDWFC 44,F
0040C:  MOVF   3F,W
0040E:  ADDWF  43,W
00410:  MOVWF  FE9
00412:  MOVF   40,W
00414:  ADDWFC 44,W
00416:  MOVWF  FEA
00418:  MOVFF  FEC,03
0041C:  MOVF   FED,F
0041E:  MOVFF  FEF,FE9
00422:  MOVFF  03,FEA
00426:  CLRF   FEF
00428:  INCF   42,F
0042A:  MOVLB  F
0042C:  BRA    03D8
0042E:  INCF   41,F
00430:  BRA    03D0
00432:  MOVLB  0
00434:  GOTO   10DA (RETURN)
.................... }
.................... 
.................... void motor_movement(struct motor_t *motor, float speed)   // Modo de movimiento normal
*
00AC2:  CLRF   5B
00AC4:  CLRF   5A
00AC6:  CLRF   59
00AC8:  CLRF   58
00ACA:  MOVFF  54,5F
00ACE:  MOVFF  53,5E
00AD2:  MOVFF  52,5D
00AD6:  MOVFF  51,5C
00ADA:  BRA    0A10
00ADC:  BC    0AE0
00ADE:  BNZ   0AE4
00AE0:  MOVLW  01
00AE2:  BRA    0AE6
00AE4:  MOVLW  00
00AE6:  BCF    55.0
00AE8:  BTFSC  FE8.0
00AEA:  BSF    55.0
.................... {
....................     short direction = (speed >= 0) ? FORWARD : BACK;
....................     
....................     // Establecemos direccion de giro
....................     output_bit(motor->IN1_pin, direction);
00AEC:  MOVLW  02
00AEE:  ADDWF  4F,W
00AF0:  MOVWF  FE9
00AF2:  MOVLW  00
00AF4:  ADDWFC 50,W
00AF6:  MOVWF  FEA
00AF8:  MOVFF  FEC,59
00AFC:  MOVF   FED,F
00AFE:  MOVFF  FEF,58
00B02:  MOVLW  00
00B04:  BTFSC  55.0
00B06:  MOVLW  01
00B08:  MOVFF  58,5A
00B0C:  MOVWF  5B
00B0E:  MOVLW  0F
00B10:  MOVWF  5D
00B12:  MOVLW  89
00B14:  MOVWF  5C
00B16:  RCALL  0462
00B18:  MOVFF  58,5A
00B1C:  CLRF   5B
00B1E:  MOVLW  0F
00B20:  MOVWF  5D
00B22:  MOVLW  92
00B24:  MOVWF  5C
00B26:  RCALL  0462
....................     output_bit(motor->IN2_pin, !direction);
00B28:  MOVLW  04
00B2A:  ADDWF  4F,W
00B2C:  MOVWF  FE9
00B2E:  MOVLW  00
00B30:  ADDWFC 50,W
00B32:  MOVWF  FEA
00B34:  MOVFF  FEC,59
00B38:  MOVF   FED,F
00B3A:  MOVFF  FEF,58
00B3E:  MOVLW  00
00B40:  BTFSS  55.0
00B42:  MOVLW  01
00B44:  MOVFF  58,5A
00B48:  MOVWF  5B
00B4A:  MOVLW  0F
00B4C:  MOVWF  5D
00B4E:  MOVLW  89
00B50:  MOVWF  5C
00B52:  RCALL  0462
00B54:  MOVFF  58,5A
00B58:  CLRF   5B
00B5A:  MOVLW  0F
00B5C:  MOVWF  5D
00B5E:  MOVLW  92
00B60:  MOVWF  5C
00B62:  RCALL  0462
....................     
....................     // Establecemos DC para velocidad
....................     long aux = ((max_dutycicle - min_dutycicle) * abs(speed) / 100) + min_dutycicle;
00B64:  MOVFF  51,00
00B68:  MOVFF  52,01
00B6C:  MOVFF  53,02
00B70:  MOVFF  54,03
00B74:  BCF    01.7
00B76:  CLRF   5B
00B78:  MOVLW  80
00B7A:  MOVWF  5A
00B7C:  MOVLW  15
00B7E:  MOVWF  59
00B80:  MOVLW  87
00B82:  MOVWF  58
00B84:  MOVFF  54,5F
00B88:  MOVFF  53,5E
00B8C:  MOVFF  01,5D
00B90:  MOVFF  51,5C
00B94:  RCALL  055A
00B96:  MOVFF  03,5B
00B9A:  MOVFF  02,5A
00B9E:  MOVFF  01,59
00BA2:  MOVFF  00,58
00BA6:  MOVFF  03,5F
00BAA:  MOVFF  02,5E
00BAE:  MOVFF  01,5D
00BB2:  MOVFF  00,5C
00BB6:  CLRF   x63
00BB8:  CLRF   x62
00BBA:  MOVLW  48
00BBC:  MOVWF  x61
00BBE:  MOVLW  85
00BC0:  MOVWF  x60
00BC2:  RCALL  064C
00BC4:  MOVFF  03,5B
00BC8:  MOVFF  02,5A
00BCC:  MOVFF  01,59
00BD0:  MOVFF  00,58
00BD4:  BCF    FD8.1
00BD6:  MOVFF  03,5F
00BDA:  MOVFF  02,5E
00BDE:  MOVFF  01,5D
00BE2:  MOVFF  00,5C
00BE6:  CLRF   x63
00BE8:  CLRF   x62
00BEA:  MOVLW  28
00BEC:  MOVWF  x61
00BEE:  MOVLW  83
00BF0:  MOVWF  x60
00BF2:  RCALL  07A6
00BF4:  MOVFF  03,5B
00BF8:  MOVFF  02,5A
00BFC:  MOVFF  01,59
00C00:  MOVFF  00,58
00C04:  BRA    0A88
00C06:  MOVFF  02,57
00C0A:  MOVFF  01,56
....................     *(motor->DutyCicle) = aux >> 2;
00C0E:  MOVFF  4F,FE9
00C12:  MOVFF  50,FEA
00C16:  MOVFF  FEC,03
00C1A:  MOVF   FED,F
00C1C:  MOVFF  FEF,FE9
00C20:  MOVFF  03,FEA
00C24:  RRCF   57,W
00C26:  MOVWF  03
00C28:  RRCF   56,W
00C2A:  MOVWF  02
00C2C:  RRCF   03,F
00C2E:  RRCF   02,F
00C30:  MOVLW  3F
00C32:  ANDWF  03,F
00C34:  MOVFF  02,FEF
00C38:  RETURN 0
.................... }
.................... 
.................... void motor_movement(struct motor_t *motor)    // Modo de freno de corto (Solo para emergencias)
.................... {
....................     output_high(motor->IN1_pin);
*
004A0:  MOVLW  02
004A2:  ADDWF  4F,W
004A4:  MOVWF  FE9
004A6:  MOVLW  00
004A8:  ADDWFC 50,W
004AA:  MOVWF  FEA
004AC:  MOVFF  FEC,52
004B0:  MOVF   FED,F
004B2:  MOVFF  FEF,51
004B6:  MOVFF  51,5A
004BA:  MOVLW  01
004BC:  MOVWF  5B
004BE:  MOVLW  0F
004C0:  MOVWF  5D
004C2:  MOVLW  89
004C4:  MOVWF  5C
004C6:  RCALL  0462
004C8:  MOVFF  51,5A
004CC:  CLRF   5B
004CE:  MOVLW  0F
004D0:  MOVWF  5D
004D2:  MOVLW  92
004D4:  MOVWF  5C
004D6:  RCALL  0462
....................     output_high(motor->IN2_pin);
004D8:  MOVLW  04
004DA:  ADDWF  4F,W
004DC:  MOVWF  FE9
004DE:  MOVLW  00
004E0:  ADDWFC 50,W
004E2:  MOVWF  FEA
004E4:  MOVFF  FEC,52
004E8:  MOVF   FED,F
004EA:  MOVFF  FEF,51
004EE:  MOVFF  51,5A
004F2:  MOVLW  01
004F4:  MOVWF  5B
004F6:  MOVLW  0F
004F8:  MOVWF  5D
004FA:  MOVLW  89
004FC:  MOVWF  5C
004FE:  RCALL  0462
00500:  MOVFF  51,5A
00504:  CLRF   5B
00506:  MOVLW  0F
00508:  MOVWF  5D
0050A:  MOVLW  92
0050C:  MOVWF  5C
0050E:  RCALL  0462
00510:  RETURN 0
.................... }
.................... 
.................... void drive_tires(struct controller_t *xbox_controller, struct motor_t tires[2][2])
.................... {    
....................     // Si estan presionados los 2 al maximo, aplicamos freno de corto y salimos de funcion
....................     if((xbox_controller->Triggers[0] == 255) && (xbox_controller->Triggers[1] == 255))
*
00C3A:  MOVLW  04
00C3C:  ADDWF  3F,W
00C3E:  MOVWF  FE9
00C40:  MOVLW  00
00C42:  ADDWFC 40,W
00C44:  MOVWF  FEA
00C46:  INCFSZ FEF,W
00C48:  BRA    0CBE
00C4A:  MOVLW  05
00C4C:  ADDWF  3F,W
00C4E:  MOVWF  FE9
00C50:  MOVLW  00
00C52:  ADDWFC 40,W
00C54:  MOVWF  FEA
00C56:  INCFSZ FEF,W
00C58:  BRA    0CBE
....................     {
....................         // Activamos modo short brake
....................         motor_movement(&tires[0][0]), motor_movement(&tires[0][1]);
00C5A:  MOVFF  41,01
00C5E:  MOVFF  42,03
00C62:  MOVFF  42,50
00C66:  MOVFF  41,4F
00C6A:  RCALL  04A0
00C6C:  MOVLW  06
00C6E:  ADDWF  41,W
00C70:  MOVWF  01
00C72:  MOVLW  00
00C74:  ADDWFC 42,W
00C76:  MOVWF  03
00C78:  MOVFF  01,4D
00C7C:  MOVWF  4E
00C7E:  MOVWF  50
00C80:  MOVFF  01,4F
00C84:  RCALL  04A0
....................         motor_movement(&tires[1][0]), motor_movement(&tires[1][1]);
00C86:  MOVLW  0C
00C88:  ADDWF  41,W
00C8A:  MOVWF  01
00C8C:  MOVLW  00
00C8E:  ADDWFC 42,W
00C90:  MOVWF  03
00C92:  MOVFF  01,4D
00C96:  MOVWF  4E
00C98:  MOVWF  50
00C9A:  MOVFF  01,4F
00C9E:  RCALL  04A0
00CA0:  MOVLW  12
00CA2:  ADDWF  41,W
00CA4:  MOVWF  01
00CA6:  MOVLW  00
00CA8:  ADDWFC 42,W
00CAA:  MOVWF  03
00CAC:  MOVFF  01,4D
00CB0:  MOVWF  4E
00CB2:  MOVWF  50
00CB4:  MOVFF  01,4F
00CB8:  CALL   04A0
....................         return;
00CBC:  BRA    1032
....................     }
.................... 
....................     /*  Notas para comprender
....................     * Llanta contraria al giro, avanza con normalidad a la velocidad indicada (speed)
....................     * Llanta de apoyo, gira a menor velocidad en funcion de que tan desviado hacia la direccion esta el joystick 
....................         ∵ (-speed < turning_speed < speed)
....................     */
.................... 
....................     // Si no se aplico freno de corto, calculamos velocidad y direccion de movimiento
....................     
....................     float speed[2];
....................     signed long trigger_diff = (signed long) xbox_controller->Triggers[1] - xbox_controller->Triggers[0];
00CBE:  MOVLW  05
00CC0:  ADDWF  3F,W
00CC2:  MOVWF  FE9
00CC4:  MOVLW  00
00CC6:  ADDWFC 40,W
00CC8:  MOVWF  FEA
00CCA:  MOVF   FEF,W
00CCC:  CLRF   4E
00CCE:  MOVWF  4D
00CD0:  MOVLW  04
00CD2:  ADDWF  3F,W
00CD4:  MOVWF  FE9
00CD6:  MOVLW  00
00CD8:  ADDWFC 40,W
00CDA:  MOVWF  FEA
00CDC:  MOVF   FEF,W
00CDE:  SUBWF  4D,W
00CE0:  MOVWF  4B
00CE2:  MOVLW  00
00CE4:  SUBWFB 4E,W
00CE6:  MOVWF  4C
.................... 
....................     if(xbox_controller->Joystick[0] >= 0)        // El movimiento es a la derecha o al centro
00CE8:  MOVFF  3F,FE9
00CEC:  MOVFF  40,FEA
00CF0:  MOVFF  FEC,4E
00CF4:  MOVF   FED,F
00CF6:  MOVFF  FEF,4D
00CFA:  BTFSC  4E.7
00CFC:  BRA    0E46
....................     {
....................         speed[0] = trigger_diff * 100.0 / max_trigger_value;
00CFE:  MOVFF  4C,52
00D02:  MOVFF  4B,51
00D06:  RCALL  0512
00D08:  MOVFF  03,5B
00D0C:  MOVFF  02,5A
00D10:  MOVFF  01,59
00D14:  MOVFF  00,58
00D18:  CLRF   5F
00D1A:  CLRF   5E
00D1C:  MOVLW  48
00D1E:  MOVWF  5D
00D20:  MOVLW  85
00D22:  MOVWF  5C
00D24:  RCALL  055A
00D26:  MOVFF  03,50
00D2A:  MOVFF  02,4F
00D2E:  MOVFF  01,4E
00D32:  MOVFF  00,4D
00D36:  MOVFF  03,5F
00D3A:  MOVFF  02,5E
00D3E:  MOVFF  01,5D
00D42:  MOVFF  00,5C
00D46:  CLRF   x63
00D48:  CLRF   x62
00D4A:  MOVLW  7F
00D4C:  MOVWF  x61
00D4E:  MOVLW  86
00D50:  MOVWF  x60
00D52:  RCALL  064C
00D54:  MOVFF  03,46
00D58:  MOVFF  02,45
00D5C:  MOVFF  01,44
00D60:  MOVFF  00,43
....................         // Flotante de -100 a 100 que indica la velocidad y direccion de movimiento (+ adelante, - atras)
....................         speed[1] = speed[0] - (2 * speed[0] * xbox_controller->Joystick[0] / max_joystick_value);
00D64:  CLRF   5B
00D66:  CLRF   5A
00D68:  CLRF   59
00D6A:  MOVLW  80
00D6C:  MOVWF  58
00D6E:  MOVFF  46,5F
00D72:  MOVFF  45,5E
00D76:  MOVFF  44,5D
00D7A:  MOVFF  43,5C
00D7E:  CALL   055A
00D82:  MOVFF  03,50
00D86:  MOVFF  02,4F
00D8A:  MOVFF  01,4E
00D8E:  MOVFF  00,4D
00D92:  MOVFF  3F,FE9
00D96:  MOVFF  40,FEA
00D9A:  MOVFF  FEC,03
00D9E:  MOVF   FED,F
00DA0:  MOVFF  FEF,51
00DA4:  MOVFF  03,52
00DA8:  CALL   0512
00DAC:  MOVFF  50,5B
00DB0:  MOVFF  4F,5A
00DB4:  MOVFF  4E,59
00DB8:  MOVFF  4D,58
00DBC:  MOVFF  03,5F
00DC0:  MOVFF  02,5E
00DC4:  MOVFF  01,5D
00DC8:  MOVFF  00,5C
00DCC:  CALL   055A
00DD0:  MOVFF  03,50
00DD4:  MOVFF  02,4F
00DD8:  MOVFF  01,4E
00DDC:  MOVFF  00,4D
00DE0:  MOVFF  03,5F
00DE4:  MOVFF  02,5E
00DE8:  MOVFF  01,5D
00DEC:  MOVFF  00,5C
00DF0:  CLRF   x63
00DF2:  MOVLW  FE
00DF4:  MOVWF  x62
00DF6:  MOVLW  7F
00DF8:  MOVWF  x61
00DFA:  MOVLW  8D
00DFC:  MOVWF  x60
00DFE:  RCALL  064C
00E00:  MOVFF  FEA,4E
00E04:  MOVFF  FE9,4D
00E08:  BSF    FD8.1
00E0A:  MOVFF  46,5F
00E0E:  MOVFF  45,5E
00E12:  MOVFF  44,5D
00E16:  MOVFF  43,5C
00E1A:  MOVFF  03,63
00E1E:  MOVFF  02,62
00E22:  MOVFF  01,61
00E26:  MOVFF  00,60
00E2A:  RCALL  07A6
00E2C:  MOVFF  4E,FEA
00E30:  MOVFF  4D,FE9
00E34:  MOVFF  03,4A
00E38:  MOVFF  02,49
00E3C:  MOVFF  01,48
00E40:  MOVFF  00,47
....................         // Velocidad - (2 veces Velocidad * (Valor Joystick X / Valor maximo Joystick X))
....................     }
00E44:  BRA    0F92
....................     else                                        // El movimiento es a la izquierda
....................     {
....................         speed[1] = trigger_diff * 100.0 / max_trigger_value;
00E46:  MOVFF  4C,52
00E4A:  MOVFF  4B,51
00E4E:  CALL   0512
00E52:  MOVFF  03,5B
00E56:  MOVFF  02,5A
00E5A:  MOVFF  01,59
00E5E:  MOVFF  00,58
00E62:  CLRF   5F
00E64:  CLRF   5E
00E66:  MOVLW  48
00E68:  MOVWF  5D
00E6A:  MOVLW  85
00E6C:  MOVWF  5C
00E6E:  CALL   055A
00E72:  MOVFF  03,50
00E76:  MOVFF  02,4F
00E7A:  MOVFF  01,4E
00E7E:  MOVFF  00,4D
00E82:  MOVFF  03,5F
00E86:  MOVFF  02,5E
00E8A:  MOVFF  01,5D
00E8E:  MOVFF  00,5C
00E92:  CLRF   x63
00E94:  CLRF   x62
00E96:  MOVLW  7F
00E98:  MOVWF  x61
00E9A:  MOVLW  86
00E9C:  MOVWF  x60
00E9E:  CALL   064C
00EA2:  MOVFF  03,4A
00EA6:  MOVFF  02,49
00EAA:  MOVFF  01,48
00EAE:  MOVFF  00,47
....................         // Flotante de -100 a 100 que indica la velocidad y direccion de movimiento (+ adelante, - atras)
....................         speed[0] = speed[1] - (2 * speed[1] * xbox_controller->Joystick[0] / -32768.0);
00EB2:  CLRF   5B
00EB4:  CLRF   5A
00EB6:  CLRF   59
00EB8:  MOVLW  80
00EBA:  MOVWF  58
00EBC:  MOVFF  4A,5F
00EC0:  MOVFF  49,5E
00EC4:  MOVFF  48,5D
00EC8:  MOVFF  47,5C
00ECC:  CALL   055A
00ED0:  MOVFF  03,50
00ED4:  MOVFF  02,4F
00ED8:  MOVFF  01,4E
00EDC:  MOVFF  00,4D
00EE0:  MOVFF  3F,FE9
00EE4:  MOVFF  40,FEA
00EE8:  MOVFF  FEC,03
00EEC:  MOVF   FED,F
00EEE:  MOVFF  FEF,51
00EF2:  MOVFF  03,52
00EF6:  CALL   0512
00EFA:  MOVFF  50,5B
00EFE:  MOVFF  4F,5A
00F02:  MOVFF  4E,59
00F06:  MOVFF  4D,58
00F0A:  MOVFF  03,5F
00F0E:  MOVFF  02,5E
00F12:  MOVFF  01,5D
00F16:  MOVFF  00,5C
00F1A:  CALL   055A
00F1E:  MOVFF  03,50
00F22:  MOVFF  02,4F
00F26:  MOVFF  01,4E
00F2A:  MOVFF  00,4D
00F2E:  MOVFF  03,5F
00F32:  MOVFF  02,5E
00F36:  MOVFF  01,5D
00F3A:  MOVFF  00,5C
00F3E:  CLRF   x63
00F40:  CLRF   x62
00F42:  MOVLW  80
00F44:  MOVWF  x61
00F46:  MOVLW  8E
00F48:  MOVWF  x60
00F4A:  CALL   064C
00F4E:  MOVFF  FEA,4E
00F52:  MOVFF  FE9,4D
00F56:  BSF    FD8.1
00F58:  MOVFF  4A,5F
00F5C:  MOVFF  49,5E
00F60:  MOVFF  48,5D
00F64:  MOVFF  47,5C
00F68:  MOVFF  03,63
00F6C:  MOVFF  02,62
00F70:  MOVFF  01,61
00F74:  MOVFF  00,60
00F78:  RCALL  07A6
00F7A:  MOVFF  4E,FEA
00F7E:  MOVFF  4D,FE9
00F82:  MOVFF  03,46
00F86:  MOVFF  02,45
00F8A:  MOVFF  01,44
00F8E:  MOVFF  00,43
....................         // Velocidad - (2 veces Velocidad * (Valor Joystick X / Valor maximo Joystick X))
....................     }
.................... 
....................     // Enviamos movimiento a las llantas //
....................     motor_movement(&tires[0][0], speed[0]);      // Llanta delantera izquierda
00F92:  MOVFF  41,01
00F96:  MOVFF  42,03
00F9A:  MOVFF  42,50
00F9E:  MOVFF  41,4F
00FA2:  MOVFF  46,54
00FA6:  MOVFF  45,53
00FAA:  MOVFF  44,52
00FAE:  MOVFF  43,51
00FB2:  RCALL  0AC2
....................     motor_movement(&tires[1][0], speed[0]);      // Llanta trasera izquierda
00FB4:  MOVLW  0C
00FB6:  ADDWF  41,W
00FB8:  MOVWF  01
00FBA:  MOVLW  00
00FBC:  ADDWFC 42,W
00FBE:  MOVWF  03
00FC0:  MOVFF  01,4D
00FC4:  MOVWF  4E
00FC6:  MOVWF  50
00FC8:  MOVFF  01,4F
00FCC:  MOVFF  46,54
00FD0:  MOVFF  45,53
00FD4:  MOVFF  44,52
00FD8:  MOVFF  43,51
00FDC:  RCALL  0AC2
....................     
....................     motor_movement(&tires[0][1], speed[1]);      // Llanta delantera derecha
00FDE:  MOVLW  06
00FE0:  ADDWF  41,W
00FE2:  MOVWF  01
00FE4:  MOVLW  00
00FE6:  ADDWFC 42,W
00FE8:  MOVWF  03
00FEA:  MOVFF  01,4D
00FEE:  MOVWF  4E
00FF0:  MOVWF  50
00FF2:  MOVFF  01,4F
00FF6:  MOVFF  4A,54
00FFA:  MOVFF  49,53
00FFE:  MOVFF  48,52
01002:  MOVFF  47,51
01006:  RCALL  0AC2
....................     motor_movement(&tires[1][1], speed[1]);      // Llanta trasera derecha
01008:  MOVLW  12
0100A:  ADDWF  41,W
0100C:  MOVWF  01
0100E:  MOVLW  00
01010:  ADDWFC 42,W
01012:  MOVWF  03
01014:  MOVFF  01,4D
01018:  MOVWF  4E
0101A:  MOVWF  50
0101C:  MOVFF  01,4F
01020:  MOVFF  4A,54
01024:  MOVFF  49,53
01028:  MOVFF  48,52
0102C:  MOVFF  47,51
01030:  RCALL  0AC2
01032:  GOTO   111C (RETURN)
.................... }
.................... 
.................... /*
.................... Los gatillos establecen la velocidad maxima de giro, y la posicion del joystick establece como se repartira esta velocidad en las llantas, para poder hacer diferentes maniobras, por ejemlo:
.................... 
.................... * Cuanto mas pegado al maximo o minimo del eje Y, mayor sera la diferencia de velocidad entre las llantas de la izquierda con las de la derecha
.................... * Cuanto mas pegado al maximo o minimo del eje X, mayor sera la diferencia de velocidad entre las llantas de arriba y abajo
.................... 
.................... Por lo tanto: 
.................... * La llanta mas lejana a la direccion de movimiento en X tendra mas velocidad que la mas pegada
.................... * La llanta mas lejana a la direccion de movimiento en Y tendra mas velocidad que la mas pegada
.................... */ 
.................... 
.................... 
.................... // --------------------- Direccion de registros --------------------- //
.................... #BYTE       TRISA               = 0xF92
.................... #BYTE       TRISB               = 0xF93
.................... #BYTE       TRISC               = 0xF94
.................... #BIT        status_LED          = 0xF89.0   // LATA
.................... 
.................... #BYTE       INTCON              = 0xFF2
.................... #BIT        INT1IE              = 0xFF0.3   // INTCON3
.................... #BIT        INTEDG1             = 0xFF1.5   // INTCON2
.................... #BIT        RC1IE               = 0xF9D.5   // PIE1
.................... #BIT        IPEN                = 0xFD0.7   // RCON
.................... #BIT        RC1IP               = 0xF9F.5   // IPR1
.................... 
.................... // ----------------------- Variable Globales ------------------------ //
.................... struct motor_t  tires[2][2]   = 
.................... {
....................     {   // Llantas delanteras
....................         { 0xFBE, PIN_B3, PIN_B4 },  // Izquierda
....................         { 0xF67, PIN_B6, PIN_B7 }   // Derecha
....................     },
....................     {   // Llantas traseras
....................         { 0xF5E, PIN_A4, PIN_A5 },  // Izquierda
....................         { 0xF58, PIN_A6, PIN_A7 }   // Derecha
....................     }
.................... };
.................... 
.................... struct          controller_t xbox_controller;
.................... struct          bth_conection_t PC = { FALSE, FALSE };
.................... 
.................... 
.................... // -------------------------- Interrupciones ------------------------ //
.................... #INT_RDA
.................... void control_instructions()
*
002D2:  BTFSS  F9E.5
002D4:  BRA    02D2
002D6:  MOVFF  FAE,6C
.................... {
....................     int data = getch();
....................     
....................     if(data == '*')     // Recibimos caracter de inicio de datos
002DA:  MOVF   x6C,W
002DC:  SUBLW  2A
002DE:  BNZ   037C
....................     {           
....................         char XJoystick[8], YJoystick[8], LeftTrigger[5], RightTrigger[5];
....................         
....................         // Obtenemos cadenas de caracteres con los valores a recibir
....................         gets(XJoystick);
002E0:  CLRF   FEA
002E2:  MOVLW  6D
002E4:  MOVWF  FE9
002E6:  CLRF   FED
002E8:  BTFSS  F9E.5
002EA:  BRA    02E8
002EC:  MOVFF  FAE,FEC
002F0:  MOVLW  0D
002F2:  SUBWF  FEF,W
002F4:  BNZ   02E8
002F6:  CLRF   FEC
....................         gets(YJoystick);
002F8:  CLRF   FEA
002FA:  MOVLW  75
002FC:  MOVWF  FE9
002FE:  CLRF   FED
00300:  BTFSS  F9E.5
00302:  BRA    0300
00304:  MOVFF  FAE,FEC
00308:  MOVLW  0D
0030A:  SUBWF  FEF,W
0030C:  BNZ   0300
0030E:  CLRF   FEC
.................... 
....................         gets(LeftTrigger);
00310:  CLRF   FEA
00312:  MOVLW  7D
00314:  MOVWF  FE9
00316:  CLRF   FED
00318:  BTFSS  F9E.5
0031A:  BRA    0318
0031C:  MOVFF  FAE,FEC
00320:  MOVLW  0D
00322:  SUBWF  FEF,W
00324:  BNZ   0318
00326:  CLRF   FEC
....................         gets(RightTrigger);
00328:  CLRF   FEA
0032A:  MOVLW  82
0032C:  MOVWF  FE9
0032E:  CLRF   FED
00330:  BTFSS  F9E.5
00332:  BRA    0330
00334:  MOVFF  FAE,FEC
00338:  MOVLW  0D
0033A:  SUBWF  FEF,W
0033C:  BNZ   0330
0033E:  CLRF   FEC
.................... 
....................         // Realizamos la conversion y actualizamos los valores del control
....................         xbox_controller.Joystick[0] =  atol(XJoystick);
00340:  CLRF   x88
00342:  MOVLW  6D
00344:  MOVWF  x87
00346:  RCALL  0100
00348:  MOVFF  02,38
0034C:  MOVFF  01,37
....................         xbox_controller.Joystick[1] =  atol(YJoystick);
00350:  CLRF   x88
00352:  MOVLW  75
00354:  MOVWF  x87
00356:  RCALL  0100
00358:  MOVFF  02,3A
0035C:  MOVFF  01,39
....................         
....................         xbox_controller.Triggers[0] =  atol(LeftTrigger);
00360:  CLRF   x88
00362:  MOVLW  7D
00364:  MOVWF  x87
00366:  RCALL  0100
00368:  MOVFF  01,3B
....................         xbox_controller.Triggers[1] =  atol(RightTrigger);
0036C:  CLRF   x88
0036E:  MOVLW  82
00370:  MOVWF  x87
00372:  RCALL  0100
00374:  MOVFF  01,3C
.................... 
....................         // Actualizamos variables de conexion
....................         PC.updated_data = PC.IsConnected = TRUE;
00378:  BSF    3D.1
0037A:  BSF    3D.0
....................     }
0037C:  BCF    F9E.5
0037E:  GOTO   0060
.................... }
.................... 
.................... /* Inforamcion de variables
.................... * updated_data: Booleano para señalar que hubo una actualizacion de informacion y no ha sido aplicada.
....................     * updated_data = FALSE   : No hay nueva informacion
....................     * updated_data = TRUE    : Hay informacion pendiente de aplicar
.................... * isConnected: Booleno para saber el estatus de la conexion de bluetooth
.................... */
.................... 
.................... // ---------------------------- Funciones --------------------------- //
.................... void log_init()
.................... {
....................     // Configuracion de pines GPIO
....................     TRISA       = 0b00000000;
00382:  CLRF   F92
....................     TRISB       = 0b00000010;
00384:  MOVLW  02
00386:  MOVWF  F93
....................     TRISC       = 0b10000000;
00388:  MOVLW  80
0038A:  MOVWF  F94
.................... 
....................     INTCON = 0b11000000;
0038C:  MOVLW  C0
0038E:  MOVWF  FF2
.................... 
....................     // Configuracion de Interrupciones
....................     IPEN = RC1IE = RC1IP =  TRUE;       // Establecemos la interrupcion de recepcion serial como prioridad
00390:  BSF    F9F.5
00392:  BSF    F9D.5
00394:  BSF    FD0.7
00396:  GOTO   10D0 (RETURN)
.................... }
.................... 
.................... // ------------------------ Codigo Principal ----------------------- //
.................... void main()
*
01036:  CLRF   FF8
01038:  BCF    FD0.7
0103A:  BSF    07.7
0103C:  MOVLW  70
0103E:  MOVWF  FD3
01040:  BCF    F9B.6
01042:  BCF    F9B.7
01044:  BSF    FB8.3
01046:  MOVLW  A0
01048:  MOVWF  FAF
0104A:  MOVLW  01
0104C:  MOVWF  FB0
0104E:  MOVLW  A6
01050:  MOVWF  FAC
01052:  MOVLW  90
01054:  MOVWF  FAB
01056:  MOVLB  F
01058:  CLRF   x38
0105A:  CLRF   x39
0105C:  CLRF   x3A
0105E:  CLRF   F77
01060:  CLRF   F78
01062:  CLRF   F79
01064:  BRA    108C
01066:  DATA 02,00
01068:  DATA 19,00
0106A:  DATA 00,18
0106C:  DATA 00,1F
0106E:  DATA BE,0F
01070:  DATA 0B,7C
01072:  DATA 0C,7C
01074:  DATA 67,0F
01076:  DATA 0E,7C
01078:  DATA 0F,7C
0107A:  DATA 5E,0F
0107C:  DATA 04,7C
0107E:  DATA 05,7C
01080:  DATA 58,0F
01082:  DATA 06,7C
01084:  DATA 07,7C
01086:  DATA 01,00
01088:  DATA 3D,00
0108A:  DATA 00,00
0108C:  MOVLW  00
0108E:  MOVWF  FF8
01090:  MOVLW  10
01092:  MOVWF  FF7
01094:  MOVLW  66
01096:  MOVWF  FF6
01098:  TBLRD*+
0109A:  MOVF   FF5,W
0109C:  MOVWF  00
0109E:  XORLW  00
010A0:  BZ    10C8
010A2:  TBLRD*+
010A4:  MOVF   FF5,W
010A6:  MOVWF  01
010A8:  BTFSC  FE8.7
010AA:  BRA    10B6
010AC:  ANDLW  3F
010AE:  MOVWF  FEA
010B0:  TBLRD*+
010B2:  MOVFF  FF5,FE9
010B6:  BTFSC  01.6
010B8:  TBLRD*+
010BA:  BTFSS  01.6
010BC:  TBLRD*+
010BE:  MOVFF  FF5,FEE
010C2:  DCFSNZ 00,F
010C4:  BRA    1098
010C6:  BRA    10BA
010C8:  CLRF   FF8
.................... {
....................     log_init();
010CA:  MOVLB  0
010CC:  GOTO   0382
....................     motors_init(tires);
010D0:  CLRF   40
010D2:  MOVLW  1F
010D4:  MOVWF  3F
010D6:  GOTO   03B8
.................... 
....................     Connection_animation:    
....................     // Esperamos conexion bluetooth con una animacion del LED indicador
....................     for(int time = 0; !PC.IsConnected; time++, delay_ms(1))
010DA:  CLRF   3E
010DC:  BTFSC  3D.1
010DE:  BRA    1108
....................     {
....................         if(time == 200)
010E0:  MOVF   3E,W
010E2:  SUBLW  C8
010E4:  BNZ   10F6
....................         {
....................             status_LED ^= TRUE;
010E6:  MOVLW  00
010E8:  BTFSC  F89.0
010EA:  MOVLW  01
010EC:  XORLW  01
010EE:  BCF    F89.0
010F0:  BTFSC  FE8.0
010F2:  BSF    F89.0
....................             time = 0;
010F4:  CLRF   3E
....................         }
010F6:  MOVF   3E,W
010F8:  INCF   3E,F
010FA:  MOVLW  01
010FC:  MOVWF  3F
010FE:  MOVLB  0
01100:  GOTO   0438
01104:  MOVLB  0
01106:  BRA    10DC
....................     }
.................... 
....................     while (TRUE)
....................     {   
....................         /*
....................         if(!PC.IsConnected)                 // Si se pierde la conexion
....................         {
....................             // Aplicamos freno de corto cuando no hay conexion
....................             motor_movement(&tires[0][0]), motor_movement(&tires[0][1]);
....................             motor_movement(&tires[1][0]), motor_movement(&tires[1][1]);
....................             
....................             goto Connection_animation;
....................         }
....................         */
....................         //*/
.................... 
....................         // Si hay conexion
....................         if(PC.updated_data)                // Si se actualizo la posicion
01108:  BTFSS  3D.0
0110A:  BRA    111E
....................         {
....................             // Enviamos instrucciones a motores
....................             drive_tires(&xbox_controller, tires);
0110C:  CLRF   40
0110E:  MOVLW  37
01110:  MOVWF  3F
01112:  CLRF   42
01114:  MOVLW  1F
01116:  MOVWF  41
01118:  MOVLB  0
0111A:  BRA    0C3A
....................             PC.updated_data = FALSE;
0111C:  BCF    3D.0
....................         }
0111E:  BRA    1108
....................         //*/
.................... 
....................         /*/ Revision de  almacenamiento de variables
....................         printf("Joystick X = %ld | Y = %ld\r\n", xbox_controller.Joystick[0], xbox_controller.Joystick[1]);
....................         printf("Triggers 1 =  %u | 2 = %u\r\n", xbox_controller.Triggers[0],  xbox_controller.Triggers[1]);
....................         delay_ms(100);
....................         //*/
....................     }
.................... }
.................... 
01120:  SLEEP 
.................... /*
.................... El codigo esta compuesto de las siguientes partes
.................... 
....................     * Interrupcion de recepcion de datos en puerto serial: Recibe los datos actualizados del control de XBOX desde el programa de computadora en C#
.................... 
....................     * Funcion principal: Inicializa los registros, y mueve las ruedas cuando hay nueva informacion
.................... */

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY FCMEN IESO
   Word  2: 3C1E   PUT BROWNOUT BORV19 NOWDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2B5 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
